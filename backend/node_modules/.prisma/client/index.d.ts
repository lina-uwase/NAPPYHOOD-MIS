
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Customer
 * 
 */
export type Customer = $Result.DefaultSelection<Prisma.$CustomerPayload>
/**
 * Model Service
 * 
 */
export type Service = $Result.DefaultSelection<Prisma.$ServicePayload>
/**
 * Model Visit
 * 
 */
export type Visit = $Result.DefaultSelection<Prisma.$VisitPayload>
/**
 * Model VisitService
 * 
 */
export type VisitService = $Result.DefaultSelection<Prisma.$VisitServicePayload>
/**
 * Model VisitStaff
 * 
 */
export type VisitStaff = $Result.DefaultSelection<Prisma.$VisitStaffPayload>
/**
 * Model DiscountRule
 * 
 */
export type DiscountRule = $Result.DefaultSelection<Prisma.$DiscountRulePayload>
/**
 * Model VisitDiscount
 * 
 */
export type VisitDiscount = $Result.DefaultSelection<Prisma.$VisitDiscountPayload>
/**
 * Model CustomerDiscount
 * 
 */
export type CustomerDiscount = $Result.DefaultSelection<Prisma.$CustomerDiscountPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const Role: {
  ADMIN: 'ADMIN',
  MANAGER: 'MANAGER',
  STAFF: 'STAFF'
};

export type Role = (typeof Role)[keyof typeof Role]


export const Gender: {
  MALE: 'MALE',
  FEMALE: 'FEMALE',
  OTHER: 'OTHER'
};

export type Gender = (typeof Gender)[keyof typeof Gender]


export const ServiceCategory: {
  HAIR_TREATMENTS: 'HAIR_TREATMENTS',
  TWIST_HAIRSTYLE: 'TWIST_HAIRSTYLE',
  CORNROWS_BRAIDS: 'CORNROWS_BRAIDS',
  STRAWSET_CURLS: 'STRAWSET_CURLS',
  STYLING_SERVICE: 'STYLING_SERVICE',
  SPECIAL_OFFERS: 'SPECIAL_OFFERS'
};

export type ServiceCategory = (typeof ServiceCategory)[keyof typeof ServiceCategory]


export const DiscountType: {
  SIXTH_VISIT: 'SIXTH_VISIT',
  BIRTHDAY_MONTH: 'BIRTHDAY_MONTH',
  LOYALTY_POINTS: 'LOYALTY_POINTS',
  SERVICE_COMBO: 'SERVICE_COMBO',
  BRING_OWN_PRODUCT: 'BRING_OWN_PRODUCT'
};

export type DiscountType = (typeof DiscountType)[keyof typeof DiscountType]

}

export type Role = $Enums.Role

export const Role: typeof $Enums.Role

export type Gender = $Enums.Gender

export const Gender: typeof $Enums.Gender

export type ServiceCategory = $Enums.ServiceCategory

export const ServiceCategory: typeof $Enums.ServiceCategory

export type DiscountType = $Enums.DiscountType

export const DiscountType: typeof $Enums.DiscountType

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.customer`: Exposes CRUD operations for the **Customer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Customers
    * const customers = await prisma.customer.findMany()
    * ```
    */
  get customer(): Prisma.CustomerDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.service`: Exposes CRUD operations for the **Service** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Services
    * const services = await prisma.service.findMany()
    * ```
    */
  get service(): Prisma.ServiceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.visit`: Exposes CRUD operations for the **Visit** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Visits
    * const visits = await prisma.visit.findMany()
    * ```
    */
  get visit(): Prisma.VisitDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.visitService`: Exposes CRUD operations for the **VisitService** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VisitServices
    * const visitServices = await prisma.visitService.findMany()
    * ```
    */
  get visitService(): Prisma.VisitServiceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.visitStaff`: Exposes CRUD operations for the **VisitStaff** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VisitStaffs
    * const visitStaffs = await prisma.visitStaff.findMany()
    * ```
    */
  get visitStaff(): Prisma.VisitStaffDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.discountRule`: Exposes CRUD operations for the **DiscountRule** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DiscountRules
    * const discountRules = await prisma.discountRule.findMany()
    * ```
    */
  get discountRule(): Prisma.DiscountRuleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.visitDiscount`: Exposes CRUD operations for the **VisitDiscount** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VisitDiscounts
    * const visitDiscounts = await prisma.visitDiscount.findMany()
    * ```
    */
  get visitDiscount(): Prisma.VisitDiscountDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.customerDiscount`: Exposes CRUD operations for the **CustomerDiscount** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CustomerDiscounts
    * const customerDiscounts = await prisma.customerDiscount.findMany()
    * ```
    */
  get customerDiscount(): Prisma.CustomerDiscountDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.16.2
   * Query Engine version: 1c57fdcd7e44b29b9313256c76699e91c3ac3c43
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Customer: 'Customer',
    Service: 'Service',
    Visit: 'Visit',
    VisitService: 'VisitService',
    VisitStaff: 'VisitStaff',
    DiscountRule: 'DiscountRule',
    VisitDiscount: 'VisitDiscount',
    CustomerDiscount: 'CustomerDiscount'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "customer" | "service" | "visit" | "visitService" | "visitStaff" | "discountRule" | "visitDiscount" | "customerDiscount"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Customer: {
        payload: Prisma.$CustomerPayload<ExtArgs>
        fields: Prisma.CustomerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CustomerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CustomerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          findFirst: {
            args: Prisma.CustomerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CustomerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          findMany: {
            args: Prisma.CustomerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>[]
          }
          create: {
            args: Prisma.CustomerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          createMany: {
            args: Prisma.CustomerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CustomerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>[]
          }
          delete: {
            args: Prisma.CustomerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          update: {
            args: Prisma.CustomerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          deleteMany: {
            args: Prisma.CustomerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CustomerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CustomerUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>[]
          }
          upsert: {
            args: Prisma.CustomerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          aggregate: {
            args: Prisma.CustomerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCustomer>
          }
          groupBy: {
            args: Prisma.CustomerGroupByArgs<ExtArgs>
            result: $Utils.Optional<CustomerGroupByOutputType>[]
          }
          count: {
            args: Prisma.CustomerCountArgs<ExtArgs>
            result: $Utils.Optional<CustomerCountAggregateOutputType> | number
          }
        }
      }
      Service: {
        payload: Prisma.$ServicePayload<ExtArgs>
        fields: Prisma.ServiceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ServiceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ServiceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          findFirst: {
            args: Prisma.ServiceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ServiceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          findMany: {
            args: Prisma.ServiceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>[]
          }
          create: {
            args: Prisma.ServiceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          createMany: {
            args: Prisma.ServiceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ServiceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>[]
          }
          delete: {
            args: Prisma.ServiceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          update: {
            args: Prisma.ServiceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          deleteMany: {
            args: Prisma.ServiceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ServiceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ServiceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>[]
          }
          upsert: {
            args: Prisma.ServiceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          aggregate: {
            args: Prisma.ServiceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateService>
          }
          groupBy: {
            args: Prisma.ServiceGroupByArgs<ExtArgs>
            result: $Utils.Optional<ServiceGroupByOutputType>[]
          }
          count: {
            args: Prisma.ServiceCountArgs<ExtArgs>
            result: $Utils.Optional<ServiceCountAggregateOutputType> | number
          }
        }
      }
      Visit: {
        payload: Prisma.$VisitPayload<ExtArgs>
        fields: Prisma.VisitFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VisitFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VisitFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitPayload>
          }
          findFirst: {
            args: Prisma.VisitFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VisitFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitPayload>
          }
          findMany: {
            args: Prisma.VisitFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitPayload>[]
          }
          create: {
            args: Prisma.VisitCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitPayload>
          }
          createMany: {
            args: Prisma.VisitCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VisitCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitPayload>[]
          }
          delete: {
            args: Prisma.VisitDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitPayload>
          }
          update: {
            args: Prisma.VisitUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitPayload>
          }
          deleteMany: {
            args: Prisma.VisitDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VisitUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VisitUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitPayload>[]
          }
          upsert: {
            args: Prisma.VisitUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitPayload>
          }
          aggregate: {
            args: Prisma.VisitAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVisit>
          }
          groupBy: {
            args: Prisma.VisitGroupByArgs<ExtArgs>
            result: $Utils.Optional<VisitGroupByOutputType>[]
          }
          count: {
            args: Prisma.VisitCountArgs<ExtArgs>
            result: $Utils.Optional<VisitCountAggregateOutputType> | number
          }
        }
      }
      VisitService: {
        payload: Prisma.$VisitServicePayload<ExtArgs>
        fields: Prisma.VisitServiceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VisitServiceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitServicePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VisitServiceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitServicePayload>
          }
          findFirst: {
            args: Prisma.VisitServiceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitServicePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VisitServiceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitServicePayload>
          }
          findMany: {
            args: Prisma.VisitServiceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitServicePayload>[]
          }
          create: {
            args: Prisma.VisitServiceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitServicePayload>
          }
          createMany: {
            args: Prisma.VisitServiceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VisitServiceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitServicePayload>[]
          }
          delete: {
            args: Prisma.VisitServiceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitServicePayload>
          }
          update: {
            args: Prisma.VisitServiceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitServicePayload>
          }
          deleteMany: {
            args: Prisma.VisitServiceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VisitServiceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VisitServiceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitServicePayload>[]
          }
          upsert: {
            args: Prisma.VisitServiceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitServicePayload>
          }
          aggregate: {
            args: Prisma.VisitServiceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVisitService>
          }
          groupBy: {
            args: Prisma.VisitServiceGroupByArgs<ExtArgs>
            result: $Utils.Optional<VisitServiceGroupByOutputType>[]
          }
          count: {
            args: Prisma.VisitServiceCountArgs<ExtArgs>
            result: $Utils.Optional<VisitServiceCountAggregateOutputType> | number
          }
        }
      }
      VisitStaff: {
        payload: Prisma.$VisitStaffPayload<ExtArgs>
        fields: Prisma.VisitStaffFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VisitStaffFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitStaffPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VisitStaffFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitStaffPayload>
          }
          findFirst: {
            args: Prisma.VisitStaffFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitStaffPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VisitStaffFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitStaffPayload>
          }
          findMany: {
            args: Prisma.VisitStaffFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitStaffPayload>[]
          }
          create: {
            args: Prisma.VisitStaffCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitStaffPayload>
          }
          createMany: {
            args: Prisma.VisitStaffCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VisitStaffCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitStaffPayload>[]
          }
          delete: {
            args: Prisma.VisitStaffDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitStaffPayload>
          }
          update: {
            args: Prisma.VisitStaffUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitStaffPayload>
          }
          deleteMany: {
            args: Prisma.VisitStaffDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VisitStaffUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VisitStaffUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitStaffPayload>[]
          }
          upsert: {
            args: Prisma.VisitStaffUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitStaffPayload>
          }
          aggregate: {
            args: Prisma.VisitStaffAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVisitStaff>
          }
          groupBy: {
            args: Prisma.VisitStaffGroupByArgs<ExtArgs>
            result: $Utils.Optional<VisitStaffGroupByOutputType>[]
          }
          count: {
            args: Prisma.VisitStaffCountArgs<ExtArgs>
            result: $Utils.Optional<VisitStaffCountAggregateOutputType> | number
          }
        }
      }
      DiscountRule: {
        payload: Prisma.$DiscountRulePayload<ExtArgs>
        fields: Prisma.DiscountRuleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DiscountRuleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiscountRulePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DiscountRuleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiscountRulePayload>
          }
          findFirst: {
            args: Prisma.DiscountRuleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiscountRulePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DiscountRuleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiscountRulePayload>
          }
          findMany: {
            args: Prisma.DiscountRuleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiscountRulePayload>[]
          }
          create: {
            args: Prisma.DiscountRuleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiscountRulePayload>
          }
          createMany: {
            args: Prisma.DiscountRuleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DiscountRuleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiscountRulePayload>[]
          }
          delete: {
            args: Prisma.DiscountRuleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiscountRulePayload>
          }
          update: {
            args: Prisma.DiscountRuleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiscountRulePayload>
          }
          deleteMany: {
            args: Prisma.DiscountRuleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DiscountRuleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DiscountRuleUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiscountRulePayload>[]
          }
          upsert: {
            args: Prisma.DiscountRuleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiscountRulePayload>
          }
          aggregate: {
            args: Prisma.DiscountRuleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDiscountRule>
          }
          groupBy: {
            args: Prisma.DiscountRuleGroupByArgs<ExtArgs>
            result: $Utils.Optional<DiscountRuleGroupByOutputType>[]
          }
          count: {
            args: Prisma.DiscountRuleCountArgs<ExtArgs>
            result: $Utils.Optional<DiscountRuleCountAggregateOutputType> | number
          }
        }
      }
      VisitDiscount: {
        payload: Prisma.$VisitDiscountPayload<ExtArgs>
        fields: Prisma.VisitDiscountFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VisitDiscountFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitDiscountPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VisitDiscountFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitDiscountPayload>
          }
          findFirst: {
            args: Prisma.VisitDiscountFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitDiscountPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VisitDiscountFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitDiscountPayload>
          }
          findMany: {
            args: Prisma.VisitDiscountFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitDiscountPayload>[]
          }
          create: {
            args: Prisma.VisitDiscountCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitDiscountPayload>
          }
          createMany: {
            args: Prisma.VisitDiscountCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VisitDiscountCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitDiscountPayload>[]
          }
          delete: {
            args: Prisma.VisitDiscountDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitDiscountPayload>
          }
          update: {
            args: Prisma.VisitDiscountUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitDiscountPayload>
          }
          deleteMany: {
            args: Prisma.VisitDiscountDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VisitDiscountUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VisitDiscountUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitDiscountPayload>[]
          }
          upsert: {
            args: Prisma.VisitDiscountUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitDiscountPayload>
          }
          aggregate: {
            args: Prisma.VisitDiscountAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVisitDiscount>
          }
          groupBy: {
            args: Prisma.VisitDiscountGroupByArgs<ExtArgs>
            result: $Utils.Optional<VisitDiscountGroupByOutputType>[]
          }
          count: {
            args: Prisma.VisitDiscountCountArgs<ExtArgs>
            result: $Utils.Optional<VisitDiscountCountAggregateOutputType> | number
          }
        }
      }
      CustomerDiscount: {
        payload: Prisma.$CustomerDiscountPayload<ExtArgs>
        fields: Prisma.CustomerDiscountFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CustomerDiscountFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerDiscountPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CustomerDiscountFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerDiscountPayload>
          }
          findFirst: {
            args: Prisma.CustomerDiscountFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerDiscountPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CustomerDiscountFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerDiscountPayload>
          }
          findMany: {
            args: Prisma.CustomerDiscountFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerDiscountPayload>[]
          }
          create: {
            args: Prisma.CustomerDiscountCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerDiscountPayload>
          }
          createMany: {
            args: Prisma.CustomerDiscountCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CustomerDiscountCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerDiscountPayload>[]
          }
          delete: {
            args: Prisma.CustomerDiscountDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerDiscountPayload>
          }
          update: {
            args: Prisma.CustomerDiscountUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerDiscountPayload>
          }
          deleteMany: {
            args: Prisma.CustomerDiscountDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CustomerDiscountUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CustomerDiscountUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerDiscountPayload>[]
          }
          upsert: {
            args: Prisma.CustomerDiscountUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerDiscountPayload>
          }
          aggregate: {
            args: Prisma.CustomerDiscountAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCustomerDiscount>
          }
          groupBy: {
            args: Prisma.CustomerDiscountGroupByArgs<ExtArgs>
            result: $Utils.Optional<CustomerDiscountGroupByOutputType>[]
          }
          count: {
            args: Prisma.CustomerDiscountCountArgs<ExtArgs>
            result: $Utils.Optional<CustomerDiscountCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory | null
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    customer?: CustomerOmit
    service?: ServiceOmit
    visit?: VisitOmit
    visitService?: VisitServiceOmit
    visitStaff?: VisitStaffOmit
    discountRule?: DiscountRuleOmit
    visitDiscount?: VisitDiscountOmit
    customerDiscount?: CustomerDiscountOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    visits: number
    staffVisits: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    visits?: boolean | UserCountOutputTypeCountVisitsArgs
    staffVisits?: boolean | UserCountOutputTypeCountStaffVisitsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountVisitsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VisitWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountStaffVisitsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VisitStaffWhereInput
  }


  /**
   * Count Type CustomerCountOutputType
   */

  export type CustomerCountOutputType = {
    visits: number
    discounts: number
  }

  export type CustomerCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    visits?: boolean | CustomerCountOutputTypeCountVisitsArgs
    discounts?: boolean | CustomerCountOutputTypeCountDiscountsArgs
  }

  // Custom InputTypes
  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerCountOutputType
     */
    select?: CustomerCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeCountVisitsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VisitWhereInput
  }

  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeCountDiscountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomerDiscountWhereInput
  }


  /**
   * Count Type ServiceCountOutputType
   */

  export type ServiceCountOutputType = {
    visitServices: number
  }

  export type ServiceCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    visitServices?: boolean | ServiceCountOutputTypeCountVisitServicesArgs
  }

  // Custom InputTypes
  /**
   * ServiceCountOutputType without action
   */
  export type ServiceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceCountOutputType
     */
    select?: ServiceCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ServiceCountOutputType without action
   */
  export type ServiceCountOutputTypeCountVisitServicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VisitServiceWhereInput
  }


  /**
   * Count Type VisitCountOutputType
   */

  export type VisitCountOutputType = {
    services: number
    staff: number
    discounts: number
  }

  export type VisitCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    services?: boolean | VisitCountOutputTypeCountServicesArgs
    staff?: boolean | VisitCountOutputTypeCountStaffArgs
    discounts?: boolean | VisitCountOutputTypeCountDiscountsArgs
  }

  // Custom InputTypes
  /**
   * VisitCountOutputType without action
   */
  export type VisitCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisitCountOutputType
     */
    select?: VisitCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * VisitCountOutputType without action
   */
  export type VisitCountOutputTypeCountServicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VisitServiceWhereInput
  }

  /**
   * VisitCountOutputType without action
   */
  export type VisitCountOutputTypeCountStaffArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VisitStaffWhereInput
  }

  /**
   * VisitCountOutputType without action
   */
  export type VisitCountOutputTypeCountDiscountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VisitDiscountWhereInput
  }


  /**
   * Count Type DiscountRuleCountOutputType
   */

  export type DiscountRuleCountOutputType = {
    visitDiscounts: number
    customerDiscounts: number
  }

  export type DiscountRuleCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    visitDiscounts?: boolean | DiscountRuleCountOutputTypeCountVisitDiscountsArgs
    customerDiscounts?: boolean | DiscountRuleCountOutputTypeCountCustomerDiscountsArgs
  }

  // Custom InputTypes
  /**
   * DiscountRuleCountOutputType without action
   */
  export type DiscountRuleCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DiscountRuleCountOutputType
     */
    select?: DiscountRuleCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DiscountRuleCountOutputType without action
   */
  export type DiscountRuleCountOutputTypeCountVisitDiscountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VisitDiscountWhereInput
  }

  /**
   * DiscountRuleCountOutputType without action
   */
  export type DiscountRuleCountOutputTypeCountCustomerDiscountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomerDiscountWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    password: string | null
    role: $Enums.Role | null
    phone: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    password: string | null
    role: $Enums.Role | null
    phone: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    name: number
    email: number
    password: number
    role: number
    phone: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    name?: true
    email?: true
    password?: true
    role?: true
    phone?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    name?: true
    email?: true
    password?: true
    role?: true
    phone?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    name?: true
    email?: true
    password?: true
    role?: true
    phone?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    name: string
    email: string
    password: string
    role: $Enums.Role
    phone: string | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    password?: boolean
    role?: boolean
    phone?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    visits?: boolean | User$visitsArgs<ExtArgs>
    staffVisits?: boolean | User$staffVisitsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    password?: boolean
    role?: boolean
    phone?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    password?: boolean
    role?: boolean
    phone?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    name?: boolean
    email?: boolean
    password?: boolean
    role?: boolean
    phone?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "email" | "password" | "role" | "phone" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    visits?: boolean | User$visitsArgs<ExtArgs>
    staffVisits?: boolean | User$staffVisitsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      visits: Prisma.$VisitPayload<ExtArgs>[]
      staffVisits: Prisma.$VisitStaffPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      email: string
      password: string
      role: $Enums.Role
      phone: string | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    visits<T extends User$visitsArgs<ExtArgs> = {}>(args?: Subset<T, User$visitsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VisitPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    staffVisits<T extends User$staffVisitsArgs<ExtArgs> = {}>(args?: Subset<T, User$staffVisitsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VisitStaffPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'Role'>
    readonly phone: FieldRef<"User", 'String'>
    readonly isActive: FieldRef<"User", 'Boolean'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.visits
   */
  export type User$visitsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Visit
     */
    select?: VisitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Visit
     */
    omit?: VisitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitInclude<ExtArgs> | null
    where?: VisitWhereInput
    orderBy?: VisitOrderByWithRelationInput | VisitOrderByWithRelationInput[]
    cursor?: VisitWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VisitScalarFieldEnum | VisitScalarFieldEnum[]
  }

  /**
   * User.staffVisits
   */
  export type User$staffVisitsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisitStaff
     */
    select?: VisitStaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VisitStaff
     */
    omit?: VisitStaffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitStaffInclude<ExtArgs> | null
    where?: VisitStaffWhereInput
    orderBy?: VisitStaffOrderByWithRelationInput | VisitStaffOrderByWithRelationInput[]
    cursor?: VisitStaffWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VisitStaffScalarFieldEnum | VisitStaffScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Customer
   */

  export type AggregateCustomer = {
    _count: CustomerCountAggregateOutputType | null
    _avg: CustomerAvgAggregateOutputType | null
    _sum: CustomerSumAggregateOutputType | null
    _min: CustomerMinAggregateOutputType | null
    _max: CustomerMaxAggregateOutputType | null
  }

  export type CustomerAvgAggregateOutputType = {
    birthDay: number | null
    birthMonth: number | null
    birthYear: number | null
    visitCount: number | null
    loyaltyPoints: number | null
    totalSpent: Decimal | null
  }

  export type CustomerSumAggregateOutputType = {
    birthDay: number | null
    birthMonth: number | null
    birthYear: number | null
    visitCount: number | null
    loyaltyPoints: number | null
    totalSpent: Decimal | null
  }

  export type CustomerMinAggregateOutputType = {
    id: string | null
    fullName: string | null
    gender: $Enums.Gender | null
    location: string | null
    district: string | null
    province: string | null
    phone: string | null
    email: string | null
    birthDay: number | null
    birthMonth: number | null
    birthYear: number | null
    visitCount: number | null
    loyaltyPoints: number | null
    totalSpent: Decimal | null
    lastVisit: Date | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CustomerMaxAggregateOutputType = {
    id: string | null
    fullName: string | null
    gender: $Enums.Gender | null
    location: string | null
    district: string | null
    province: string | null
    phone: string | null
    email: string | null
    birthDay: number | null
    birthMonth: number | null
    birthYear: number | null
    visitCount: number | null
    loyaltyPoints: number | null
    totalSpent: Decimal | null
    lastVisit: Date | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CustomerCountAggregateOutputType = {
    id: number
    fullName: number
    gender: number
    location: number
    district: number
    province: number
    phone: number
    email: number
    birthDay: number
    birthMonth: number
    birthYear: number
    visitCount: number
    loyaltyPoints: number
    totalSpent: number
    lastVisit: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CustomerAvgAggregateInputType = {
    birthDay?: true
    birthMonth?: true
    birthYear?: true
    visitCount?: true
    loyaltyPoints?: true
    totalSpent?: true
  }

  export type CustomerSumAggregateInputType = {
    birthDay?: true
    birthMonth?: true
    birthYear?: true
    visitCount?: true
    loyaltyPoints?: true
    totalSpent?: true
  }

  export type CustomerMinAggregateInputType = {
    id?: true
    fullName?: true
    gender?: true
    location?: true
    district?: true
    province?: true
    phone?: true
    email?: true
    birthDay?: true
    birthMonth?: true
    birthYear?: true
    visitCount?: true
    loyaltyPoints?: true
    totalSpent?: true
    lastVisit?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CustomerMaxAggregateInputType = {
    id?: true
    fullName?: true
    gender?: true
    location?: true
    district?: true
    province?: true
    phone?: true
    email?: true
    birthDay?: true
    birthMonth?: true
    birthYear?: true
    visitCount?: true
    loyaltyPoints?: true
    totalSpent?: true
    lastVisit?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CustomerCountAggregateInputType = {
    id?: true
    fullName?: true
    gender?: true
    location?: true
    district?: true
    province?: true
    phone?: true
    email?: true
    birthDay?: true
    birthMonth?: true
    birthYear?: true
    visitCount?: true
    loyaltyPoints?: true
    totalSpent?: true
    lastVisit?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CustomerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Customer to aggregate.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Customers
    **/
    _count?: true | CustomerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CustomerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CustomerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CustomerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CustomerMaxAggregateInputType
  }

  export type GetCustomerAggregateType<T extends CustomerAggregateArgs> = {
        [P in keyof T & keyof AggregateCustomer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCustomer[P]>
      : GetScalarType<T[P], AggregateCustomer[P]>
  }




  export type CustomerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomerWhereInput
    orderBy?: CustomerOrderByWithAggregationInput | CustomerOrderByWithAggregationInput[]
    by: CustomerScalarFieldEnum[] | CustomerScalarFieldEnum
    having?: CustomerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CustomerCountAggregateInputType | true
    _avg?: CustomerAvgAggregateInputType
    _sum?: CustomerSumAggregateInputType
    _min?: CustomerMinAggregateInputType
    _max?: CustomerMaxAggregateInputType
  }

  export type CustomerGroupByOutputType = {
    id: string
    fullName: string
    gender: $Enums.Gender
    location: string
    district: string
    province: string
    phone: string
    email: string | null
    birthDay: number
    birthMonth: number
    birthYear: number | null
    visitCount: number
    loyaltyPoints: number
    totalSpent: Decimal
    lastVisit: Date | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: CustomerCountAggregateOutputType | null
    _avg: CustomerAvgAggregateOutputType | null
    _sum: CustomerSumAggregateOutputType | null
    _min: CustomerMinAggregateOutputType | null
    _max: CustomerMaxAggregateOutputType | null
  }

  type GetCustomerGroupByPayload<T extends CustomerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CustomerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CustomerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CustomerGroupByOutputType[P]>
            : GetScalarType<T[P], CustomerGroupByOutputType[P]>
        }
      >
    >


  export type CustomerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    fullName?: boolean
    gender?: boolean
    location?: boolean
    district?: boolean
    province?: boolean
    phone?: boolean
    email?: boolean
    birthDay?: boolean
    birthMonth?: boolean
    birthYear?: boolean
    visitCount?: boolean
    loyaltyPoints?: boolean
    totalSpent?: boolean
    lastVisit?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    visits?: boolean | Customer$visitsArgs<ExtArgs>
    discounts?: boolean | Customer$discountsArgs<ExtArgs>
    _count?: boolean | CustomerCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customer"]>

  export type CustomerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    fullName?: boolean
    gender?: boolean
    location?: boolean
    district?: boolean
    province?: boolean
    phone?: boolean
    email?: boolean
    birthDay?: boolean
    birthMonth?: boolean
    birthYear?: boolean
    visitCount?: boolean
    loyaltyPoints?: boolean
    totalSpent?: boolean
    lastVisit?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["customer"]>

  export type CustomerSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    fullName?: boolean
    gender?: boolean
    location?: boolean
    district?: boolean
    province?: boolean
    phone?: boolean
    email?: boolean
    birthDay?: boolean
    birthMonth?: boolean
    birthYear?: boolean
    visitCount?: boolean
    loyaltyPoints?: boolean
    totalSpent?: boolean
    lastVisit?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["customer"]>

  export type CustomerSelectScalar = {
    id?: boolean
    fullName?: boolean
    gender?: boolean
    location?: boolean
    district?: boolean
    province?: boolean
    phone?: boolean
    email?: boolean
    birthDay?: boolean
    birthMonth?: boolean
    birthYear?: boolean
    visitCount?: boolean
    loyaltyPoints?: boolean
    totalSpent?: boolean
    lastVisit?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CustomerOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "fullName" | "gender" | "location" | "district" | "province" | "phone" | "email" | "birthDay" | "birthMonth" | "birthYear" | "visitCount" | "loyaltyPoints" | "totalSpent" | "lastVisit" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["customer"]>
  export type CustomerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    visits?: boolean | Customer$visitsArgs<ExtArgs>
    discounts?: boolean | Customer$discountsArgs<ExtArgs>
    _count?: boolean | CustomerCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CustomerIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type CustomerIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $CustomerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Customer"
    objects: {
      visits: Prisma.$VisitPayload<ExtArgs>[]
      discounts: Prisma.$CustomerDiscountPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      fullName: string
      gender: $Enums.Gender
      location: string
      district: string
      province: string
      phone: string
      email: string | null
      birthDay: number
      birthMonth: number
      birthYear: number | null
      visitCount: number
      loyaltyPoints: number
      totalSpent: Prisma.Decimal
      lastVisit: Date | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["customer"]>
    composites: {}
  }

  type CustomerGetPayload<S extends boolean | null | undefined | CustomerDefaultArgs> = $Result.GetResult<Prisma.$CustomerPayload, S>

  type CustomerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CustomerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CustomerCountAggregateInputType | true
    }

  export interface CustomerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Customer'], meta: { name: 'Customer' } }
    /**
     * Find zero or one Customer that matches the filter.
     * @param {CustomerFindUniqueArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CustomerFindUniqueArgs>(args: SelectSubset<T, CustomerFindUniqueArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Customer that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CustomerFindUniqueOrThrowArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CustomerFindUniqueOrThrowArgs>(args: SelectSubset<T, CustomerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Customer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerFindFirstArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CustomerFindFirstArgs>(args?: SelectSubset<T, CustomerFindFirstArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Customer that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerFindFirstOrThrowArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CustomerFindFirstOrThrowArgs>(args?: SelectSubset<T, CustomerFindFirstOrThrowArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Customers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Customers
     * const customers = await prisma.customer.findMany()
     * 
     * // Get first 10 Customers
     * const customers = await prisma.customer.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const customerWithIdOnly = await prisma.customer.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CustomerFindManyArgs>(args?: SelectSubset<T, CustomerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Customer.
     * @param {CustomerCreateArgs} args - Arguments to create a Customer.
     * @example
     * // Create one Customer
     * const Customer = await prisma.customer.create({
     *   data: {
     *     // ... data to create a Customer
     *   }
     * })
     * 
     */
    create<T extends CustomerCreateArgs>(args: SelectSubset<T, CustomerCreateArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Customers.
     * @param {CustomerCreateManyArgs} args - Arguments to create many Customers.
     * @example
     * // Create many Customers
     * const customer = await prisma.customer.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CustomerCreateManyArgs>(args?: SelectSubset<T, CustomerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Customers and returns the data saved in the database.
     * @param {CustomerCreateManyAndReturnArgs} args - Arguments to create many Customers.
     * @example
     * // Create many Customers
     * const customer = await prisma.customer.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Customers and only return the `id`
     * const customerWithIdOnly = await prisma.customer.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CustomerCreateManyAndReturnArgs>(args?: SelectSubset<T, CustomerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Customer.
     * @param {CustomerDeleteArgs} args - Arguments to delete one Customer.
     * @example
     * // Delete one Customer
     * const Customer = await prisma.customer.delete({
     *   where: {
     *     // ... filter to delete one Customer
     *   }
     * })
     * 
     */
    delete<T extends CustomerDeleteArgs>(args: SelectSubset<T, CustomerDeleteArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Customer.
     * @param {CustomerUpdateArgs} args - Arguments to update one Customer.
     * @example
     * // Update one Customer
     * const customer = await prisma.customer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CustomerUpdateArgs>(args: SelectSubset<T, CustomerUpdateArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Customers.
     * @param {CustomerDeleteManyArgs} args - Arguments to filter Customers to delete.
     * @example
     * // Delete a few Customers
     * const { count } = await prisma.customer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CustomerDeleteManyArgs>(args?: SelectSubset<T, CustomerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Customers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Customers
     * const customer = await prisma.customer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CustomerUpdateManyArgs>(args: SelectSubset<T, CustomerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Customers and returns the data updated in the database.
     * @param {CustomerUpdateManyAndReturnArgs} args - Arguments to update many Customers.
     * @example
     * // Update many Customers
     * const customer = await prisma.customer.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Customers and only return the `id`
     * const customerWithIdOnly = await prisma.customer.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CustomerUpdateManyAndReturnArgs>(args: SelectSubset<T, CustomerUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Customer.
     * @param {CustomerUpsertArgs} args - Arguments to update or create a Customer.
     * @example
     * // Update or create a Customer
     * const customer = await prisma.customer.upsert({
     *   create: {
     *     // ... data to create a Customer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Customer we want to update
     *   }
     * })
     */
    upsert<T extends CustomerUpsertArgs>(args: SelectSubset<T, CustomerUpsertArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Customers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerCountArgs} args - Arguments to filter Customers to count.
     * @example
     * // Count the number of Customers
     * const count = await prisma.customer.count({
     *   where: {
     *     // ... the filter for the Customers we want to count
     *   }
     * })
    **/
    count<T extends CustomerCountArgs>(
      args?: Subset<T, CustomerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CustomerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Customer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CustomerAggregateArgs>(args: Subset<T, CustomerAggregateArgs>): Prisma.PrismaPromise<GetCustomerAggregateType<T>>

    /**
     * Group by Customer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CustomerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CustomerGroupByArgs['orderBy'] }
        : { orderBy?: CustomerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CustomerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCustomerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Customer model
   */
  readonly fields: CustomerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Customer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CustomerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    visits<T extends Customer$visitsArgs<ExtArgs> = {}>(args?: Subset<T, Customer$visitsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VisitPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    discounts<T extends Customer$discountsArgs<ExtArgs> = {}>(args?: Subset<T, Customer$discountsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerDiscountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Customer model
   */
  interface CustomerFieldRefs {
    readonly id: FieldRef<"Customer", 'String'>
    readonly fullName: FieldRef<"Customer", 'String'>
    readonly gender: FieldRef<"Customer", 'Gender'>
    readonly location: FieldRef<"Customer", 'String'>
    readonly district: FieldRef<"Customer", 'String'>
    readonly province: FieldRef<"Customer", 'String'>
    readonly phone: FieldRef<"Customer", 'String'>
    readonly email: FieldRef<"Customer", 'String'>
    readonly birthDay: FieldRef<"Customer", 'Int'>
    readonly birthMonth: FieldRef<"Customer", 'Int'>
    readonly birthYear: FieldRef<"Customer", 'Int'>
    readonly visitCount: FieldRef<"Customer", 'Int'>
    readonly loyaltyPoints: FieldRef<"Customer", 'Int'>
    readonly totalSpent: FieldRef<"Customer", 'Decimal'>
    readonly lastVisit: FieldRef<"Customer", 'DateTime'>
    readonly isActive: FieldRef<"Customer", 'Boolean'>
    readonly createdAt: FieldRef<"Customer", 'DateTime'>
    readonly updatedAt: FieldRef<"Customer", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Customer findUnique
   */
  export type CustomerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where: CustomerWhereUniqueInput
  }

  /**
   * Customer findUniqueOrThrow
   */
  export type CustomerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where: CustomerWhereUniqueInput
  }

  /**
   * Customer findFirst
   */
  export type CustomerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Customers.
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Customers.
     */
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }

  /**
   * Customer findFirstOrThrow
   */
  export type CustomerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Customers.
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Customers.
     */
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }

  /**
   * Customer findMany
   */
  export type CustomerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customers to fetch.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Customers.
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }

  /**
   * Customer create
   */
  export type CustomerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * The data needed to create a Customer.
     */
    data: XOR<CustomerCreateInput, CustomerUncheckedCreateInput>
  }

  /**
   * Customer createMany
   */
  export type CustomerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Customers.
     */
    data: CustomerCreateManyInput | CustomerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Customer createManyAndReturn
   */
  export type CustomerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * The data used to create many Customers.
     */
    data: CustomerCreateManyInput | CustomerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Customer update
   */
  export type CustomerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * The data needed to update a Customer.
     */
    data: XOR<CustomerUpdateInput, CustomerUncheckedUpdateInput>
    /**
     * Choose, which Customer to update.
     */
    where: CustomerWhereUniqueInput
  }

  /**
   * Customer updateMany
   */
  export type CustomerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Customers.
     */
    data: XOR<CustomerUpdateManyMutationInput, CustomerUncheckedUpdateManyInput>
    /**
     * Filter which Customers to update
     */
    where?: CustomerWhereInput
    /**
     * Limit how many Customers to update.
     */
    limit?: number
  }

  /**
   * Customer updateManyAndReturn
   */
  export type CustomerUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * The data used to update Customers.
     */
    data: XOR<CustomerUpdateManyMutationInput, CustomerUncheckedUpdateManyInput>
    /**
     * Filter which Customers to update
     */
    where?: CustomerWhereInput
    /**
     * Limit how many Customers to update.
     */
    limit?: number
  }

  /**
   * Customer upsert
   */
  export type CustomerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * The filter to search for the Customer to update in case it exists.
     */
    where: CustomerWhereUniqueInput
    /**
     * In case the Customer found by the `where` argument doesn't exist, create a new Customer with this data.
     */
    create: XOR<CustomerCreateInput, CustomerUncheckedCreateInput>
    /**
     * In case the Customer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CustomerUpdateInput, CustomerUncheckedUpdateInput>
  }

  /**
   * Customer delete
   */
  export type CustomerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter which Customer to delete.
     */
    where: CustomerWhereUniqueInput
  }

  /**
   * Customer deleteMany
   */
  export type CustomerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Customers to delete
     */
    where?: CustomerWhereInput
    /**
     * Limit how many Customers to delete.
     */
    limit?: number
  }

  /**
   * Customer.visits
   */
  export type Customer$visitsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Visit
     */
    select?: VisitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Visit
     */
    omit?: VisitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitInclude<ExtArgs> | null
    where?: VisitWhereInput
    orderBy?: VisitOrderByWithRelationInput | VisitOrderByWithRelationInput[]
    cursor?: VisitWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VisitScalarFieldEnum | VisitScalarFieldEnum[]
  }

  /**
   * Customer.discounts
   */
  export type Customer$discountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerDiscount
     */
    select?: CustomerDiscountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerDiscount
     */
    omit?: CustomerDiscountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerDiscountInclude<ExtArgs> | null
    where?: CustomerDiscountWhereInput
    orderBy?: CustomerDiscountOrderByWithRelationInput | CustomerDiscountOrderByWithRelationInput[]
    cursor?: CustomerDiscountWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CustomerDiscountScalarFieldEnum | CustomerDiscountScalarFieldEnum[]
  }

  /**
   * Customer without action
   */
  export type CustomerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
  }


  /**
   * Model Service
   */

  export type AggregateService = {
    _count: ServiceCountAggregateOutputType | null
    _avg: ServiceAvgAggregateOutputType | null
    _sum: ServiceSumAggregateOutputType | null
    _min: ServiceMinAggregateOutputType | null
    _max: ServiceMaxAggregateOutputType | null
  }

  export type ServiceAvgAggregateOutputType = {
    singlePrice: Decimal | null
    combinedPrice: Decimal | null
    childPrice: Decimal | null
    childCombinedPrice: Decimal | null
    duration: number | null
  }

  export type ServiceSumAggregateOutputType = {
    singlePrice: Decimal | null
    combinedPrice: Decimal | null
    childPrice: Decimal | null
    childCombinedPrice: Decimal | null
    duration: number | null
  }

  export type ServiceMinAggregateOutputType = {
    id: string | null
    name: string | null
    category: $Enums.ServiceCategory | null
    description: string | null
    singlePrice: Decimal | null
    combinedPrice: Decimal | null
    childPrice: Decimal | null
    childCombinedPrice: Decimal | null
    duration: number | null
    isActive: boolean | null
    isComboEligible: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ServiceMaxAggregateOutputType = {
    id: string | null
    name: string | null
    category: $Enums.ServiceCategory | null
    description: string | null
    singlePrice: Decimal | null
    combinedPrice: Decimal | null
    childPrice: Decimal | null
    childCombinedPrice: Decimal | null
    duration: number | null
    isActive: boolean | null
    isComboEligible: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ServiceCountAggregateOutputType = {
    id: number
    name: number
    category: number
    description: number
    singlePrice: number
    combinedPrice: number
    childPrice: number
    childCombinedPrice: number
    duration: number
    isActive: number
    isComboEligible: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ServiceAvgAggregateInputType = {
    singlePrice?: true
    combinedPrice?: true
    childPrice?: true
    childCombinedPrice?: true
    duration?: true
  }

  export type ServiceSumAggregateInputType = {
    singlePrice?: true
    combinedPrice?: true
    childPrice?: true
    childCombinedPrice?: true
    duration?: true
  }

  export type ServiceMinAggregateInputType = {
    id?: true
    name?: true
    category?: true
    description?: true
    singlePrice?: true
    combinedPrice?: true
    childPrice?: true
    childCombinedPrice?: true
    duration?: true
    isActive?: true
    isComboEligible?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ServiceMaxAggregateInputType = {
    id?: true
    name?: true
    category?: true
    description?: true
    singlePrice?: true
    combinedPrice?: true
    childPrice?: true
    childCombinedPrice?: true
    duration?: true
    isActive?: true
    isComboEligible?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ServiceCountAggregateInputType = {
    id?: true
    name?: true
    category?: true
    description?: true
    singlePrice?: true
    combinedPrice?: true
    childPrice?: true
    childCombinedPrice?: true
    duration?: true
    isActive?: true
    isComboEligible?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ServiceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Service to aggregate.
     */
    where?: ServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Services to fetch.
     */
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Services.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Services
    **/
    _count?: true | ServiceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ServiceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ServiceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ServiceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ServiceMaxAggregateInputType
  }

  export type GetServiceAggregateType<T extends ServiceAggregateArgs> = {
        [P in keyof T & keyof AggregateService]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateService[P]>
      : GetScalarType<T[P], AggregateService[P]>
  }




  export type ServiceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceWhereInput
    orderBy?: ServiceOrderByWithAggregationInput | ServiceOrderByWithAggregationInput[]
    by: ServiceScalarFieldEnum[] | ServiceScalarFieldEnum
    having?: ServiceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ServiceCountAggregateInputType | true
    _avg?: ServiceAvgAggregateInputType
    _sum?: ServiceSumAggregateInputType
    _min?: ServiceMinAggregateInputType
    _max?: ServiceMaxAggregateInputType
  }

  export type ServiceGroupByOutputType = {
    id: string
    name: string
    category: $Enums.ServiceCategory
    description: string
    singlePrice: Decimal
    combinedPrice: Decimal | null
    childPrice: Decimal | null
    childCombinedPrice: Decimal | null
    duration: number
    isActive: boolean
    isComboEligible: boolean
    createdAt: Date
    updatedAt: Date
    _count: ServiceCountAggregateOutputType | null
    _avg: ServiceAvgAggregateOutputType | null
    _sum: ServiceSumAggregateOutputType | null
    _min: ServiceMinAggregateOutputType | null
    _max: ServiceMaxAggregateOutputType | null
  }

  type GetServiceGroupByPayload<T extends ServiceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ServiceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ServiceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ServiceGroupByOutputType[P]>
            : GetScalarType<T[P], ServiceGroupByOutputType[P]>
        }
      >
    >


  export type ServiceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    category?: boolean
    description?: boolean
    singlePrice?: boolean
    combinedPrice?: boolean
    childPrice?: boolean
    childCombinedPrice?: boolean
    duration?: boolean
    isActive?: boolean
    isComboEligible?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    visitServices?: boolean | Service$visitServicesArgs<ExtArgs>
    _count?: boolean | ServiceCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["service"]>

  export type ServiceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    category?: boolean
    description?: boolean
    singlePrice?: boolean
    combinedPrice?: boolean
    childPrice?: boolean
    childCombinedPrice?: boolean
    duration?: boolean
    isActive?: boolean
    isComboEligible?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["service"]>

  export type ServiceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    category?: boolean
    description?: boolean
    singlePrice?: boolean
    combinedPrice?: boolean
    childPrice?: boolean
    childCombinedPrice?: boolean
    duration?: boolean
    isActive?: boolean
    isComboEligible?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["service"]>

  export type ServiceSelectScalar = {
    id?: boolean
    name?: boolean
    category?: boolean
    description?: boolean
    singlePrice?: boolean
    combinedPrice?: boolean
    childPrice?: boolean
    childCombinedPrice?: boolean
    duration?: boolean
    isActive?: boolean
    isComboEligible?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ServiceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "category" | "description" | "singlePrice" | "combinedPrice" | "childPrice" | "childCombinedPrice" | "duration" | "isActive" | "isComboEligible" | "createdAt" | "updatedAt", ExtArgs["result"]["service"]>
  export type ServiceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    visitServices?: boolean | Service$visitServicesArgs<ExtArgs>
    _count?: boolean | ServiceCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ServiceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type ServiceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ServicePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Service"
    objects: {
      visitServices: Prisma.$VisitServicePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      category: $Enums.ServiceCategory
      description: string
      singlePrice: Prisma.Decimal
      combinedPrice: Prisma.Decimal | null
      childPrice: Prisma.Decimal | null
      childCombinedPrice: Prisma.Decimal | null
      duration: number
      isActive: boolean
      isComboEligible: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["service"]>
    composites: {}
  }

  type ServiceGetPayload<S extends boolean | null | undefined | ServiceDefaultArgs> = $Result.GetResult<Prisma.$ServicePayload, S>

  type ServiceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ServiceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ServiceCountAggregateInputType | true
    }

  export interface ServiceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Service'], meta: { name: 'Service' } }
    /**
     * Find zero or one Service that matches the filter.
     * @param {ServiceFindUniqueArgs} args - Arguments to find a Service
     * @example
     * // Get one Service
     * const service = await prisma.service.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ServiceFindUniqueArgs>(args: SelectSubset<T, ServiceFindUniqueArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Service that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ServiceFindUniqueOrThrowArgs} args - Arguments to find a Service
     * @example
     * // Get one Service
     * const service = await prisma.service.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ServiceFindUniqueOrThrowArgs>(args: SelectSubset<T, ServiceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Service that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceFindFirstArgs} args - Arguments to find a Service
     * @example
     * // Get one Service
     * const service = await prisma.service.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ServiceFindFirstArgs>(args?: SelectSubset<T, ServiceFindFirstArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Service that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceFindFirstOrThrowArgs} args - Arguments to find a Service
     * @example
     * // Get one Service
     * const service = await prisma.service.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ServiceFindFirstOrThrowArgs>(args?: SelectSubset<T, ServiceFindFirstOrThrowArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Services that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Services
     * const services = await prisma.service.findMany()
     * 
     * // Get first 10 Services
     * const services = await prisma.service.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const serviceWithIdOnly = await prisma.service.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ServiceFindManyArgs>(args?: SelectSubset<T, ServiceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Service.
     * @param {ServiceCreateArgs} args - Arguments to create a Service.
     * @example
     * // Create one Service
     * const Service = await prisma.service.create({
     *   data: {
     *     // ... data to create a Service
     *   }
     * })
     * 
     */
    create<T extends ServiceCreateArgs>(args: SelectSubset<T, ServiceCreateArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Services.
     * @param {ServiceCreateManyArgs} args - Arguments to create many Services.
     * @example
     * // Create many Services
     * const service = await prisma.service.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ServiceCreateManyArgs>(args?: SelectSubset<T, ServiceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Services and returns the data saved in the database.
     * @param {ServiceCreateManyAndReturnArgs} args - Arguments to create many Services.
     * @example
     * // Create many Services
     * const service = await prisma.service.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Services and only return the `id`
     * const serviceWithIdOnly = await prisma.service.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ServiceCreateManyAndReturnArgs>(args?: SelectSubset<T, ServiceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Service.
     * @param {ServiceDeleteArgs} args - Arguments to delete one Service.
     * @example
     * // Delete one Service
     * const Service = await prisma.service.delete({
     *   where: {
     *     // ... filter to delete one Service
     *   }
     * })
     * 
     */
    delete<T extends ServiceDeleteArgs>(args: SelectSubset<T, ServiceDeleteArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Service.
     * @param {ServiceUpdateArgs} args - Arguments to update one Service.
     * @example
     * // Update one Service
     * const service = await prisma.service.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ServiceUpdateArgs>(args: SelectSubset<T, ServiceUpdateArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Services.
     * @param {ServiceDeleteManyArgs} args - Arguments to filter Services to delete.
     * @example
     * // Delete a few Services
     * const { count } = await prisma.service.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ServiceDeleteManyArgs>(args?: SelectSubset<T, ServiceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Services.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Services
     * const service = await prisma.service.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ServiceUpdateManyArgs>(args: SelectSubset<T, ServiceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Services and returns the data updated in the database.
     * @param {ServiceUpdateManyAndReturnArgs} args - Arguments to update many Services.
     * @example
     * // Update many Services
     * const service = await prisma.service.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Services and only return the `id`
     * const serviceWithIdOnly = await prisma.service.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ServiceUpdateManyAndReturnArgs>(args: SelectSubset<T, ServiceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Service.
     * @param {ServiceUpsertArgs} args - Arguments to update or create a Service.
     * @example
     * // Update or create a Service
     * const service = await prisma.service.upsert({
     *   create: {
     *     // ... data to create a Service
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Service we want to update
     *   }
     * })
     */
    upsert<T extends ServiceUpsertArgs>(args: SelectSubset<T, ServiceUpsertArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Services.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceCountArgs} args - Arguments to filter Services to count.
     * @example
     * // Count the number of Services
     * const count = await prisma.service.count({
     *   where: {
     *     // ... the filter for the Services we want to count
     *   }
     * })
    **/
    count<T extends ServiceCountArgs>(
      args?: Subset<T, ServiceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ServiceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Service.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ServiceAggregateArgs>(args: Subset<T, ServiceAggregateArgs>): Prisma.PrismaPromise<GetServiceAggregateType<T>>

    /**
     * Group by Service.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ServiceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ServiceGroupByArgs['orderBy'] }
        : { orderBy?: ServiceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ServiceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetServiceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Service model
   */
  readonly fields: ServiceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Service.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ServiceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    visitServices<T extends Service$visitServicesArgs<ExtArgs> = {}>(args?: Subset<T, Service$visitServicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VisitServicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Service model
   */
  interface ServiceFieldRefs {
    readonly id: FieldRef<"Service", 'String'>
    readonly name: FieldRef<"Service", 'String'>
    readonly category: FieldRef<"Service", 'ServiceCategory'>
    readonly description: FieldRef<"Service", 'String'>
    readonly singlePrice: FieldRef<"Service", 'Decimal'>
    readonly combinedPrice: FieldRef<"Service", 'Decimal'>
    readonly childPrice: FieldRef<"Service", 'Decimal'>
    readonly childCombinedPrice: FieldRef<"Service", 'Decimal'>
    readonly duration: FieldRef<"Service", 'Int'>
    readonly isActive: FieldRef<"Service", 'Boolean'>
    readonly isComboEligible: FieldRef<"Service", 'Boolean'>
    readonly createdAt: FieldRef<"Service", 'DateTime'>
    readonly updatedAt: FieldRef<"Service", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Service findUnique
   */
  export type ServiceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Service to fetch.
     */
    where: ServiceWhereUniqueInput
  }

  /**
   * Service findUniqueOrThrow
   */
  export type ServiceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Service to fetch.
     */
    where: ServiceWhereUniqueInput
  }

  /**
   * Service findFirst
   */
  export type ServiceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Service to fetch.
     */
    where?: ServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Services to fetch.
     */
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Services.
     */
    cursor?: ServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Services.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Services.
     */
    distinct?: ServiceScalarFieldEnum | ServiceScalarFieldEnum[]
  }

  /**
   * Service findFirstOrThrow
   */
  export type ServiceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Service to fetch.
     */
    where?: ServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Services to fetch.
     */
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Services.
     */
    cursor?: ServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Services.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Services.
     */
    distinct?: ServiceScalarFieldEnum | ServiceScalarFieldEnum[]
  }

  /**
   * Service findMany
   */
  export type ServiceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Services to fetch.
     */
    where?: ServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Services to fetch.
     */
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Services.
     */
    cursor?: ServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Services.
     */
    skip?: number
    distinct?: ServiceScalarFieldEnum | ServiceScalarFieldEnum[]
  }

  /**
   * Service create
   */
  export type ServiceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * The data needed to create a Service.
     */
    data: XOR<ServiceCreateInput, ServiceUncheckedCreateInput>
  }

  /**
   * Service createMany
   */
  export type ServiceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Services.
     */
    data: ServiceCreateManyInput | ServiceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Service createManyAndReturn
   */
  export type ServiceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * The data used to create many Services.
     */
    data: ServiceCreateManyInput | ServiceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Service update
   */
  export type ServiceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * The data needed to update a Service.
     */
    data: XOR<ServiceUpdateInput, ServiceUncheckedUpdateInput>
    /**
     * Choose, which Service to update.
     */
    where: ServiceWhereUniqueInput
  }

  /**
   * Service updateMany
   */
  export type ServiceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Services.
     */
    data: XOR<ServiceUpdateManyMutationInput, ServiceUncheckedUpdateManyInput>
    /**
     * Filter which Services to update
     */
    where?: ServiceWhereInput
    /**
     * Limit how many Services to update.
     */
    limit?: number
  }

  /**
   * Service updateManyAndReturn
   */
  export type ServiceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * The data used to update Services.
     */
    data: XOR<ServiceUpdateManyMutationInput, ServiceUncheckedUpdateManyInput>
    /**
     * Filter which Services to update
     */
    where?: ServiceWhereInput
    /**
     * Limit how many Services to update.
     */
    limit?: number
  }

  /**
   * Service upsert
   */
  export type ServiceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * The filter to search for the Service to update in case it exists.
     */
    where: ServiceWhereUniqueInput
    /**
     * In case the Service found by the `where` argument doesn't exist, create a new Service with this data.
     */
    create: XOR<ServiceCreateInput, ServiceUncheckedCreateInput>
    /**
     * In case the Service was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ServiceUpdateInput, ServiceUncheckedUpdateInput>
  }

  /**
   * Service delete
   */
  export type ServiceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter which Service to delete.
     */
    where: ServiceWhereUniqueInput
  }

  /**
   * Service deleteMany
   */
  export type ServiceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Services to delete
     */
    where?: ServiceWhereInput
    /**
     * Limit how many Services to delete.
     */
    limit?: number
  }

  /**
   * Service.visitServices
   */
  export type Service$visitServicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisitService
     */
    select?: VisitServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VisitService
     */
    omit?: VisitServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitServiceInclude<ExtArgs> | null
    where?: VisitServiceWhereInput
    orderBy?: VisitServiceOrderByWithRelationInput | VisitServiceOrderByWithRelationInput[]
    cursor?: VisitServiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VisitServiceScalarFieldEnum | VisitServiceScalarFieldEnum[]
  }

  /**
   * Service without action
   */
  export type ServiceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
  }


  /**
   * Model Visit
   */

  export type AggregateVisit = {
    _count: VisitCountAggregateOutputType | null
    _avg: VisitAvgAggregateOutputType | null
    _sum: VisitSumAggregateOutputType | null
    _min: VisitMinAggregateOutputType | null
    _max: VisitMaxAggregateOutputType | null
  }

  export type VisitAvgAggregateOutputType = {
    totalAmount: Decimal | null
    discountAmount: Decimal | null
    finalAmount: Decimal | null
    loyaltyPointsEarned: number | null
  }

  export type VisitSumAggregateOutputType = {
    totalAmount: Decimal | null
    discountAmount: Decimal | null
    finalAmount: Decimal | null
    loyaltyPointsEarned: number | null
  }

  export type VisitMinAggregateOutputType = {
    id: string | null
    customerId: string | null
    visitDate: Date | null
    totalAmount: Decimal | null
    discountAmount: Decimal | null
    finalAmount: Decimal | null
    loyaltyPointsEarned: number | null
    notes: string | null
    isCompleted: boolean | null
    createdById: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VisitMaxAggregateOutputType = {
    id: string | null
    customerId: string | null
    visitDate: Date | null
    totalAmount: Decimal | null
    discountAmount: Decimal | null
    finalAmount: Decimal | null
    loyaltyPointsEarned: number | null
    notes: string | null
    isCompleted: boolean | null
    createdById: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VisitCountAggregateOutputType = {
    id: number
    customerId: number
    visitDate: number
    totalAmount: number
    discountAmount: number
    finalAmount: number
    loyaltyPointsEarned: number
    notes: number
    isCompleted: number
    createdById: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type VisitAvgAggregateInputType = {
    totalAmount?: true
    discountAmount?: true
    finalAmount?: true
    loyaltyPointsEarned?: true
  }

  export type VisitSumAggregateInputType = {
    totalAmount?: true
    discountAmount?: true
    finalAmount?: true
    loyaltyPointsEarned?: true
  }

  export type VisitMinAggregateInputType = {
    id?: true
    customerId?: true
    visitDate?: true
    totalAmount?: true
    discountAmount?: true
    finalAmount?: true
    loyaltyPointsEarned?: true
    notes?: true
    isCompleted?: true
    createdById?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VisitMaxAggregateInputType = {
    id?: true
    customerId?: true
    visitDate?: true
    totalAmount?: true
    discountAmount?: true
    finalAmount?: true
    loyaltyPointsEarned?: true
    notes?: true
    isCompleted?: true
    createdById?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VisitCountAggregateInputType = {
    id?: true
    customerId?: true
    visitDate?: true
    totalAmount?: true
    discountAmount?: true
    finalAmount?: true
    loyaltyPointsEarned?: true
    notes?: true
    isCompleted?: true
    createdById?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type VisitAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Visit to aggregate.
     */
    where?: VisitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Visits to fetch.
     */
    orderBy?: VisitOrderByWithRelationInput | VisitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VisitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Visits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Visits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Visits
    **/
    _count?: true | VisitCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VisitAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VisitSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VisitMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VisitMaxAggregateInputType
  }

  export type GetVisitAggregateType<T extends VisitAggregateArgs> = {
        [P in keyof T & keyof AggregateVisit]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVisit[P]>
      : GetScalarType<T[P], AggregateVisit[P]>
  }




  export type VisitGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VisitWhereInput
    orderBy?: VisitOrderByWithAggregationInput | VisitOrderByWithAggregationInput[]
    by: VisitScalarFieldEnum[] | VisitScalarFieldEnum
    having?: VisitScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VisitCountAggregateInputType | true
    _avg?: VisitAvgAggregateInputType
    _sum?: VisitSumAggregateInputType
    _min?: VisitMinAggregateInputType
    _max?: VisitMaxAggregateInputType
  }

  export type VisitGroupByOutputType = {
    id: string
    customerId: string
    visitDate: Date
    totalAmount: Decimal
    discountAmount: Decimal
    finalAmount: Decimal
    loyaltyPointsEarned: number
    notes: string | null
    isCompleted: boolean
    createdById: string
    createdAt: Date
    updatedAt: Date
    _count: VisitCountAggregateOutputType | null
    _avg: VisitAvgAggregateOutputType | null
    _sum: VisitSumAggregateOutputType | null
    _min: VisitMinAggregateOutputType | null
    _max: VisitMaxAggregateOutputType | null
  }

  type GetVisitGroupByPayload<T extends VisitGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VisitGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VisitGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VisitGroupByOutputType[P]>
            : GetScalarType<T[P], VisitGroupByOutputType[P]>
        }
      >
    >


  export type VisitSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    customerId?: boolean
    visitDate?: boolean
    totalAmount?: boolean
    discountAmount?: boolean
    finalAmount?: boolean
    loyaltyPointsEarned?: boolean
    notes?: boolean
    isCompleted?: boolean
    createdById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    services?: boolean | Visit$servicesArgs<ExtArgs>
    staff?: boolean | Visit$staffArgs<ExtArgs>
    discounts?: boolean | Visit$discountsArgs<ExtArgs>
    _count?: boolean | VisitCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["visit"]>

  export type VisitSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    customerId?: boolean
    visitDate?: boolean
    totalAmount?: boolean
    discountAmount?: boolean
    finalAmount?: boolean
    loyaltyPointsEarned?: boolean
    notes?: boolean
    isCompleted?: boolean
    createdById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["visit"]>

  export type VisitSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    customerId?: boolean
    visitDate?: boolean
    totalAmount?: boolean
    discountAmount?: boolean
    finalAmount?: boolean
    loyaltyPointsEarned?: boolean
    notes?: boolean
    isCompleted?: boolean
    createdById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["visit"]>

  export type VisitSelectScalar = {
    id?: boolean
    customerId?: boolean
    visitDate?: boolean
    totalAmount?: boolean
    discountAmount?: boolean
    finalAmount?: boolean
    loyaltyPointsEarned?: boolean
    notes?: boolean
    isCompleted?: boolean
    createdById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type VisitOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "customerId" | "visitDate" | "totalAmount" | "discountAmount" | "finalAmount" | "loyaltyPointsEarned" | "notes" | "isCompleted" | "createdById" | "createdAt" | "updatedAt", ExtArgs["result"]["visit"]>
  export type VisitInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    services?: boolean | Visit$servicesArgs<ExtArgs>
    staff?: boolean | Visit$staffArgs<ExtArgs>
    discounts?: boolean | Visit$discountsArgs<ExtArgs>
    _count?: boolean | VisitCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type VisitIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type VisitIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $VisitPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Visit"
    objects: {
      customer: Prisma.$CustomerPayload<ExtArgs>
      createdBy: Prisma.$UserPayload<ExtArgs>
      services: Prisma.$VisitServicePayload<ExtArgs>[]
      staff: Prisma.$VisitStaffPayload<ExtArgs>[]
      discounts: Prisma.$VisitDiscountPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      customerId: string
      visitDate: Date
      totalAmount: Prisma.Decimal
      discountAmount: Prisma.Decimal
      finalAmount: Prisma.Decimal
      loyaltyPointsEarned: number
      notes: string | null
      isCompleted: boolean
      createdById: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["visit"]>
    composites: {}
  }

  type VisitGetPayload<S extends boolean | null | undefined | VisitDefaultArgs> = $Result.GetResult<Prisma.$VisitPayload, S>

  type VisitCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VisitFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VisitCountAggregateInputType | true
    }

  export interface VisitDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Visit'], meta: { name: 'Visit' } }
    /**
     * Find zero or one Visit that matches the filter.
     * @param {VisitFindUniqueArgs} args - Arguments to find a Visit
     * @example
     * // Get one Visit
     * const visit = await prisma.visit.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VisitFindUniqueArgs>(args: SelectSubset<T, VisitFindUniqueArgs<ExtArgs>>): Prisma__VisitClient<$Result.GetResult<Prisma.$VisitPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Visit that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VisitFindUniqueOrThrowArgs} args - Arguments to find a Visit
     * @example
     * // Get one Visit
     * const visit = await prisma.visit.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VisitFindUniqueOrThrowArgs>(args: SelectSubset<T, VisitFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VisitClient<$Result.GetResult<Prisma.$VisitPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Visit that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VisitFindFirstArgs} args - Arguments to find a Visit
     * @example
     * // Get one Visit
     * const visit = await prisma.visit.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VisitFindFirstArgs>(args?: SelectSubset<T, VisitFindFirstArgs<ExtArgs>>): Prisma__VisitClient<$Result.GetResult<Prisma.$VisitPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Visit that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VisitFindFirstOrThrowArgs} args - Arguments to find a Visit
     * @example
     * // Get one Visit
     * const visit = await prisma.visit.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VisitFindFirstOrThrowArgs>(args?: SelectSubset<T, VisitFindFirstOrThrowArgs<ExtArgs>>): Prisma__VisitClient<$Result.GetResult<Prisma.$VisitPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Visits that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VisitFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Visits
     * const visits = await prisma.visit.findMany()
     * 
     * // Get first 10 Visits
     * const visits = await prisma.visit.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const visitWithIdOnly = await prisma.visit.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VisitFindManyArgs>(args?: SelectSubset<T, VisitFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VisitPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Visit.
     * @param {VisitCreateArgs} args - Arguments to create a Visit.
     * @example
     * // Create one Visit
     * const Visit = await prisma.visit.create({
     *   data: {
     *     // ... data to create a Visit
     *   }
     * })
     * 
     */
    create<T extends VisitCreateArgs>(args: SelectSubset<T, VisitCreateArgs<ExtArgs>>): Prisma__VisitClient<$Result.GetResult<Prisma.$VisitPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Visits.
     * @param {VisitCreateManyArgs} args - Arguments to create many Visits.
     * @example
     * // Create many Visits
     * const visit = await prisma.visit.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VisitCreateManyArgs>(args?: SelectSubset<T, VisitCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Visits and returns the data saved in the database.
     * @param {VisitCreateManyAndReturnArgs} args - Arguments to create many Visits.
     * @example
     * // Create many Visits
     * const visit = await prisma.visit.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Visits and only return the `id`
     * const visitWithIdOnly = await prisma.visit.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VisitCreateManyAndReturnArgs>(args?: SelectSubset<T, VisitCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VisitPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Visit.
     * @param {VisitDeleteArgs} args - Arguments to delete one Visit.
     * @example
     * // Delete one Visit
     * const Visit = await prisma.visit.delete({
     *   where: {
     *     // ... filter to delete one Visit
     *   }
     * })
     * 
     */
    delete<T extends VisitDeleteArgs>(args: SelectSubset<T, VisitDeleteArgs<ExtArgs>>): Prisma__VisitClient<$Result.GetResult<Prisma.$VisitPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Visit.
     * @param {VisitUpdateArgs} args - Arguments to update one Visit.
     * @example
     * // Update one Visit
     * const visit = await prisma.visit.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VisitUpdateArgs>(args: SelectSubset<T, VisitUpdateArgs<ExtArgs>>): Prisma__VisitClient<$Result.GetResult<Prisma.$VisitPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Visits.
     * @param {VisitDeleteManyArgs} args - Arguments to filter Visits to delete.
     * @example
     * // Delete a few Visits
     * const { count } = await prisma.visit.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VisitDeleteManyArgs>(args?: SelectSubset<T, VisitDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Visits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VisitUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Visits
     * const visit = await prisma.visit.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VisitUpdateManyArgs>(args: SelectSubset<T, VisitUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Visits and returns the data updated in the database.
     * @param {VisitUpdateManyAndReturnArgs} args - Arguments to update many Visits.
     * @example
     * // Update many Visits
     * const visit = await prisma.visit.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Visits and only return the `id`
     * const visitWithIdOnly = await prisma.visit.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VisitUpdateManyAndReturnArgs>(args: SelectSubset<T, VisitUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VisitPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Visit.
     * @param {VisitUpsertArgs} args - Arguments to update or create a Visit.
     * @example
     * // Update or create a Visit
     * const visit = await prisma.visit.upsert({
     *   create: {
     *     // ... data to create a Visit
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Visit we want to update
     *   }
     * })
     */
    upsert<T extends VisitUpsertArgs>(args: SelectSubset<T, VisitUpsertArgs<ExtArgs>>): Prisma__VisitClient<$Result.GetResult<Prisma.$VisitPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Visits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VisitCountArgs} args - Arguments to filter Visits to count.
     * @example
     * // Count the number of Visits
     * const count = await prisma.visit.count({
     *   where: {
     *     // ... the filter for the Visits we want to count
     *   }
     * })
    **/
    count<T extends VisitCountArgs>(
      args?: Subset<T, VisitCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VisitCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Visit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VisitAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VisitAggregateArgs>(args: Subset<T, VisitAggregateArgs>): Prisma.PrismaPromise<GetVisitAggregateType<T>>

    /**
     * Group by Visit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VisitGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VisitGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VisitGroupByArgs['orderBy'] }
        : { orderBy?: VisitGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VisitGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVisitGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Visit model
   */
  readonly fields: VisitFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Visit.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VisitClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    customer<T extends CustomerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CustomerDefaultArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    createdBy<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    services<T extends Visit$servicesArgs<ExtArgs> = {}>(args?: Subset<T, Visit$servicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VisitServicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    staff<T extends Visit$staffArgs<ExtArgs> = {}>(args?: Subset<T, Visit$staffArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VisitStaffPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    discounts<T extends Visit$discountsArgs<ExtArgs> = {}>(args?: Subset<T, Visit$discountsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VisitDiscountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Visit model
   */
  interface VisitFieldRefs {
    readonly id: FieldRef<"Visit", 'String'>
    readonly customerId: FieldRef<"Visit", 'String'>
    readonly visitDate: FieldRef<"Visit", 'DateTime'>
    readonly totalAmount: FieldRef<"Visit", 'Decimal'>
    readonly discountAmount: FieldRef<"Visit", 'Decimal'>
    readonly finalAmount: FieldRef<"Visit", 'Decimal'>
    readonly loyaltyPointsEarned: FieldRef<"Visit", 'Int'>
    readonly notes: FieldRef<"Visit", 'String'>
    readonly isCompleted: FieldRef<"Visit", 'Boolean'>
    readonly createdById: FieldRef<"Visit", 'String'>
    readonly createdAt: FieldRef<"Visit", 'DateTime'>
    readonly updatedAt: FieldRef<"Visit", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Visit findUnique
   */
  export type VisitFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Visit
     */
    select?: VisitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Visit
     */
    omit?: VisitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitInclude<ExtArgs> | null
    /**
     * Filter, which Visit to fetch.
     */
    where: VisitWhereUniqueInput
  }

  /**
   * Visit findUniqueOrThrow
   */
  export type VisitFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Visit
     */
    select?: VisitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Visit
     */
    omit?: VisitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitInclude<ExtArgs> | null
    /**
     * Filter, which Visit to fetch.
     */
    where: VisitWhereUniqueInput
  }

  /**
   * Visit findFirst
   */
  export type VisitFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Visit
     */
    select?: VisitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Visit
     */
    omit?: VisitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitInclude<ExtArgs> | null
    /**
     * Filter, which Visit to fetch.
     */
    where?: VisitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Visits to fetch.
     */
    orderBy?: VisitOrderByWithRelationInput | VisitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Visits.
     */
    cursor?: VisitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Visits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Visits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Visits.
     */
    distinct?: VisitScalarFieldEnum | VisitScalarFieldEnum[]
  }

  /**
   * Visit findFirstOrThrow
   */
  export type VisitFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Visit
     */
    select?: VisitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Visit
     */
    omit?: VisitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitInclude<ExtArgs> | null
    /**
     * Filter, which Visit to fetch.
     */
    where?: VisitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Visits to fetch.
     */
    orderBy?: VisitOrderByWithRelationInput | VisitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Visits.
     */
    cursor?: VisitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Visits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Visits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Visits.
     */
    distinct?: VisitScalarFieldEnum | VisitScalarFieldEnum[]
  }

  /**
   * Visit findMany
   */
  export type VisitFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Visit
     */
    select?: VisitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Visit
     */
    omit?: VisitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitInclude<ExtArgs> | null
    /**
     * Filter, which Visits to fetch.
     */
    where?: VisitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Visits to fetch.
     */
    orderBy?: VisitOrderByWithRelationInput | VisitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Visits.
     */
    cursor?: VisitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Visits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Visits.
     */
    skip?: number
    distinct?: VisitScalarFieldEnum | VisitScalarFieldEnum[]
  }

  /**
   * Visit create
   */
  export type VisitCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Visit
     */
    select?: VisitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Visit
     */
    omit?: VisitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitInclude<ExtArgs> | null
    /**
     * The data needed to create a Visit.
     */
    data: XOR<VisitCreateInput, VisitUncheckedCreateInput>
  }

  /**
   * Visit createMany
   */
  export type VisitCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Visits.
     */
    data: VisitCreateManyInput | VisitCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Visit createManyAndReturn
   */
  export type VisitCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Visit
     */
    select?: VisitSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Visit
     */
    omit?: VisitOmit<ExtArgs> | null
    /**
     * The data used to create many Visits.
     */
    data: VisitCreateManyInput | VisitCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Visit update
   */
  export type VisitUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Visit
     */
    select?: VisitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Visit
     */
    omit?: VisitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitInclude<ExtArgs> | null
    /**
     * The data needed to update a Visit.
     */
    data: XOR<VisitUpdateInput, VisitUncheckedUpdateInput>
    /**
     * Choose, which Visit to update.
     */
    where: VisitWhereUniqueInput
  }

  /**
   * Visit updateMany
   */
  export type VisitUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Visits.
     */
    data: XOR<VisitUpdateManyMutationInput, VisitUncheckedUpdateManyInput>
    /**
     * Filter which Visits to update
     */
    where?: VisitWhereInput
    /**
     * Limit how many Visits to update.
     */
    limit?: number
  }

  /**
   * Visit updateManyAndReturn
   */
  export type VisitUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Visit
     */
    select?: VisitSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Visit
     */
    omit?: VisitOmit<ExtArgs> | null
    /**
     * The data used to update Visits.
     */
    data: XOR<VisitUpdateManyMutationInput, VisitUncheckedUpdateManyInput>
    /**
     * Filter which Visits to update
     */
    where?: VisitWhereInput
    /**
     * Limit how many Visits to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Visit upsert
   */
  export type VisitUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Visit
     */
    select?: VisitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Visit
     */
    omit?: VisitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitInclude<ExtArgs> | null
    /**
     * The filter to search for the Visit to update in case it exists.
     */
    where: VisitWhereUniqueInput
    /**
     * In case the Visit found by the `where` argument doesn't exist, create a new Visit with this data.
     */
    create: XOR<VisitCreateInput, VisitUncheckedCreateInput>
    /**
     * In case the Visit was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VisitUpdateInput, VisitUncheckedUpdateInput>
  }

  /**
   * Visit delete
   */
  export type VisitDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Visit
     */
    select?: VisitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Visit
     */
    omit?: VisitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitInclude<ExtArgs> | null
    /**
     * Filter which Visit to delete.
     */
    where: VisitWhereUniqueInput
  }

  /**
   * Visit deleteMany
   */
  export type VisitDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Visits to delete
     */
    where?: VisitWhereInput
    /**
     * Limit how many Visits to delete.
     */
    limit?: number
  }

  /**
   * Visit.services
   */
  export type Visit$servicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisitService
     */
    select?: VisitServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VisitService
     */
    omit?: VisitServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitServiceInclude<ExtArgs> | null
    where?: VisitServiceWhereInput
    orderBy?: VisitServiceOrderByWithRelationInput | VisitServiceOrderByWithRelationInput[]
    cursor?: VisitServiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VisitServiceScalarFieldEnum | VisitServiceScalarFieldEnum[]
  }

  /**
   * Visit.staff
   */
  export type Visit$staffArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisitStaff
     */
    select?: VisitStaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VisitStaff
     */
    omit?: VisitStaffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitStaffInclude<ExtArgs> | null
    where?: VisitStaffWhereInput
    orderBy?: VisitStaffOrderByWithRelationInput | VisitStaffOrderByWithRelationInput[]
    cursor?: VisitStaffWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VisitStaffScalarFieldEnum | VisitStaffScalarFieldEnum[]
  }

  /**
   * Visit.discounts
   */
  export type Visit$discountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisitDiscount
     */
    select?: VisitDiscountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VisitDiscount
     */
    omit?: VisitDiscountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitDiscountInclude<ExtArgs> | null
    where?: VisitDiscountWhereInput
    orderBy?: VisitDiscountOrderByWithRelationInput | VisitDiscountOrderByWithRelationInput[]
    cursor?: VisitDiscountWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VisitDiscountScalarFieldEnum | VisitDiscountScalarFieldEnum[]
  }

  /**
   * Visit without action
   */
  export type VisitDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Visit
     */
    select?: VisitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Visit
     */
    omit?: VisitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitInclude<ExtArgs> | null
  }


  /**
   * Model VisitService
   */

  export type AggregateVisitService = {
    _count: VisitServiceCountAggregateOutputType | null
    _avg: VisitServiceAvgAggregateOutputType | null
    _sum: VisitServiceSumAggregateOutputType | null
    _min: VisitServiceMinAggregateOutputType | null
    _max: VisitServiceMaxAggregateOutputType | null
  }

  export type VisitServiceAvgAggregateOutputType = {
    quantity: number | null
    unitPrice: Decimal | null
    totalPrice: Decimal | null
  }

  export type VisitServiceSumAggregateOutputType = {
    quantity: number | null
    unitPrice: Decimal | null
    totalPrice: Decimal | null
  }

  export type VisitServiceMinAggregateOutputType = {
    id: string | null
    visitId: string | null
    serviceId: string | null
    quantity: number | null
    unitPrice: Decimal | null
    totalPrice: Decimal | null
    isChild: boolean | null
    isCombined: boolean | null
    createdAt: Date | null
  }

  export type VisitServiceMaxAggregateOutputType = {
    id: string | null
    visitId: string | null
    serviceId: string | null
    quantity: number | null
    unitPrice: Decimal | null
    totalPrice: Decimal | null
    isChild: boolean | null
    isCombined: boolean | null
    createdAt: Date | null
  }

  export type VisitServiceCountAggregateOutputType = {
    id: number
    visitId: number
    serviceId: number
    quantity: number
    unitPrice: number
    totalPrice: number
    isChild: number
    isCombined: number
    createdAt: number
    _all: number
  }


  export type VisitServiceAvgAggregateInputType = {
    quantity?: true
    unitPrice?: true
    totalPrice?: true
  }

  export type VisitServiceSumAggregateInputType = {
    quantity?: true
    unitPrice?: true
    totalPrice?: true
  }

  export type VisitServiceMinAggregateInputType = {
    id?: true
    visitId?: true
    serviceId?: true
    quantity?: true
    unitPrice?: true
    totalPrice?: true
    isChild?: true
    isCombined?: true
    createdAt?: true
  }

  export type VisitServiceMaxAggregateInputType = {
    id?: true
    visitId?: true
    serviceId?: true
    quantity?: true
    unitPrice?: true
    totalPrice?: true
    isChild?: true
    isCombined?: true
    createdAt?: true
  }

  export type VisitServiceCountAggregateInputType = {
    id?: true
    visitId?: true
    serviceId?: true
    quantity?: true
    unitPrice?: true
    totalPrice?: true
    isChild?: true
    isCombined?: true
    createdAt?: true
    _all?: true
  }

  export type VisitServiceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VisitService to aggregate.
     */
    where?: VisitServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VisitServices to fetch.
     */
    orderBy?: VisitServiceOrderByWithRelationInput | VisitServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VisitServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VisitServices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VisitServices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VisitServices
    **/
    _count?: true | VisitServiceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VisitServiceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VisitServiceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VisitServiceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VisitServiceMaxAggregateInputType
  }

  export type GetVisitServiceAggregateType<T extends VisitServiceAggregateArgs> = {
        [P in keyof T & keyof AggregateVisitService]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVisitService[P]>
      : GetScalarType<T[P], AggregateVisitService[P]>
  }




  export type VisitServiceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VisitServiceWhereInput
    orderBy?: VisitServiceOrderByWithAggregationInput | VisitServiceOrderByWithAggregationInput[]
    by: VisitServiceScalarFieldEnum[] | VisitServiceScalarFieldEnum
    having?: VisitServiceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VisitServiceCountAggregateInputType | true
    _avg?: VisitServiceAvgAggregateInputType
    _sum?: VisitServiceSumAggregateInputType
    _min?: VisitServiceMinAggregateInputType
    _max?: VisitServiceMaxAggregateInputType
  }

  export type VisitServiceGroupByOutputType = {
    id: string
    visitId: string
    serviceId: string
    quantity: number
    unitPrice: Decimal
    totalPrice: Decimal
    isChild: boolean
    isCombined: boolean
    createdAt: Date
    _count: VisitServiceCountAggregateOutputType | null
    _avg: VisitServiceAvgAggregateOutputType | null
    _sum: VisitServiceSumAggregateOutputType | null
    _min: VisitServiceMinAggregateOutputType | null
    _max: VisitServiceMaxAggregateOutputType | null
  }

  type GetVisitServiceGroupByPayload<T extends VisitServiceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VisitServiceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VisitServiceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VisitServiceGroupByOutputType[P]>
            : GetScalarType<T[P], VisitServiceGroupByOutputType[P]>
        }
      >
    >


  export type VisitServiceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    visitId?: boolean
    serviceId?: boolean
    quantity?: boolean
    unitPrice?: boolean
    totalPrice?: boolean
    isChild?: boolean
    isCombined?: boolean
    createdAt?: boolean
    visit?: boolean | VisitDefaultArgs<ExtArgs>
    service?: boolean | ServiceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["visitService"]>

  export type VisitServiceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    visitId?: boolean
    serviceId?: boolean
    quantity?: boolean
    unitPrice?: boolean
    totalPrice?: boolean
    isChild?: boolean
    isCombined?: boolean
    createdAt?: boolean
    visit?: boolean | VisitDefaultArgs<ExtArgs>
    service?: boolean | ServiceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["visitService"]>

  export type VisitServiceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    visitId?: boolean
    serviceId?: boolean
    quantity?: boolean
    unitPrice?: boolean
    totalPrice?: boolean
    isChild?: boolean
    isCombined?: boolean
    createdAt?: boolean
    visit?: boolean | VisitDefaultArgs<ExtArgs>
    service?: boolean | ServiceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["visitService"]>

  export type VisitServiceSelectScalar = {
    id?: boolean
    visitId?: boolean
    serviceId?: boolean
    quantity?: boolean
    unitPrice?: boolean
    totalPrice?: boolean
    isChild?: boolean
    isCombined?: boolean
    createdAt?: boolean
  }

  export type VisitServiceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "visitId" | "serviceId" | "quantity" | "unitPrice" | "totalPrice" | "isChild" | "isCombined" | "createdAt", ExtArgs["result"]["visitService"]>
  export type VisitServiceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    visit?: boolean | VisitDefaultArgs<ExtArgs>
    service?: boolean | ServiceDefaultArgs<ExtArgs>
  }
  export type VisitServiceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    visit?: boolean | VisitDefaultArgs<ExtArgs>
    service?: boolean | ServiceDefaultArgs<ExtArgs>
  }
  export type VisitServiceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    visit?: boolean | VisitDefaultArgs<ExtArgs>
    service?: boolean | ServiceDefaultArgs<ExtArgs>
  }

  export type $VisitServicePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VisitService"
    objects: {
      visit: Prisma.$VisitPayload<ExtArgs>
      service: Prisma.$ServicePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      visitId: string
      serviceId: string
      quantity: number
      unitPrice: Prisma.Decimal
      totalPrice: Prisma.Decimal
      isChild: boolean
      isCombined: boolean
      createdAt: Date
    }, ExtArgs["result"]["visitService"]>
    composites: {}
  }

  type VisitServiceGetPayload<S extends boolean | null | undefined | VisitServiceDefaultArgs> = $Result.GetResult<Prisma.$VisitServicePayload, S>

  type VisitServiceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VisitServiceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VisitServiceCountAggregateInputType | true
    }

  export interface VisitServiceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VisitService'], meta: { name: 'VisitService' } }
    /**
     * Find zero or one VisitService that matches the filter.
     * @param {VisitServiceFindUniqueArgs} args - Arguments to find a VisitService
     * @example
     * // Get one VisitService
     * const visitService = await prisma.visitService.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VisitServiceFindUniqueArgs>(args: SelectSubset<T, VisitServiceFindUniqueArgs<ExtArgs>>): Prisma__VisitServiceClient<$Result.GetResult<Prisma.$VisitServicePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one VisitService that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VisitServiceFindUniqueOrThrowArgs} args - Arguments to find a VisitService
     * @example
     * // Get one VisitService
     * const visitService = await prisma.visitService.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VisitServiceFindUniqueOrThrowArgs>(args: SelectSubset<T, VisitServiceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VisitServiceClient<$Result.GetResult<Prisma.$VisitServicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VisitService that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VisitServiceFindFirstArgs} args - Arguments to find a VisitService
     * @example
     * // Get one VisitService
     * const visitService = await prisma.visitService.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VisitServiceFindFirstArgs>(args?: SelectSubset<T, VisitServiceFindFirstArgs<ExtArgs>>): Prisma__VisitServiceClient<$Result.GetResult<Prisma.$VisitServicePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VisitService that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VisitServiceFindFirstOrThrowArgs} args - Arguments to find a VisitService
     * @example
     * // Get one VisitService
     * const visitService = await prisma.visitService.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VisitServiceFindFirstOrThrowArgs>(args?: SelectSubset<T, VisitServiceFindFirstOrThrowArgs<ExtArgs>>): Prisma__VisitServiceClient<$Result.GetResult<Prisma.$VisitServicePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more VisitServices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VisitServiceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VisitServices
     * const visitServices = await prisma.visitService.findMany()
     * 
     * // Get first 10 VisitServices
     * const visitServices = await prisma.visitService.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const visitServiceWithIdOnly = await prisma.visitService.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VisitServiceFindManyArgs>(args?: SelectSubset<T, VisitServiceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VisitServicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a VisitService.
     * @param {VisitServiceCreateArgs} args - Arguments to create a VisitService.
     * @example
     * // Create one VisitService
     * const VisitService = await prisma.visitService.create({
     *   data: {
     *     // ... data to create a VisitService
     *   }
     * })
     * 
     */
    create<T extends VisitServiceCreateArgs>(args: SelectSubset<T, VisitServiceCreateArgs<ExtArgs>>): Prisma__VisitServiceClient<$Result.GetResult<Prisma.$VisitServicePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many VisitServices.
     * @param {VisitServiceCreateManyArgs} args - Arguments to create many VisitServices.
     * @example
     * // Create many VisitServices
     * const visitService = await prisma.visitService.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VisitServiceCreateManyArgs>(args?: SelectSubset<T, VisitServiceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many VisitServices and returns the data saved in the database.
     * @param {VisitServiceCreateManyAndReturnArgs} args - Arguments to create many VisitServices.
     * @example
     * // Create many VisitServices
     * const visitService = await prisma.visitService.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many VisitServices and only return the `id`
     * const visitServiceWithIdOnly = await prisma.visitService.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VisitServiceCreateManyAndReturnArgs>(args?: SelectSubset<T, VisitServiceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VisitServicePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a VisitService.
     * @param {VisitServiceDeleteArgs} args - Arguments to delete one VisitService.
     * @example
     * // Delete one VisitService
     * const VisitService = await prisma.visitService.delete({
     *   where: {
     *     // ... filter to delete one VisitService
     *   }
     * })
     * 
     */
    delete<T extends VisitServiceDeleteArgs>(args: SelectSubset<T, VisitServiceDeleteArgs<ExtArgs>>): Prisma__VisitServiceClient<$Result.GetResult<Prisma.$VisitServicePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one VisitService.
     * @param {VisitServiceUpdateArgs} args - Arguments to update one VisitService.
     * @example
     * // Update one VisitService
     * const visitService = await prisma.visitService.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VisitServiceUpdateArgs>(args: SelectSubset<T, VisitServiceUpdateArgs<ExtArgs>>): Prisma__VisitServiceClient<$Result.GetResult<Prisma.$VisitServicePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more VisitServices.
     * @param {VisitServiceDeleteManyArgs} args - Arguments to filter VisitServices to delete.
     * @example
     * // Delete a few VisitServices
     * const { count } = await prisma.visitService.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VisitServiceDeleteManyArgs>(args?: SelectSubset<T, VisitServiceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VisitServices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VisitServiceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VisitServices
     * const visitService = await prisma.visitService.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VisitServiceUpdateManyArgs>(args: SelectSubset<T, VisitServiceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VisitServices and returns the data updated in the database.
     * @param {VisitServiceUpdateManyAndReturnArgs} args - Arguments to update many VisitServices.
     * @example
     * // Update many VisitServices
     * const visitService = await prisma.visitService.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more VisitServices and only return the `id`
     * const visitServiceWithIdOnly = await prisma.visitService.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VisitServiceUpdateManyAndReturnArgs>(args: SelectSubset<T, VisitServiceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VisitServicePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one VisitService.
     * @param {VisitServiceUpsertArgs} args - Arguments to update or create a VisitService.
     * @example
     * // Update or create a VisitService
     * const visitService = await prisma.visitService.upsert({
     *   create: {
     *     // ... data to create a VisitService
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VisitService we want to update
     *   }
     * })
     */
    upsert<T extends VisitServiceUpsertArgs>(args: SelectSubset<T, VisitServiceUpsertArgs<ExtArgs>>): Prisma__VisitServiceClient<$Result.GetResult<Prisma.$VisitServicePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of VisitServices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VisitServiceCountArgs} args - Arguments to filter VisitServices to count.
     * @example
     * // Count the number of VisitServices
     * const count = await prisma.visitService.count({
     *   where: {
     *     // ... the filter for the VisitServices we want to count
     *   }
     * })
    **/
    count<T extends VisitServiceCountArgs>(
      args?: Subset<T, VisitServiceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VisitServiceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VisitService.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VisitServiceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VisitServiceAggregateArgs>(args: Subset<T, VisitServiceAggregateArgs>): Prisma.PrismaPromise<GetVisitServiceAggregateType<T>>

    /**
     * Group by VisitService.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VisitServiceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VisitServiceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VisitServiceGroupByArgs['orderBy'] }
        : { orderBy?: VisitServiceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VisitServiceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVisitServiceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VisitService model
   */
  readonly fields: VisitServiceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VisitService.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VisitServiceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    visit<T extends VisitDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VisitDefaultArgs<ExtArgs>>): Prisma__VisitClient<$Result.GetResult<Prisma.$VisitPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    service<T extends ServiceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ServiceDefaultArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the VisitService model
   */
  interface VisitServiceFieldRefs {
    readonly id: FieldRef<"VisitService", 'String'>
    readonly visitId: FieldRef<"VisitService", 'String'>
    readonly serviceId: FieldRef<"VisitService", 'String'>
    readonly quantity: FieldRef<"VisitService", 'Int'>
    readonly unitPrice: FieldRef<"VisitService", 'Decimal'>
    readonly totalPrice: FieldRef<"VisitService", 'Decimal'>
    readonly isChild: FieldRef<"VisitService", 'Boolean'>
    readonly isCombined: FieldRef<"VisitService", 'Boolean'>
    readonly createdAt: FieldRef<"VisitService", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * VisitService findUnique
   */
  export type VisitServiceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisitService
     */
    select?: VisitServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VisitService
     */
    omit?: VisitServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitServiceInclude<ExtArgs> | null
    /**
     * Filter, which VisitService to fetch.
     */
    where: VisitServiceWhereUniqueInput
  }

  /**
   * VisitService findUniqueOrThrow
   */
  export type VisitServiceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisitService
     */
    select?: VisitServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VisitService
     */
    omit?: VisitServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitServiceInclude<ExtArgs> | null
    /**
     * Filter, which VisitService to fetch.
     */
    where: VisitServiceWhereUniqueInput
  }

  /**
   * VisitService findFirst
   */
  export type VisitServiceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisitService
     */
    select?: VisitServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VisitService
     */
    omit?: VisitServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitServiceInclude<ExtArgs> | null
    /**
     * Filter, which VisitService to fetch.
     */
    where?: VisitServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VisitServices to fetch.
     */
    orderBy?: VisitServiceOrderByWithRelationInput | VisitServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VisitServices.
     */
    cursor?: VisitServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VisitServices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VisitServices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VisitServices.
     */
    distinct?: VisitServiceScalarFieldEnum | VisitServiceScalarFieldEnum[]
  }

  /**
   * VisitService findFirstOrThrow
   */
  export type VisitServiceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisitService
     */
    select?: VisitServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VisitService
     */
    omit?: VisitServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitServiceInclude<ExtArgs> | null
    /**
     * Filter, which VisitService to fetch.
     */
    where?: VisitServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VisitServices to fetch.
     */
    orderBy?: VisitServiceOrderByWithRelationInput | VisitServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VisitServices.
     */
    cursor?: VisitServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VisitServices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VisitServices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VisitServices.
     */
    distinct?: VisitServiceScalarFieldEnum | VisitServiceScalarFieldEnum[]
  }

  /**
   * VisitService findMany
   */
  export type VisitServiceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisitService
     */
    select?: VisitServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VisitService
     */
    omit?: VisitServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitServiceInclude<ExtArgs> | null
    /**
     * Filter, which VisitServices to fetch.
     */
    where?: VisitServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VisitServices to fetch.
     */
    orderBy?: VisitServiceOrderByWithRelationInput | VisitServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VisitServices.
     */
    cursor?: VisitServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VisitServices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VisitServices.
     */
    skip?: number
    distinct?: VisitServiceScalarFieldEnum | VisitServiceScalarFieldEnum[]
  }

  /**
   * VisitService create
   */
  export type VisitServiceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisitService
     */
    select?: VisitServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VisitService
     */
    omit?: VisitServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitServiceInclude<ExtArgs> | null
    /**
     * The data needed to create a VisitService.
     */
    data: XOR<VisitServiceCreateInput, VisitServiceUncheckedCreateInput>
  }

  /**
   * VisitService createMany
   */
  export type VisitServiceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VisitServices.
     */
    data: VisitServiceCreateManyInput | VisitServiceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VisitService createManyAndReturn
   */
  export type VisitServiceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisitService
     */
    select?: VisitServiceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VisitService
     */
    omit?: VisitServiceOmit<ExtArgs> | null
    /**
     * The data used to create many VisitServices.
     */
    data: VisitServiceCreateManyInput | VisitServiceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitServiceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * VisitService update
   */
  export type VisitServiceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisitService
     */
    select?: VisitServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VisitService
     */
    omit?: VisitServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitServiceInclude<ExtArgs> | null
    /**
     * The data needed to update a VisitService.
     */
    data: XOR<VisitServiceUpdateInput, VisitServiceUncheckedUpdateInput>
    /**
     * Choose, which VisitService to update.
     */
    where: VisitServiceWhereUniqueInput
  }

  /**
   * VisitService updateMany
   */
  export type VisitServiceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VisitServices.
     */
    data: XOR<VisitServiceUpdateManyMutationInput, VisitServiceUncheckedUpdateManyInput>
    /**
     * Filter which VisitServices to update
     */
    where?: VisitServiceWhereInput
    /**
     * Limit how many VisitServices to update.
     */
    limit?: number
  }

  /**
   * VisitService updateManyAndReturn
   */
  export type VisitServiceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisitService
     */
    select?: VisitServiceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VisitService
     */
    omit?: VisitServiceOmit<ExtArgs> | null
    /**
     * The data used to update VisitServices.
     */
    data: XOR<VisitServiceUpdateManyMutationInput, VisitServiceUncheckedUpdateManyInput>
    /**
     * Filter which VisitServices to update
     */
    where?: VisitServiceWhereInput
    /**
     * Limit how many VisitServices to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitServiceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * VisitService upsert
   */
  export type VisitServiceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisitService
     */
    select?: VisitServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VisitService
     */
    omit?: VisitServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitServiceInclude<ExtArgs> | null
    /**
     * The filter to search for the VisitService to update in case it exists.
     */
    where: VisitServiceWhereUniqueInput
    /**
     * In case the VisitService found by the `where` argument doesn't exist, create a new VisitService with this data.
     */
    create: XOR<VisitServiceCreateInput, VisitServiceUncheckedCreateInput>
    /**
     * In case the VisitService was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VisitServiceUpdateInput, VisitServiceUncheckedUpdateInput>
  }

  /**
   * VisitService delete
   */
  export type VisitServiceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisitService
     */
    select?: VisitServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VisitService
     */
    omit?: VisitServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitServiceInclude<ExtArgs> | null
    /**
     * Filter which VisitService to delete.
     */
    where: VisitServiceWhereUniqueInput
  }

  /**
   * VisitService deleteMany
   */
  export type VisitServiceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VisitServices to delete
     */
    where?: VisitServiceWhereInput
    /**
     * Limit how many VisitServices to delete.
     */
    limit?: number
  }

  /**
   * VisitService without action
   */
  export type VisitServiceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisitService
     */
    select?: VisitServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VisitService
     */
    omit?: VisitServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitServiceInclude<ExtArgs> | null
  }


  /**
   * Model VisitStaff
   */

  export type AggregateVisitStaff = {
    _count: VisitStaffCountAggregateOutputType | null
    _min: VisitStaffMinAggregateOutputType | null
    _max: VisitStaffMaxAggregateOutputType | null
  }

  export type VisitStaffMinAggregateOutputType = {
    id: string | null
    visitId: string | null
    staffId: string | null
    serviceId: string | null
    createdAt: Date | null
  }

  export type VisitStaffMaxAggregateOutputType = {
    id: string | null
    visitId: string | null
    staffId: string | null
    serviceId: string | null
    createdAt: Date | null
  }

  export type VisitStaffCountAggregateOutputType = {
    id: number
    visitId: number
    staffId: number
    serviceId: number
    createdAt: number
    _all: number
  }


  export type VisitStaffMinAggregateInputType = {
    id?: true
    visitId?: true
    staffId?: true
    serviceId?: true
    createdAt?: true
  }

  export type VisitStaffMaxAggregateInputType = {
    id?: true
    visitId?: true
    staffId?: true
    serviceId?: true
    createdAt?: true
  }

  export type VisitStaffCountAggregateInputType = {
    id?: true
    visitId?: true
    staffId?: true
    serviceId?: true
    createdAt?: true
    _all?: true
  }

  export type VisitStaffAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VisitStaff to aggregate.
     */
    where?: VisitStaffWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VisitStaffs to fetch.
     */
    orderBy?: VisitStaffOrderByWithRelationInput | VisitStaffOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VisitStaffWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VisitStaffs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VisitStaffs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VisitStaffs
    **/
    _count?: true | VisitStaffCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VisitStaffMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VisitStaffMaxAggregateInputType
  }

  export type GetVisitStaffAggregateType<T extends VisitStaffAggregateArgs> = {
        [P in keyof T & keyof AggregateVisitStaff]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVisitStaff[P]>
      : GetScalarType<T[P], AggregateVisitStaff[P]>
  }




  export type VisitStaffGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VisitStaffWhereInput
    orderBy?: VisitStaffOrderByWithAggregationInput | VisitStaffOrderByWithAggregationInput[]
    by: VisitStaffScalarFieldEnum[] | VisitStaffScalarFieldEnum
    having?: VisitStaffScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VisitStaffCountAggregateInputType | true
    _min?: VisitStaffMinAggregateInputType
    _max?: VisitStaffMaxAggregateInputType
  }

  export type VisitStaffGroupByOutputType = {
    id: string
    visitId: string
    staffId: string
    serviceId: string | null
    createdAt: Date
    _count: VisitStaffCountAggregateOutputType | null
    _min: VisitStaffMinAggregateOutputType | null
    _max: VisitStaffMaxAggregateOutputType | null
  }

  type GetVisitStaffGroupByPayload<T extends VisitStaffGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VisitStaffGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VisitStaffGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VisitStaffGroupByOutputType[P]>
            : GetScalarType<T[P], VisitStaffGroupByOutputType[P]>
        }
      >
    >


  export type VisitStaffSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    visitId?: boolean
    staffId?: boolean
    serviceId?: boolean
    createdAt?: boolean
    visit?: boolean | VisitDefaultArgs<ExtArgs>
    staff?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["visitStaff"]>

  export type VisitStaffSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    visitId?: boolean
    staffId?: boolean
    serviceId?: boolean
    createdAt?: boolean
    visit?: boolean | VisitDefaultArgs<ExtArgs>
    staff?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["visitStaff"]>

  export type VisitStaffSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    visitId?: boolean
    staffId?: boolean
    serviceId?: boolean
    createdAt?: boolean
    visit?: boolean | VisitDefaultArgs<ExtArgs>
    staff?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["visitStaff"]>

  export type VisitStaffSelectScalar = {
    id?: boolean
    visitId?: boolean
    staffId?: boolean
    serviceId?: boolean
    createdAt?: boolean
  }

  export type VisitStaffOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "visitId" | "staffId" | "serviceId" | "createdAt", ExtArgs["result"]["visitStaff"]>
  export type VisitStaffInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    visit?: boolean | VisitDefaultArgs<ExtArgs>
    staff?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type VisitStaffIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    visit?: boolean | VisitDefaultArgs<ExtArgs>
    staff?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type VisitStaffIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    visit?: boolean | VisitDefaultArgs<ExtArgs>
    staff?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $VisitStaffPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VisitStaff"
    objects: {
      visit: Prisma.$VisitPayload<ExtArgs>
      staff: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      visitId: string
      staffId: string
      serviceId: string | null
      createdAt: Date
    }, ExtArgs["result"]["visitStaff"]>
    composites: {}
  }

  type VisitStaffGetPayload<S extends boolean | null | undefined | VisitStaffDefaultArgs> = $Result.GetResult<Prisma.$VisitStaffPayload, S>

  type VisitStaffCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VisitStaffFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VisitStaffCountAggregateInputType | true
    }

  export interface VisitStaffDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VisitStaff'], meta: { name: 'VisitStaff' } }
    /**
     * Find zero or one VisitStaff that matches the filter.
     * @param {VisitStaffFindUniqueArgs} args - Arguments to find a VisitStaff
     * @example
     * // Get one VisitStaff
     * const visitStaff = await prisma.visitStaff.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VisitStaffFindUniqueArgs>(args: SelectSubset<T, VisitStaffFindUniqueArgs<ExtArgs>>): Prisma__VisitStaffClient<$Result.GetResult<Prisma.$VisitStaffPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one VisitStaff that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VisitStaffFindUniqueOrThrowArgs} args - Arguments to find a VisitStaff
     * @example
     * // Get one VisitStaff
     * const visitStaff = await prisma.visitStaff.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VisitStaffFindUniqueOrThrowArgs>(args: SelectSubset<T, VisitStaffFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VisitStaffClient<$Result.GetResult<Prisma.$VisitStaffPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VisitStaff that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VisitStaffFindFirstArgs} args - Arguments to find a VisitStaff
     * @example
     * // Get one VisitStaff
     * const visitStaff = await prisma.visitStaff.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VisitStaffFindFirstArgs>(args?: SelectSubset<T, VisitStaffFindFirstArgs<ExtArgs>>): Prisma__VisitStaffClient<$Result.GetResult<Prisma.$VisitStaffPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VisitStaff that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VisitStaffFindFirstOrThrowArgs} args - Arguments to find a VisitStaff
     * @example
     * // Get one VisitStaff
     * const visitStaff = await prisma.visitStaff.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VisitStaffFindFirstOrThrowArgs>(args?: SelectSubset<T, VisitStaffFindFirstOrThrowArgs<ExtArgs>>): Prisma__VisitStaffClient<$Result.GetResult<Prisma.$VisitStaffPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more VisitStaffs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VisitStaffFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VisitStaffs
     * const visitStaffs = await prisma.visitStaff.findMany()
     * 
     * // Get first 10 VisitStaffs
     * const visitStaffs = await prisma.visitStaff.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const visitStaffWithIdOnly = await prisma.visitStaff.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VisitStaffFindManyArgs>(args?: SelectSubset<T, VisitStaffFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VisitStaffPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a VisitStaff.
     * @param {VisitStaffCreateArgs} args - Arguments to create a VisitStaff.
     * @example
     * // Create one VisitStaff
     * const VisitStaff = await prisma.visitStaff.create({
     *   data: {
     *     // ... data to create a VisitStaff
     *   }
     * })
     * 
     */
    create<T extends VisitStaffCreateArgs>(args: SelectSubset<T, VisitStaffCreateArgs<ExtArgs>>): Prisma__VisitStaffClient<$Result.GetResult<Prisma.$VisitStaffPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many VisitStaffs.
     * @param {VisitStaffCreateManyArgs} args - Arguments to create many VisitStaffs.
     * @example
     * // Create many VisitStaffs
     * const visitStaff = await prisma.visitStaff.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VisitStaffCreateManyArgs>(args?: SelectSubset<T, VisitStaffCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many VisitStaffs and returns the data saved in the database.
     * @param {VisitStaffCreateManyAndReturnArgs} args - Arguments to create many VisitStaffs.
     * @example
     * // Create many VisitStaffs
     * const visitStaff = await prisma.visitStaff.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many VisitStaffs and only return the `id`
     * const visitStaffWithIdOnly = await prisma.visitStaff.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VisitStaffCreateManyAndReturnArgs>(args?: SelectSubset<T, VisitStaffCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VisitStaffPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a VisitStaff.
     * @param {VisitStaffDeleteArgs} args - Arguments to delete one VisitStaff.
     * @example
     * // Delete one VisitStaff
     * const VisitStaff = await prisma.visitStaff.delete({
     *   where: {
     *     // ... filter to delete one VisitStaff
     *   }
     * })
     * 
     */
    delete<T extends VisitStaffDeleteArgs>(args: SelectSubset<T, VisitStaffDeleteArgs<ExtArgs>>): Prisma__VisitStaffClient<$Result.GetResult<Prisma.$VisitStaffPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one VisitStaff.
     * @param {VisitStaffUpdateArgs} args - Arguments to update one VisitStaff.
     * @example
     * // Update one VisitStaff
     * const visitStaff = await prisma.visitStaff.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VisitStaffUpdateArgs>(args: SelectSubset<T, VisitStaffUpdateArgs<ExtArgs>>): Prisma__VisitStaffClient<$Result.GetResult<Prisma.$VisitStaffPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more VisitStaffs.
     * @param {VisitStaffDeleteManyArgs} args - Arguments to filter VisitStaffs to delete.
     * @example
     * // Delete a few VisitStaffs
     * const { count } = await prisma.visitStaff.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VisitStaffDeleteManyArgs>(args?: SelectSubset<T, VisitStaffDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VisitStaffs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VisitStaffUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VisitStaffs
     * const visitStaff = await prisma.visitStaff.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VisitStaffUpdateManyArgs>(args: SelectSubset<T, VisitStaffUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VisitStaffs and returns the data updated in the database.
     * @param {VisitStaffUpdateManyAndReturnArgs} args - Arguments to update many VisitStaffs.
     * @example
     * // Update many VisitStaffs
     * const visitStaff = await prisma.visitStaff.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more VisitStaffs and only return the `id`
     * const visitStaffWithIdOnly = await prisma.visitStaff.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VisitStaffUpdateManyAndReturnArgs>(args: SelectSubset<T, VisitStaffUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VisitStaffPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one VisitStaff.
     * @param {VisitStaffUpsertArgs} args - Arguments to update or create a VisitStaff.
     * @example
     * // Update or create a VisitStaff
     * const visitStaff = await prisma.visitStaff.upsert({
     *   create: {
     *     // ... data to create a VisitStaff
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VisitStaff we want to update
     *   }
     * })
     */
    upsert<T extends VisitStaffUpsertArgs>(args: SelectSubset<T, VisitStaffUpsertArgs<ExtArgs>>): Prisma__VisitStaffClient<$Result.GetResult<Prisma.$VisitStaffPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of VisitStaffs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VisitStaffCountArgs} args - Arguments to filter VisitStaffs to count.
     * @example
     * // Count the number of VisitStaffs
     * const count = await prisma.visitStaff.count({
     *   where: {
     *     // ... the filter for the VisitStaffs we want to count
     *   }
     * })
    **/
    count<T extends VisitStaffCountArgs>(
      args?: Subset<T, VisitStaffCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VisitStaffCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VisitStaff.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VisitStaffAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VisitStaffAggregateArgs>(args: Subset<T, VisitStaffAggregateArgs>): Prisma.PrismaPromise<GetVisitStaffAggregateType<T>>

    /**
     * Group by VisitStaff.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VisitStaffGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VisitStaffGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VisitStaffGroupByArgs['orderBy'] }
        : { orderBy?: VisitStaffGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VisitStaffGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVisitStaffGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VisitStaff model
   */
  readonly fields: VisitStaffFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VisitStaff.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VisitStaffClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    visit<T extends VisitDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VisitDefaultArgs<ExtArgs>>): Prisma__VisitClient<$Result.GetResult<Prisma.$VisitPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    staff<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the VisitStaff model
   */
  interface VisitStaffFieldRefs {
    readonly id: FieldRef<"VisitStaff", 'String'>
    readonly visitId: FieldRef<"VisitStaff", 'String'>
    readonly staffId: FieldRef<"VisitStaff", 'String'>
    readonly serviceId: FieldRef<"VisitStaff", 'String'>
    readonly createdAt: FieldRef<"VisitStaff", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * VisitStaff findUnique
   */
  export type VisitStaffFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisitStaff
     */
    select?: VisitStaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VisitStaff
     */
    omit?: VisitStaffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitStaffInclude<ExtArgs> | null
    /**
     * Filter, which VisitStaff to fetch.
     */
    where: VisitStaffWhereUniqueInput
  }

  /**
   * VisitStaff findUniqueOrThrow
   */
  export type VisitStaffFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisitStaff
     */
    select?: VisitStaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VisitStaff
     */
    omit?: VisitStaffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitStaffInclude<ExtArgs> | null
    /**
     * Filter, which VisitStaff to fetch.
     */
    where: VisitStaffWhereUniqueInput
  }

  /**
   * VisitStaff findFirst
   */
  export type VisitStaffFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisitStaff
     */
    select?: VisitStaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VisitStaff
     */
    omit?: VisitStaffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitStaffInclude<ExtArgs> | null
    /**
     * Filter, which VisitStaff to fetch.
     */
    where?: VisitStaffWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VisitStaffs to fetch.
     */
    orderBy?: VisitStaffOrderByWithRelationInput | VisitStaffOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VisitStaffs.
     */
    cursor?: VisitStaffWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VisitStaffs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VisitStaffs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VisitStaffs.
     */
    distinct?: VisitStaffScalarFieldEnum | VisitStaffScalarFieldEnum[]
  }

  /**
   * VisitStaff findFirstOrThrow
   */
  export type VisitStaffFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisitStaff
     */
    select?: VisitStaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VisitStaff
     */
    omit?: VisitStaffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitStaffInclude<ExtArgs> | null
    /**
     * Filter, which VisitStaff to fetch.
     */
    where?: VisitStaffWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VisitStaffs to fetch.
     */
    orderBy?: VisitStaffOrderByWithRelationInput | VisitStaffOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VisitStaffs.
     */
    cursor?: VisitStaffWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VisitStaffs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VisitStaffs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VisitStaffs.
     */
    distinct?: VisitStaffScalarFieldEnum | VisitStaffScalarFieldEnum[]
  }

  /**
   * VisitStaff findMany
   */
  export type VisitStaffFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisitStaff
     */
    select?: VisitStaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VisitStaff
     */
    omit?: VisitStaffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitStaffInclude<ExtArgs> | null
    /**
     * Filter, which VisitStaffs to fetch.
     */
    where?: VisitStaffWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VisitStaffs to fetch.
     */
    orderBy?: VisitStaffOrderByWithRelationInput | VisitStaffOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VisitStaffs.
     */
    cursor?: VisitStaffWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VisitStaffs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VisitStaffs.
     */
    skip?: number
    distinct?: VisitStaffScalarFieldEnum | VisitStaffScalarFieldEnum[]
  }

  /**
   * VisitStaff create
   */
  export type VisitStaffCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisitStaff
     */
    select?: VisitStaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VisitStaff
     */
    omit?: VisitStaffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitStaffInclude<ExtArgs> | null
    /**
     * The data needed to create a VisitStaff.
     */
    data: XOR<VisitStaffCreateInput, VisitStaffUncheckedCreateInput>
  }

  /**
   * VisitStaff createMany
   */
  export type VisitStaffCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VisitStaffs.
     */
    data: VisitStaffCreateManyInput | VisitStaffCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VisitStaff createManyAndReturn
   */
  export type VisitStaffCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisitStaff
     */
    select?: VisitStaffSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VisitStaff
     */
    omit?: VisitStaffOmit<ExtArgs> | null
    /**
     * The data used to create many VisitStaffs.
     */
    data: VisitStaffCreateManyInput | VisitStaffCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitStaffIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * VisitStaff update
   */
  export type VisitStaffUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisitStaff
     */
    select?: VisitStaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VisitStaff
     */
    omit?: VisitStaffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitStaffInclude<ExtArgs> | null
    /**
     * The data needed to update a VisitStaff.
     */
    data: XOR<VisitStaffUpdateInput, VisitStaffUncheckedUpdateInput>
    /**
     * Choose, which VisitStaff to update.
     */
    where: VisitStaffWhereUniqueInput
  }

  /**
   * VisitStaff updateMany
   */
  export type VisitStaffUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VisitStaffs.
     */
    data: XOR<VisitStaffUpdateManyMutationInput, VisitStaffUncheckedUpdateManyInput>
    /**
     * Filter which VisitStaffs to update
     */
    where?: VisitStaffWhereInput
    /**
     * Limit how many VisitStaffs to update.
     */
    limit?: number
  }

  /**
   * VisitStaff updateManyAndReturn
   */
  export type VisitStaffUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisitStaff
     */
    select?: VisitStaffSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VisitStaff
     */
    omit?: VisitStaffOmit<ExtArgs> | null
    /**
     * The data used to update VisitStaffs.
     */
    data: XOR<VisitStaffUpdateManyMutationInput, VisitStaffUncheckedUpdateManyInput>
    /**
     * Filter which VisitStaffs to update
     */
    where?: VisitStaffWhereInput
    /**
     * Limit how many VisitStaffs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitStaffIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * VisitStaff upsert
   */
  export type VisitStaffUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisitStaff
     */
    select?: VisitStaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VisitStaff
     */
    omit?: VisitStaffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitStaffInclude<ExtArgs> | null
    /**
     * The filter to search for the VisitStaff to update in case it exists.
     */
    where: VisitStaffWhereUniqueInput
    /**
     * In case the VisitStaff found by the `where` argument doesn't exist, create a new VisitStaff with this data.
     */
    create: XOR<VisitStaffCreateInput, VisitStaffUncheckedCreateInput>
    /**
     * In case the VisitStaff was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VisitStaffUpdateInput, VisitStaffUncheckedUpdateInput>
  }

  /**
   * VisitStaff delete
   */
  export type VisitStaffDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisitStaff
     */
    select?: VisitStaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VisitStaff
     */
    omit?: VisitStaffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitStaffInclude<ExtArgs> | null
    /**
     * Filter which VisitStaff to delete.
     */
    where: VisitStaffWhereUniqueInput
  }

  /**
   * VisitStaff deleteMany
   */
  export type VisitStaffDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VisitStaffs to delete
     */
    where?: VisitStaffWhereInput
    /**
     * Limit how many VisitStaffs to delete.
     */
    limit?: number
  }

  /**
   * VisitStaff without action
   */
  export type VisitStaffDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisitStaff
     */
    select?: VisitStaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VisitStaff
     */
    omit?: VisitStaffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitStaffInclude<ExtArgs> | null
  }


  /**
   * Model DiscountRule
   */

  export type AggregateDiscountRule = {
    _count: DiscountRuleCountAggregateOutputType | null
    _avg: DiscountRuleAvgAggregateOutputType | null
    _sum: DiscountRuleSumAggregateOutputType | null
    _min: DiscountRuleMinAggregateOutputType | null
    _max: DiscountRuleMaxAggregateOutputType | null
  }

  export type DiscountRuleAvgAggregateOutputType = {
    value: Decimal | null
    minAmount: Decimal | null
    maxDiscount: Decimal | null
  }

  export type DiscountRuleSumAggregateOutputType = {
    value: Decimal | null
    minAmount: Decimal | null
    maxDiscount: Decimal | null
  }

  export type DiscountRuleMinAggregateOutputType = {
    id: string | null
    name: string | null
    type: $Enums.DiscountType | null
    value: Decimal | null
    isPercentage: boolean | null
    isActive: boolean | null
    description: string | null
    minAmount: Decimal | null
    maxDiscount: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DiscountRuleMaxAggregateOutputType = {
    id: string | null
    name: string | null
    type: $Enums.DiscountType | null
    value: Decimal | null
    isPercentage: boolean | null
    isActive: boolean | null
    description: string | null
    minAmount: Decimal | null
    maxDiscount: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DiscountRuleCountAggregateOutputType = {
    id: number
    name: number
    type: number
    value: number
    isPercentage: number
    isActive: number
    description: number
    minAmount: number
    maxDiscount: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DiscountRuleAvgAggregateInputType = {
    value?: true
    minAmount?: true
    maxDiscount?: true
  }

  export type DiscountRuleSumAggregateInputType = {
    value?: true
    minAmount?: true
    maxDiscount?: true
  }

  export type DiscountRuleMinAggregateInputType = {
    id?: true
    name?: true
    type?: true
    value?: true
    isPercentage?: true
    isActive?: true
    description?: true
    minAmount?: true
    maxDiscount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DiscountRuleMaxAggregateInputType = {
    id?: true
    name?: true
    type?: true
    value?: true
    isPercentage?: true
    isActive?: true
    description?: true
    minAmount?: true
    maxDiscount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DiscountRuleCountAggregateInputType = {
    id?: true
    name?: true
    type?: true
    value?: true
    isPercentage?: true
    isActive?: true
    description?: true
    minAmount?: true
    maxDiscount?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DiscountRuleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DiscountRule to aggregate.
     */
    where?: DiscountRuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DiscountRules to fetch.
     */
    orderBy?: DiscountRuleOrderByWithRelationInput | DiscountRuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DiscountRuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DiscountRules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DiscountRules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DiscountRules
    **/
    _count?: true | DiscountRuleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DiscountRuleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DiscountRuleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DiscountRuleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DiscountRuleMaxAggregateInputType
  }

  export type GetDiscountRuleAggregateType<T extends DiscountRuleAggregateArgs> = {
        [P in keyof T & keyof AggregateDiscountRule]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDiscountRule[P]>
      : GetScalarType<T[P], AggregateDiscountRule[P]>
  }




  export type DiscountRuleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DiscountRuleWhereInput
    orderBy?: DiscountRuleOrderByWithAggregationInput | DiscountRuleOrderByWithAggregationInput[]
    by: DiscountRuleScalarFieldEnum[] | DiscountRuleScalarFieldEnum
    having?: DiscountRuleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DiscountRuleCountAggregateInputType | true
    _avg?: DiscountRuleAvgAggregateInputType
    _sum?: DiscountRuleSumAggregateInputType
    _min?: DiscountRuleMinAggregateInputType
    _max?: DiscountRuleMaxAggregateInputType
  }

  export type DiscountRuleGroupByOutputType = {
    id: string
    name: string
    type: $Enums.DiscountType
    value: Decimal
    isPercentage: boolean
    isActive: boolean
    description: string | null
    minAmount: Decimal | null
    maxDiscount: Decimal | null
    createdAt: Date
    updatedAt: Date
    _count: DiscountRuleCountAggregateOutputType | null
    _avg: DiscountRuleAvgAggregateOutputType | null
    _sum: DiscountRuleSumAggregateOutputType | null
    _min: DiscountRuleMinAggregateOutputType | null
    _max: DiscountRuleMaxAggregateOutputType | null
  }

  type GetDiscountRuleGroupByPayload<T extends DiscountRuleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DiscountRuleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DiscountRuleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DiscountRuleGroupByOutputType[P]>
            : GetScalarType<T[P], DiscountRuleGroupByOutputType[P]>
        }
      >
    >


  export type DiscountRuleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    value?: boolean
    isPercentage?: boolean
    isActive?: boolean
    description?: boolean
    minAmount?: boolean
    maxDiscount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    visitDiscounts?: boolean | DiscountRule$visitDiscountsArgs<ExtArgs>
    customerDiscounts?: boolean | DiscountRule$customerDiscountsArgs<ExtArgs>
    _count?: boolean | DiscountRuleCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["discountRule"]>

  export type DiscountRuleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    value?: boolean
    isPercentage?: boolean
    isActive?: boolean
    description?: boolean
    minAmount?: boolean
    maxDiscount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["discountRule"]>

  export type DiscountRuleSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    value?: boolean
    isPercentage?: boolean
    isActive?: boolean
    description?: boolean
    minAmount?: boolean
    maxDiscount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["discountRule"]>

  export type DiscountRuleSelectScalar = {
    id?: boolean
    name?: boolean
    type?: boolean
    value?: boolean
    isPercentage?: boolean
    isActive?: boolean
    description?: boolean
    minAmount?: boolean
    maxDiscount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DiscountRuleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "type" | "value" | "isPercentage" | "isActive" | "description" | "minAmount" | "maxDiscount" | "createdAt" | "updatedAt", ExtArgs["result"]["discountRule"]>
  export type DiscountRuleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    visitDiscounts?: boolean | DiscountRule$visitDiscountsArgs<ExtArgs>
    customerDiscounts?: boolean | DiscountRule$customerDiscountsArgs<ExtArgs>
    _count?: boolean | DiscountRuleCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type DiscountRuleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type DiscountRuleIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $DiscountRulePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DiscountRule"
    objects: {
      visitDiscounts: Prisma.$VisitDiscountPayload<ExtArgs>[]
      customerDiscounts: Prisma.$CustomerDiscountPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      type: $Enums.DiscountType
      value: Prisma.Decimal
      isPercentage: boolean
      isActive: boolean
      description: string | null
      minAmount: Prisma.Decimal | null
      maxDiscount: Prisma.Decimal | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["discountRule"]>
    composites: {}
  }

  type DiscountRuleGetPayload<S extends boolean | null | undefined | DiscountRuleDefaultArgs> = $Result.GetResult<Prisma.$DiscountRulePayload, S>

  type DiscountRuleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DiscountRuleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DiscountRuleCountAggregateInputType | true
    }

  export interface DiscountRuleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DiscountRule'], meta: { name: 'DiscountRule' } }
    /**
     * Find zero or one DiscountRule that matches the filter.
     * @param {DiscountRuleFindUniqueArgs} args - Arguments to find a DiscountRule
     * @example
     * // Get one DiscountRule
     * const discountRule = await prisma.discountRule.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DiscountRuleFindUniqueArgs>(args: SelectSubset<T, DiscountRuleFindUniqueArgs<ExtArgs>>): Prisma__DiscountRuleClient<$Result.GetResult<Prisma.$DiscountRulePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DiscountRule that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DiscountRuleFindUniqueOrThrowArgs} args - Arguments to find a DiscountRule
     * @example
     * // Get one DiscountRule
     * const discountRule = await prisma.discountRule.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DiscountRuleFindUniqueOrThrowArgs>(args: SelectSubset<T, DiscountRuleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DiscountRuleClient<$Result.GetResult<Prisma.$DiscountRulePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DiscountRule that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiscountRuleFindFirstArgs} args - Arguments to find a DiscountRule
     * @example
     * // Get one DiscountRule
     * const discountRule = await prisma.discountRule.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DiscountRuleFindFirstArgs>(args?: SelectSubset<T, DiscountRuleFindFirstArgs<ExtArgs>>): Prisma__DiscountRuleClient<$Result.GetResult<Prisma.$DiscountRulePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DiscountRule that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiscountRuleFindFirstOrThrowArgs} args - Arguments to find a DiscountRule
     * @example
     * // Get one DiscountRule
     * const discountRule = await prisma.discountRule.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DiscountRuleFindFirstOrThrowArgs>(args?: SelectSubset<T, DiscountRuleFindFirstOrThrowArgs<ExtArgs>>): Prisma__DiscountRuleClient<$Result.GetResult<Prisma.$DiscountRulePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DiscountRules that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiscountRuleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DiscountRules
     * const discountRules = await prisma.discountRule.findMany()
     * 
     * // Get first 10 DiscountRules
     * const discountRules = await prisma.discountRule.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const discountRuleWithIdOnly = await prisma.discountRule.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DiscountRuleFindManyArgs>(args?: SelectSubset<T, DiscountRuleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DiscountRulePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DiscountRule.
     * @param {DiscountRuleCreateArgs} args - Arguments to create a DiscountRule.
     * @example
     * // Create one DiscountRule
     * const DiscountRule = await prisma.discountRule.create({
     *   data: {
     *     // ... data to create a DiscountRule
     *   }
     * })
     * 
     */
    create<T extends DiscountRuleCreateArgs>(args: SelectSubset<T, DiscountRuleCreateArgs<ExtArgs>>): Prisma__DiscountRuleClient<$Result.GetResult<Prisma.$DiscountRulePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DiscountRules.
     * @param {DiscountRuleCreateManyArgs} args - Arguments to create many DiscountRules.
     * @example
     * // Create many DiscountRules
     * const discountRule = await prisma.discountRule.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DiscountRuleCreateManyArgs>(args?: SelectSubset<T, DiscountRuleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DiscountRules and returns the data saved in the database.
     * @param {DiscountRuleCreateManyAndReturnArgs} args - Arguments to create many DiscountRules.
     * @example
     * // Create many DiscountRules
     * const discountRule = await prisma.discountRule.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DiscountRules and only return the `id`
     * const discountRuleWithIdOnly = await prisma.discountRule.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DiscountRuleCreateManyAndReturnArgs>(args?: SelectSubset<T, DiscountRuleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DiscountRulePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a DiscountRule.
     * @param {DiscountRuleDeleteArgs} args - Arguments to delete one DiscountRule.
     * @example
     * // Delete one DiscountRule
     * const DiscountRule = await prisma.discountRule.delete({
     *   where: {
     *     // ... filter to delete one DiscountRule
     *   }
     * })
     * 
     */
    delete<T extends DiscountRuleDeleteArgs>(args: SelectSubset<T, DiscountRuleDeleteArgs<ExtArgs>>): Prisma__DiscountRuleClient<$Result.GetResult<Prisma.$DiscountRulePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DiscountRule.
     * @param {DiscountRuleUpdateArgs} args - Arguments to update one DiscountRule.
     * @example
     * // Update one DiscountRule
     * const discountRule = await prisma.discountRule.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DiscountRuleUpdateArgs>(args: SelectSubset<T, DiscountRuleUpdateArgs<ExtArgs>>): Prisma__DiscountRuleClient<$Result.GetResult<Prisma.$DiscountRulePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DiscountRules.
     * @param {DiscountRuleDeleteManyArgs} args - Arguments to filter DiscountRules to delete.
     * @example
     * // Delete a few DiscountRules
     * const { count } = await prisma.discountRule.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DiscountRuleDeleteManyArgs>(args?: SelectSubset<T, DiscountRuleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DiscountRules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiscountRuleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DiscountRules
     * const discountRule = await prisma.discountRule.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DiscountRuleUpdateManyArgs>(args: SelectSubset<T, DiscountRuleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DiscountRules and returns the data updated in the database.
     * @param {DiscountRuleUpdateManyAndReturnArgs} args - Arguments to update many DiscountRules.
     * @example
     * // Update many DiscountRules
     * const discountRule = await prisma.discountRule.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DiscountRules and only return the `id`
     * const discountRuleWithIdOnly = await prisma.discountRule.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DiscountRuleUpdateManyAndReturnArgs>(args: SelectSubset<T, DiscountRuleUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DiscountRulePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one DiscountRule.
     * @param {DiscountRuleUpsertArgs} args - Arguments to update or create a DiscountRule.
     * @example
     * // Update or create a DiscountRule
     * const discountRule = await prisma.discountRule.upsert({
     *   create: {
     *     // ... data to create a DiscountRule
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DiscountRule we want to update
     *   }
     * })
     */
    upsert<T extends DiscountRuleUpsertArgs>(args: SelectSubset<T, DiscountRuleUpsertArgs<ExtArgs>>): Prisma__DiscountRuleClient<$Result.GetResult<Prisma.$DiscountRulePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DiscountRules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiscountRuleCountArgs} args - Arguments to filter DiscountRules to count.
     * @example
     * // Count the number of DiscountRules
     * const count = await prisma.discountRule.count({
     *   where: {
     *     // ... the filter for the DiscountRules we want to count
     *   }
     * })
    **/
    count<T extends DiscountRuleCountArgs>(
      args?: Subset<T, DiscountRuleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DiscountRuleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DiscountRule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiscountRuleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DiscountRuleAggregateArgs>(args: Subset<T, DiscountRuleAggregateArgs>): Prisma.PrismaPromise<GetDiscountRuleAggregateType<T>>

    /**
     * Group by DiscountRule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiscountRuleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DiscountRuleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DiscountRuleGroupByArgs['orderBy'] }
        : { orderBy?: DiscountRuleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DiscountRuleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDiscountRuleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DiscountRule model
   */
  readonly fields: DiscountRuleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DiscountRule.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DiscountRuleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    visitDiscounts<T extends DiscountRule$visitDiscountsArgs<ExtArgs> = {}>(args?: Subset<T, DiscountRule$visitDiscountsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VisitDiscountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    customerDiscounts<T extends DiscountRule$customerDiscountsArgs<ExtArgs> = {}>(args?: Subset<T, DiscountRule$customerDiscountsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerDiscountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DiscountRule model
   */
  interface DiscountRuleFieldRefs {
    readonly id: FieldRef<"DiscountRule", 'String'>
    readonly name: FieldRef<"DiscountRule", 'String'>
    readonly type: FieldRef<"DiscountRule", 'DiscountType'>
    readonly value: FieldRef<"DiscountRule", 'Decimal'>
    readonly isPercentage: FieldRef<"DiscountRule", 'Boolean'>
    readonly isActive: FieldRef<"DiscountRule", 'Boolean'>
    readonly description: FieldRef<"DiscountRule", 'String'>
    readonly minAmount: FieldRef<"DiscountRule", 'Decimal'>
    readonly maxDiscount: FieldRef<"DiscountRule", 'Decimal'>
    readonly createdAt: FieldRef<"DiscountRule", 'DateTime'>
    readonly updatedAt: FieldRef<"DiscountRule", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DiscountRule findUnique
   */
  export type DiscountRuleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DiscountRule
     */
    select?: DiscountRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DiscountRule
     */
    omit?: DiscountRuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiscountRuleInclude<ExtArgs> | null
    /**
     * Filter, which DiscountRule to fetch.
     */
    where: DiscountRuleWhereUniqueInput
  }

  /**
   * DiscountRule findUniqueOrThrow
   */
  export type DiscountRuleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DiscountRule
     */
    select?: DiscountRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DiscountRule
     */
    omit?: DiscountRuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiscountRuleInclude<ExtArgs> | null
    /**
     * Filter, which DiscountRule to fetch.
     */
    where: DiscountRuleWhereUniqueInput
  }

  /**
   * DiscountRule findFirst
   */
  export type DiscountRuleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DiscountRule
     */
    select?: DiscountRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DiscountRule
     */
    omit?: DiscountRuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiscountRuleInclude<ExtArgs> | null
    /**
     * Filter, which DiscountRule to fetch.
     */
    where?: DiscountRuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DiscountRules to fetch.
     */
    orderBy?: DiscountRuleOrderByWithRelationInput | DiscountRuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DiscountRules.
     */
    cursor?: DiscountRuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DiscountRules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DiscountRules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DiscountRules.
     */
    distinct?: DiscountRuleScalarFieldEnum | DiscountRuleScalarFieldEnum[]
  }

  /**
   * DiscountRule findFirstOrThrow
   */
  export type DiscountRuleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DiscountRule
     */
    select?: DiscountRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DiscountRule
     */
    omit?: DiscountRuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiscountRuleInclude<ExtArgs> | null
    /**
     * Filter, which DiscountRule to fetch.
     */
    where?: DiscountRuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DiscountRules to fetch.
     */
    orderBy?: DiscountRuleOrderByWithRelationInput | DiscountRuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DiscountRules.
     */
    cursor?: DiscountRuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DiscountRules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DiscountRules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DiscountRules.
     */
    distinct?: DiscountRuleScalarFieldEnum | DiscountRuleScalarFieldEnum[]
  }

  /**
   * DiscountRule findMany
   */
  export type DiscountRuleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DiscountRule
     */
    select?: DiscountRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DiscountRule
     */
    omit?: DiscountRuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiscountRuleInclude<ExtArgs> | null
    /**
     * Filter, which DiscountRules to fetch.
     */
    where?: DiscountRuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DiscountRules to fetch.
     */
    orderBy?: DiscountRuleOrderByWithRelationInput | DiscountRuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DiscountRules.
     */
    cursor?: DiscountRuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DiscountRules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DiscountRules.
     */
    skip?: number
    distinct?: DiscountRuleScalarFieldEnum | DiscountRuleScalarFieldEnum[]
  }

  /**
   * DiscountRule create
   */
  export type DiscountRuleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DiscountRule
     */
    select?: DiscountRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DiscountRule
     */
    omit?: DiscountRuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiscountRuleInclude<ExtArgs> | null
    /**
     * The data needed to create a DiscountRule.
     */
    data: XOR<DiscountRuleCreateInput, DiscountRuleUncheckedCreateInput>
  }

  /**
   * DiscountRule createMany
   */
  export type DiscountRuleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DiscountRules.
     */
    data: DiscountRuleCreateManyInput | DiscountRuleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DiscountRule createManyAndReturn
   */
  export type DiscountRuleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DiscountRule
     */
    select?: DiscountRuleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DiscountRule
     */
    omit?: DiscountRuleOmit<ExtArgs> | null
    /**
     * The data used to create many DiscountRules.
     */
    data: DiscountRuleCreateManyInput | DiscountRuleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DiscountRule update
   */
  export type DiscountRuleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DiscountRule
     */
    select?: DiscountRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DiscountRule
     */
    omit?: DiscountRuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiscountRuleInclude<ExtArgs> | null
    /**
     * The data needed to update a DiscountRule.
     */
    data: XOR<DiscountRuleUpdateInput, DiscountRuleUncheckedUpdateInput>
    /**
     * Choose, which DiscountRule to update.
     */
    where: DiscountRuleWhereUniqueInput
  }

  /**
   * DiscountRule updateMany
   */
  export type DiscountRuleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DiscountRules.
     */
    data: XOR<DiscountRuleUpdateManyMutationInput, DiscountRuleUncheckedUpdateManyInput>
    /**
     * Filter which DiscountRules to update
     */
    where?: DiscountRuleWhereInput
    /**
     * Limit how many DiscountRules to update.
     */
    limit?: number
  }

  /**
   * DiscountRule updateManyAndReturn
   */
  export type DiscountRuleUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DiscountRule
     */
    select?: DiscountRuleSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DiscountRule
     */
    omit?: DiscountRuleOmit<ExtArgs> | null
    /**
     * The data used to update DiscountRules.
     */
    data: XOR<DiscountRuleUpdateManyMutationInput, DiscountRuleUncheckedUpdateManyInput>
    /**
     * Filter which DiscountRules to update
     */
    where?: DiscountRuleWhereInput
    /**
     * Limit how many DiscountRules to update.
     */
    limit?: number
  }

  /**
   * DiscountRule upsert
   */
  export type DiscountRuleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DiscountRule
     */
    select?: DiscountRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DiscountRule
     */
    omit?: DiscountRuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiscountRuleInclude<ExtArgs> | null
    /**
     * The filter to search for the DiscountRule to update in case it exists.
     */
    where: DiscountRuleWhereUniqueInput
    /**
     * In case the DiscountRule found by the `where` argument doesn't exist, create a new DiscountRule with this data.
     */
    create: XOR<DiscountRuleCreateInput, DiscountRuleUncheckedCreateInput>
    /**
     * In case the DiscountRule was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DiscountRuleUpdateInput, DiscountRuleUncheckedUpdateInput>
  }

  /**
   * DiscountRule delete
   */
  export type DiscountRuleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DiscountRule
     */
    select?: DiscountRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DiscountRule
     */
    omit?: DiscountRuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiscountRuleInclude<ExtArgs> | null
    /**
     * Filter which DiscountRule to delete.
     */
    where: DiscountRuleWhereUniqueInput
  }

  /**
   * DiscountRule deleteMany
   */
  export type DiscountRuleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DiscountRules to delete
     */
    where?: DiscountRuleWhereInput
    /**
     * Limit how many DiscountRules to delete.
     */
    limit?: number
  }

  /**
   * DiscountRule.visitDiscounts
   */
  export type DiscountRule$visitDiscountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisitDiscount
     */
    select?: VisitDiscountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VisitDiscount
     */
    omit?: VisitDiscountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitDiscountInclude<ExtArgs> | null
    where?: VisitDiscountWhereInput
    orderBy?: VisitDiscountOrderByWithRelationInput | VisitDiscountOrderByWithRelationInput[]
    cursor?: VisitDiscountWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VisitDiscountScalarFieldEnum | VisitDiscountScalarFieldEnum[]
  }

  /**
   * DiscountRule.customerDiscounts
   */
  export type DiscountRule$customerDiscountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerDiscount
     */
    select?: CustomerDiscountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerDiscount
     */
    omit?: CustomerDiscountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerDiscountInclude<ExtArgs> | null
    where?: CustomerDiscountWhereInput
    orderBy?: CustomerDiscountOrderByWithRelationInput | CustomerDiscountOrderByWithRelationInput[]
    cursor?: CustomerDiscountWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CustomerDiscountScalarFieldEnum | CustomerDiscountScalarFieldEnum[]
  }

  /**
   * DiscountRule without action
   */
  export type DiscountRuleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DiscountRule
     */
    select?: DiscountRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DiscountRule
     */
    omit?: DiscountRuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiscountRuleInclude<ExtArgs> | null
  }


  /**
   * Model VisitDiscount
   */

  export type AggregateVisitDiscount = {
    _count: VisitDiscountCountAggregateOutputType | null
    _avg: VisitDiscountAvgAggregateOutputType | null
    _sum: VisitDiscountSumAggregateOutputType | null
    _min: VisitDiscountMinAggregateOutputType | null
    _max: VisitDiscountMaxAggregateOutputType | null
  }

  export type VisitDiscountAvgAggregateOutputType = {
    discountAmount: Decimal | null
  }

  export type VisitDiscountSumAggregateOutputType = {
    discountAmount: Decimal | null
  }

  export type VisitDiscountMinAggregateOutputType = {
    id: string | null
    visitId: string | null
    discountRuleId: string | null
    discountAmount: Decimal | null
    createdAt: Date | null
  }

  export type VisitDiscountMaxAggregateOutputType = {
    id: string | null
    visitId: string | null
    discountRuleId: string | null
    discountAmount: Decimal | null
    createdAt: Date | null
  }

  export type VisitDiscountCountAggregateOutputType = {
    id: number
    visitId: number
    discountRuleId: number
    discountAmount: number
    createdAt: number
    _all: number
  }


  export type VisitDiscountAvgAggregateInputType = {
    discountAmount?: true
  }

  export type VisitDiscountSumAggregateInputType = {
    discountAmount?: true
  }

  export type VisitDiscountMinAggregateInputType = {
    id?: true
    visitId?: true
    discountRuleId?: true
    discountAmount?: true
    createdAt?: true
  }

  export type VisitDiscountMaxAggregateInputType = {
    id?: true
    visitId?: true
    discountRuleId?: true
    discountAmount?: true
    createdAt?: true
  }

  export type VisitDiscountCountAggregateInputType = {
    id?: true
    visitId?: true
    discountRuleId?: true
    discountAmount?: true
    createdAt?: true
    _all?: true
  }

  export type VisitDiscountAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VisitDiscount to aggregate.
     */
    where?: VisitDiscountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VisitDiscounts to fetch.
     */
    orderBy?: VisitDiscountOrderByWithRelationInput | VisitDiscountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VisitDiscountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VisitDiscounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VisitDiscounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VisitDiscounts
    **/
    _count?: true | VisitDiscountCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VisitDiscountAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VisitDiscountSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VisitDiscountMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VisitDiscountMaxAggregateInputType
  }

  export type GetVisitDiscountAggregateType<T extends VisitDiscountAggregateArgs> = {
        [P in keyof T & keyof AggregateVisitDiscount]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVisitDiscount[P]>
      : GetScalarType<T[P], AggregateVisitDiscount[P]>
  }




  export type VisitDiscountGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VisitDiscountWhereInput
    orderBy?: VisitDiscountOrderByWithAggregationInput | VisitDiscountOrderByWithAggregationInput[]
    by: VisitDiscountScalarFieldEnum[] | VisitDiscountScalarFieldEnum
    having?: VisitDiscountScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VisitDiscountCountAggregateInputType | true
    _avg?: VisitDiscountAvgAggregateInputType
    _sum?: VisitDiscountSumAggregateInputType
    _min?: VisitDiscountMinAggregateInputType
    _max?: VisitDiscountMaxAggregateInputType
  }

  export type VisitDiscountGroupByOutputType = {
    id: string
    visitId: string
    discountRuleId: string
    discountAmount: Decimal
    createdAt: Date
    _count: VisitDiscountCountAggregateOutputType | null
    _avg: VisitDiscountAvgAggregateOutputType | null
    _sum: VisitDiscountSumAggregateOutputType | null
    _min: VisitDiscountMinAggregateOutputType | null
    _max: VisitDiscountMaxAggregateOutputType | null
  }

  type GetVisitDiscountGroupByPayload<T extends VisitDiscountGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VisitDiscountGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VisitDiscountGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VisitDiscountGroupByOutputType[P]>
            : GetScalarType<T[P], VisitDiscountGroupByOutputType[P]>
        }
      >
    >


  export type VisitDiscountSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    visitId?: boolean
    discountRuleId?: boolean
    discountAmount?: boolean
    createdAt?: boolean
    visit?: boolean | VisitDefaultArgs<ExtArgs>
    discountRule?: boolean | DiscountRuleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["visitDiscount"]>

  export type VisitDiscountSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    visitId?: boolean
    discountRuleId?: boolean
    discountAmount?: boolean
    createdAt?: boolean
    visit?: boolean | VisitDefaultArgs<ExtArgs>
    discountRule?: boolean | DiscountRuleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["visitDiscount"]>

  export type VisitDiscountSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    visitId?: boolean
    discountRuleId?: boolean
    discountAmount?: boolean
    createdAt?: boolean
    visit?: boolean | VisitDefaultArgs<ExtArgs>
    discountRule?: boolean | DiscountRuleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["visitDiscount"]>

  export type VisitDiscountSelectScalar = {
    id?: boolean
    visitId?: boolean
    discountRuleId?: boolean
    discountAmount?: boolean
    createdAt?: boolean
  }

  export type VisitDiscountOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "visitId" | "discountRuleId" | "discountAmount" | "createdAt", ExtArgs["result"]["visitDiscount"]>
  export type VisitDiscountInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    visit?: boolean | VisitDefaultArgs<ExtArgs>
    discountRule?: boolean | DiscountRuleDefaultArgs<ExtArgs>
  }
  export type VisitDiscountIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    visit?: boolean | VisitDefaultArgs<ExtArgs>
    discountRule?: boolean | DiscountRuleDefaultArgs<ExtArgs>
  }
  export type VisitDiscountIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    visit?: boolean | VisitDefaultArgs<ExtArgs>
    discountRule?: boolean | DiscountRuleDefaultArgs<ExtArgs>
  }

  export type $VisitDiscountPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VisitDiscount"
    objects: {
      visit: Prisma.$VisitPayload<ExtArgs>
      discountRule: Prisma.$DiscountRulePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      visitId: string
      discountRuleId: string
      discountAmount: Prisma.Decimal
      createdAt: Date
    }, ExtArgs["result"]["visitDiscount"]>
    composites: {}
  }

  type VisitDiscountGetPayload<S extends boolean | null | undefined | VisitDiscountDefaultArgs> = $Result.GetResult<Prisma.$VisitDiscountPayload, S>

  type VisitDiscountCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VisitDiscountFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VisitDiscountCountAggregateInputType | true
    }

  export interface VisitDiscountDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VisitDiscount'], meta: { name: 'VisitDiscount' } }
    /**
     * Find zero or one VisitDiscount that matches the filter.
     * @param {VisitDiscountFindUniqueArgs} args - Arguments to find a VisitDiscount
     * @example
     * // Get one VisitDiscount
     * const visitDiscount = await prisma.visitDiscount.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VisitDiscountFindUniqueArgs>(args: SelectSubset<T, VisitDiscountFindUniqueArgs<ExtArgs>>): Prisma__VisitDiscountClient<$Result.GetResult<Prisma.$VisitDiscountPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one VisitDiscount that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VisitDiscountFindUniqueOrThrowArgs} args - Arguments to find a VisitDiscount
     * @example
     * // Get one VisitDiscount
     * const visitDiscount = await prisma.visitDiscount.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VisitDiscountFindUniqueOrThrowArgs>(args: SelectSubset<T, VisitDiscountFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VisitDiscountClient<$Result.GetResult<Prisma.$VisitDiscountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VisitDiscount that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VisitDiscountFindFirstArgs} args - Arguments to find a VisitDiscount
     * @example
     * // Get one VisitDiscount
     * const visitDiscount = await prisma.visitDiscount.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VisitDiscountFindFirstArgs>(args?: SelectSubset<T, VisitDiscountFindFirstArgs<ExtArgs>>): Prisma__VisitDiscountClient<$Result.GetResult<Prisma.$VisitDiscountPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VisitDiscount that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VisitDiscountFindFirstOrThrowArgs} args - Arguments to find a VisitDiscount
     * @example
     * // Get one VisitDiscount
     * const visitDiscount = await prisma.visitDiscount.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VisitDiscountFindFirstOrThrowArgs>(args?: SelectSubset<T, VisitDiscountFindFirstOrThrowArgs<ExtArgs>>): Prisma__VisitDiscountClient<$Result.GetResult<Prisma.$VisitDiscountPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more VisitDiscounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VisitDiscountFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VisitDiscounts
     * const visitDiscounts = await prisma.visitDiscount.findMany()
     * 
     * // Get first 10 VisitDiscounts
     * const visitDiscounts = await prisma.visitDiscount.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const visitDiscountWithIdOnly = await prisma.visitDiscount.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VisitDiscountFindManyArgs>(args?: SelectSubset<T, VisitDiscountFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VisitDiscountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a VisitDiscount.
     * @param {VisitDiscountCreateArgs} args - Arguments to create a VisitDiscount.
     * @example
     * // Create one VisitDiscount
     * const VisitDiscount = await prisma.visitDiscount.create({
     *   data: {
     *     // ... data to create a VisitDiscount
     *   }
     * })
     * 
     */
    create<T extends VisitDiscountCreateArgs>(args: SelectSubset<T, VisitDiscountCreateArgs<ExtArgs>>): Prisma__VisitDiscountClient<$Result.GetResult<Prisma.$VisitDiscountPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many VisitDiscounts.
     * @param {VisitDiscountCreateManyArgs} args - Arguments to create many VisitDiscounts.
     * @example
     * // Create many VisitDiscounts
     * const visitDiscount = await prisma.visitDiscount.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VisitDiscountCreateManyArgs>(args?: SelectSubset<T, VisitDiscountCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many VisitDiscounts and returns the data saved in the database.
     * @param {VisitDiscountCreateManyAndReturnArgs} args - Arguments to create many VisitDiscounts.
     * @example
     * // Create many VisitDiscounts
     * const visitDiscount = await prisma.visitDiscount.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many VisitDiscounts and only return the `id`
     * const visitDiscountWithIdOnly = await prisma.visitDiscount.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VisitDiscountCreateManyAndReturnArgs>(args?: SelectSubset<T, VisitDiscountCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VisitDiscountPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a VisitDiscount.
     * @param {VisitDiscountDeleteArgs} args - Arguments to delete one VisitDiscount.
     * @example
     * // Delete one VisitDiscount
     * const VisitDiscount = await prisma.visitDiscount.delete({
     *   where: {
     *     // ... filter to delete one VisitDiscount
     *   }
     * })
     * 
     */
    delete<T extends VisitDiscountDeleteArgs>(args: SelectSubset<T, VisitDiscountDeleteArgs<ExtArgs>>): Prisma__VisitDiscountClient<$Result.GetResult<Prisma.$VisitDiscountPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one VisitDiscount.
     * @param {VisitDiscountUpdateArgs} args - Arguments to update one VisitDiscount.
     * @example
     * // Update one VisitDiscount
     * const visitDiscount = await prisma.visitDiscount.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VisitDiscountUpdateArgs>(args: SelectSubset<T, VisitDiscountUpdateArgs<ExtArgs>>): Prisma__VisitDiscountClient<$Result.GetResult<Prisma.$VisitDiscountPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more VisitDiscounts.
     * @param {VisitDiscountDeleteManyArgs} args - Arguments to filter VisitDiscounts to delete.
     * @example
     * // Delete a few VisitDiscounts
     * const { count } = await prisma.visitDiscount.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VisitDiscountDeleteManyArgs>(args?: SelectSubset<T, VisitDiscountDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VisitDiscounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VisitDiscountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VisitDiscounts
     * const visitDiscount = await prisma.visitDiscount.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VisitDiscountUpdateManyArgs>(args: SelectSubset<T, VisitDiscountUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VisitDiscounts and returns the data updated in the database.
     * @param {VisitDiscountUpdateManyAndReturnArgs} args - Arguments to update many VisitDiscounts.
     * @example
     * // Update many VisitDiscounts
     * const visitDiscount = await prisma.visitDiscount.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more VisitDiscounts and only return the `id`
     * const visitDiscountWithIdOnly = await prisma.visitDiscount.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VisitDiscountUpdateManyAndReturnArgs>(args: SelectSubset<T, VisitDiscountUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VisitDiscountPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one VisitDiscount.
     * @param {VisitDiscountUpsertArgs} args - Arguments to update or create a VisitDiscount.
     * @example
     * // Update or create a VisitDiscount
     * const visitDiscount = await prisma.visitDiscount.upsert({
     *   create: {
     *     // ... data to create a VisitDiscount
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VisitDiscount we want to update
     *   }
     * })
     */
    upsert<T extends VisitDiscountUpsertArgs>(args: SelectSubset<T, VisitDiscountUpsertArgs<ExtArgs>>): Prisma__VisitDiscountClient<$Result.GetResult<Prisma.$VisitDiscountPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of VisitDiscounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VisitDiscountCountArgs} args - Arguments to filter VisitDiscounts to count.
     * @example
     * // Count the number of VisitDiscounts
     * const count = await prisma.visitDiscount.count({
     *   where: {
     *     // ... the filter for the VisitDiscounts we want to count
     *   }
     * })
    **/
    count<T extends VisitDiscountCountArgs>(
      args?: Subset<T, VisitDiscountCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VisitDiscountCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VisitDiscount.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VisitDiscountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VisitDiscountAggregateArgs>(args: Subset<T, VisitDiscountAggregateArgs>): Prisma.PrismaPromise<GetVisitDiscountAggregateType<T>>

    /**
     * Group by VisitDiscount.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VisitDiscountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VisitDiscountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VisitDiscountGroupByArgs['orderBy'] }
        : { orderBy?: VisitDiscountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VisitDiscountGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVisitDiscountGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VisitDiscount model
   */
  readonly fields: VisitDiscountFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VisitDiscount.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VisitDiscountClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    visit<T extends VisitDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VisitDefaultArgs<ExtArgs>>): Prisma__VisitClient<$Result.GetResult<Prisma.$VisitPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    discountRule<T extends DiscountRuleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DiscountRuleDefaultArgs<ExtArgs>>): Prisma__DiscountRuleClient<$Result.GetResult<Prisma.$DiscountRulePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the VisitDiscount model
   */
  interface VisitDiscountFieldRefs {
    readonly id: FieldRef<"VisitDiscount", 'String'>
    readonly visitId: FieldRef<"VisitDiscount", 'String'>
    readonly discountRuleId: FieldRef<"VisitDiscount", 'String'>
    readonly discountAmount: FieldRef<"VisitDiscount", 'Decimal'>
    readonly createdAt: FieldRef<"VisitDiscount", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * VisitDiscount findUnique
   */
  export type VisitDiscountFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisitDiscount
     */
    select?: VisitDiscountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VisitDiscount
     */
    omit?: VisitDiscountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitDiscountInclude<ExtArgs> | null
    /**
     * Filter, which VisitDiscount to fetch.
     */
    where: VisitDiscountWhereUniqueInput
  }

  /**
   * VisitDiscount findUniqueOrThrow
   */
  export type VisitDiscountFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisitDiscount
     */
    select?: VisitDiscountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VisitDiscount
     */
    omit?: VisitDiscountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitDiscountInclude<ExtArgs> | null
    /**
     * Filter, which VisitDiscount to fetch.
     */
    where: VisitDiscountWhereUniqueInput
  }

  /**
   * VisitDiscount findFirst
   */
  export type VisitDiscountFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisitDiscount
     */
    select?: VisitDiscountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VisitDiscount
     */
    omit?: VisitDiscountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitDiscountInclude<ExtArgs> | null
    /**
     * Filter, which VisitDiscount to fetch.
     */
    where?: VisitDiscountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VisitDiscounts to fetch.
     */
    orderBy?: VisitDiscountOrderByWithRelationInput | VisitDiscountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VisitDiscounts.
     */
    cursor?: VisitDiscountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VisitDiscounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VisitDiscounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VisitDiscounts.
     */
    distinct?: VisitDiscountScalarFieldEnum | VisitDiscountScalarFieldEnum[]
  }

  /**
   * VisitDiscount findFirstOrThrow
   */
  export type VisitDiscountFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisitDiscount
     */
    select?: VisitDiscountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VisitDiscount
     */
    omit?: VisitDiscountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitDiscountInclude<ExtArgs> | null
    /**
     * Filter, which VisitDiscount to fetch.
     */
    where?: VisitDiscountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VisitDiscounts to fetch.
     */
    orderBy?: VisitDiscountOrderByWithRelationInput | VisitDiscountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VisitDiscounts.
     */
    cursor?: VisitDiscountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VisitDiscounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VisitDiscounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VisitDiscounts.
     */
    distinct?: VisitDiscountScalarFieldEnum | VisitDiscountScalarFieldEnum[]
  }

  /**
   * VisitDiscount findMany
   */
  export type VisitDiscountFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisitDiscount
     */
    select?: VisitDiscountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VisitDiscount
     */
    omit?: VisitDiscountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitDiscountInclude<ExtArgs> | null
    /**
     * Filter, which VisitDiscounts to fetch.
     */
    where?: VisitDiscountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VisitDiscounts to fetch.
     */
    orderBy?: VisitDiscountOrderByWithRelationInput | VisitDiscountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VisitDiscounts.
     */
    cursor?: VisitDiscountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VisitDiscounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VisitDiscounts.
     */
    skip?: number
    distinct?: VisitDiscountScalarFieldEnum | VisitDiscountScalarFieldEnum[]
  }

  /**
   * VisitDiscount create
   */
  export type VisitDiscountCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisitDiscount
     */
    select?: VisitDiscountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VisitDiscount
     */
    omit?: VisitDiscountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitDiscountInclude<ExtArgs> | null
    /**
     * The data needed to create a VisitDiscount.
     */
    data: XOR<VisitDiscountCreateInput, VisitDiscountUncheckedCreateInput>
  }

  /**
   * VisitDiscount createMany
   */
  export type VisitDiscountCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VisitDiscounts.
     */
    data: VisitDiscountCreateManyInput | VisitDiscountCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VisitDiscount createManyAndReturn
   */
  export type VisitDiscountCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisitDiscount
     */
    select?: VisitDiscountSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VisitDiscount
     */
    omit?: VisitDiscountOmit<ExtArgs> | null
    /**
     * The data used to create many VisitDiscounts.
     */
    data: VisitDiscountCreateManyInput | VisitDiscountCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitDiscountIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * VisitDiscount update
   */
  export type VisitDiscountUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisitDiscount
     */
    select?: VisitDiscountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VisitDiscount
     */
    omit?: VisitDiscountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitDiscountInclude<ExtArgs> | null
    /**
     * The data needed to update a VisitDiscount.
     */
    data: XOR<VisitDiscountUpdateInput, VisitDiscountUncheckedUpdateInput>
    /**
     * Choose, which VisitDiscount to update.
     */
    where: VisitDiscountWhereUniqueInput
  }

  /**
   * VisitDiscount updateMany
   */
  export type VisitDiscountUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VisitDiscounts.
     */
    data: XOR<VisitDiscountUpdateManyMutationInput, VisitDiscountUncheckedUpdateManyInput>
    /**
     * Filter which VisitDiscounts to update
     */
    where?: VisitDiscountWhereInput
    /**
     * Limit how many VisitDiscounts to update.
     */
    limit?: number
  }

  /**
   * VisitDiscount updateManyAndReturn
   */
  export type VisitDiscountUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisitDiscount
     */
    select?: VisitDiscountSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VisitDiscount
     */
    omit?: VisitDiscountOmit<ExtArgs> | null
    /**
     * The data used to update VisitDiscounts.
     */
    data: XOR<VisitDiscountUpdateManyMutationInput, VisitDiscountUncheckedUpdateManyInput>
    /**
     * Filter which VisitDiscounts to update
     */
    where?: VisitDiscountWhereInput
    /**
     * Limit how many VisitDiscounts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitDiscountIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * VisitDiscount upsert
   */
  export type VisitDiscountUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisitDiscount
     */
    select?: VisitDiscountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VisitDiscount
     */
    omit?: VisitDiscountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitDiscountInclude<ExtArgs> | null
    /**
     * The filter to search for the VisitDiscount to update in case it exists.
     */
    where: VisitDiscountWhereUniqueInput
    /**
     * In case the VisitDiscount found by the `where` argument doesn't exist, create a new VisitDiscount with this data.
     */
    create: XOR<VisitDiscountCreateInput, VisitDiscountUncheckedCreateInput>
    /**
     * In case the VisitDiscount was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VisitDiscountUpdateInput, VisitDiscountUncheckedUpdateInput>
  }

  /**
   * VisitDiscount delete
   */
  export type VisitDiscountDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisitDiscount
     */
    select?: VisitDiscountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VisitDiscount
     */
    omit?: VisitDiscountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitDiscountInclude<ExtArgs> | null
    /**
     * Filter which VisitDiscount to delete.
     */
    where: VisitDiscountWhereUniqueInput
  }

  /**
   * VisitDiscount deleteMany
   */
  export type VisitDiscountDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VisitDiscounts to delete
     */
    where?: VisitDiscountWhereInput
    /**
     * Limit how many VisitDiscounts to delete.
     */
    limit?: number
  }

  /**
   * VisitDiscount without action
   */
  export type VisitDiscountDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisitDiscount
     */
    select?: VisitDiscountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VisitDiscount
     */
    omit?: VisitDiscountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitDiscountInclude<ExtArgs> | null
  }


  /**
   * Model CustomerDiscount
   */

  export type AggregateCustomerDiscount = {
    _count: CustomerDiscountCountAggregateOutputType | null
    _avg: CustomerDiscountAvgAggregateOutputType | null
    _sum: CustomerDiscountSumAggregateOutputType | null
    _min: CustomerDiscountMinAggregateOutputType | null
    _max: CustomerDiscountMaxAggregateOutputType | null
  }

  export type CustomerDiscountAvgAggregateOutputType = {
    discountAmount: Decimal | null
  }

  export type CustomerDiscountSumAggregateOutputType = {
    discountAmount: Decimal | null
  }

  export type CustomerDiscountMinAggregateOutputType = {
    id: string | null
    customerId: string | null
    discountRuleId: string | null
    usedAt: Date | null
    discountAmount: Decimal | null
  }

  export type CustomerDiscountMaxAggregateOutputType = {
    id: string | null
    customerId: string | null
    discountRuleId: string | null
    usedAt: Date | null
    discountAmount: Decimal | null
  }

  export type CustomerDiscountCountAggregateOutputType = {
    id: number
    customerId: number
    discountRuleId: number
    usedAt: number
    discountAmount: number
    _all: number
  }


  export type CustomerDiscountAvgAggregateInputType = {
    discountAmount?: true
  }

  export type CustomerDiscountSumAggregateInputType = {
    discountAmount?: true
  }

  export type CustomerDiscountMinAggregateInputType = {
    id?: true
    customerId?: true
    discountRuleId?: true
    usedAt?: true
    discountAmount?: true
  }

  export type CustomerDiscountMaxAggregateInputType = {
    id?: true
    customerId?: true
    discountRuleId?: true
    usedAt?: true
    discountAmount?: true
  }

  export type CustomerDiscountCountAggregateInputType = {
    id?: true
    customerId?: true
    discountRuleId?: true
    usedAt?: true
    discountAmount?: true
    _all?: true
  }

  export type CustomerDiscountAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CustomerDiscount to aggregate.
     */
    where?: CustomerDiscountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerDiscounts to fetch.
     */
    orderBy?: CustomerDiscountOrderByWithRelationInput | CustomerDiscountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CustomerDiscountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerDiscounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerDiscounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CustomerDiscounts
    **/
    _count?: true | CustomerDiscountCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CustomerDiscountAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CustomerDiscountSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CustomerDiscountMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CustomerDiscountMaxAggregateInputType
  }

  export type GetCustomerDiscountAggregateType<T extends CustomerDiscountAggregateArgs> = {
        [P in keyof T & keyof AggregateCustomerDiscount]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCustomerDiscount[P]>
      : GetScalarType<T[P], AggregateCustomerDiscount[P]>
  }




  export type CustomerDiscountGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomerDiscountWhereInput
    orderBy?: CustomerDiscountOrderByWithAggregationInput | CustomerDiscountOrderByWithAggregationInput[]
    by: CustomerDiscountScalarFieldEnum[] | CustomerDiscountScalarFieldEnum
    having?: CustomerDiscountScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CustomerDiscountCountAggregateInputType | true
    _avg?: CustomerDiscountAvgAggregateInputType
    _sum?: CustomerDiscountSumAggregateInputType
    _min?: CustomerDiscountMinAggregateInputType
    _max?: CustomerDiscountMaxAggregateInputType
  }

  export type CustomerDiscountGroupByOutputType = {
    id: string
    customerId: string
    discountRuleId: string
    usedAt: Date
    discountAmount: Decimal
    _count: CustomerDiscountCountAggregateOutputType | null
    _avg: CustomerDiscountAvgAggregateOutputType | null
    _sum: CustomerDiscountSumAggregateOutputType | null
    _min: CustomerDiscountMinAggregateOutputType | null
    _max: CustomerDiscountMaxAggregateOutputType | null
  }

  type GetCustomerDiscountGroupByPayload<T extends CustomerDiscountGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CustomerDiscountGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CustomerDiscountGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CustomerDiscountGroupByOutputType[P]>
            : GetScalarType<T[P], CustomerDiscountGroupByOutputType[P]>
        }
      >
    >


  export type CustomerDiscountSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    customerId?: boolean
    discountRuleId?: boolean
    usedAt?: boolean
    discountAmount?: boolean
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    discountRule?: boolean | DiscountRuleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customerDiscount"]>

  export type CustomerDiscountSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    customerId?: boolean
    discountRuleId?: boolean
    usedAt?: boolean
    discountAmount?: boolean
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    discountRule?: boolean | DiscountRuleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customerDiscount"]>

  export type CustomerDiscountSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    customerId?: boolean
    discountRuleId?: boolean
    usedAt?: boolean
    discountAmount?: boolean
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    discountRule?: boolean | DiscountRuleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customerDiscount"]>

  export type CustomerDiscountSelectScalar = {
    id?: boolean
    customerId?: boolean
    discountRuleId?: boolean
    usedAt?: boolean
    discountAmount?: boolean
  }

  export type CustomerDiscountOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "customerId" | "discountRuleId" | "usedAt" | "discountAmount", ExtArgs["result"]["customerDiscount"]>
  export type CustomerDiscountInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    discountRule?: boolean | DiscountRuleDefaultArgs<ExtArgs>
  }
  export type CustomerDiscountIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    discountRule?: boolean | DiscountRuleDefaultArgs<ExtArgs>
  }
  export type CustomerDiscountIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    discountRule?: boolean | DiscountRuleDefaultArgs<ExtArgs>
  }

  export type $CustomerDiscountPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CustomerDiscount"
    objects: {
      customer: Prisma.$CustomerPayload<ExtArgs>
      discountRule: Prisma.$DiscountRulePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      customerId: string
      discountRuleId: string
      usedAt: Date
      discountAmount: Prisma.Decimal
    }, ExtArgs["result"]["customerDiscount"]>
    composites: {}
  }

  type CustomerDiscountGetPayload<S extends boolean | null | undefined | CustomerDiscountDefaultArgs> = $Result.GetResult<Prisma.$CustomerDiscountPayload, S>

  type CustomerDiscountCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CustomerDiscountFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CustomerDiscountCountAggregateInputType | true
    }

  export interface CustomerDiscountDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CustomerDiscount'], meta: { name: 'CustomerDiscount' } }
    /**
     * Find zero or one CustomerDiscount that matches the filter.
     * @param {CustomerDiscountFindUniqueArgs} args - Arguments to find a CustomerDiscount
     * @example
     * // Get one CustomerDiscount
     * const customerDiscount = await prisma.customerDiscount.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CustomerDiscountFindUniqueArgs>(args: SelectSubset<T, CustomerDiscountFindUniqueArgs<ExtArgs>>): Prisma__CustomerDiscountClient<$Result.GetResult<Prisma.$CustomerDiscountPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CustomerDiscount that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CustomerDiscountFindUniqueOrThrowArgs} args - Arguments to find a CustomerDiscount
     * @example
     * // Get one CustomerDiscount
     * const customerDiscount = await prisma.customerDiscount.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CustomerDiscountFindUniqueOrThrowArgs>(args: SelectSubset<T, CustomerDiscountFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CustomerDiscountClient<$Result.GetResult<Prisma.$CustomerDiscountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CustomerDiscount that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerDiscountFindFirstArgs} args - Arguments to find a CustomerDiscount
     * @example
     * // Get one CustomerDiscount
     * const customerDiscount = await prisma.customerDiscount.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CustomerDiscountFindFirstArgs>(args?: SelectSubset<T, CustomerDiscountFindFirstArgs<ExtArgs>>): Prisma__CustomerDiscountClient<$Result.GetResult<Prisma.$CustomerDiscountPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CustomerDiscount that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerDiscountFindFirstOrThrowArgs} args - Arguments to find a CustomerDiscount
     * @example
     * // Get one CustomerDiscount
     * const customerDiscount = await prisma.customerDiscount.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CustomerDiscountFindFirstOrThrowArgs>(args?: SelectSubset<T, CustomerDiscountFindFirstOrThrowArgs<ExtArgs>>): Prisma__CustomerDiscountClient<$Result.GetResult<Prisma.$CustomerDiscountPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CustomerDiscounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerDiscountFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CustomerDiscounts
     * const customerDiscounts = await prisma.customerDiscount.findMany()
     * 
     * // Get first 10 CustomerDiscounts
     * const customerDiscounts = await prisma.customerDiscount.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const customerDiscountWithIdOnly = await prisma.customerDiscount.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CustomerDiscountFindManyArgs>(args?: SelectSubset<T, CustomerDiscountFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerDiscountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CustomerDiscount.
     * @param {CustomerDiscountCreateArgs} args - Arguments to create a CustomerDiscount.
     * @example
     * // Create one CustomerDiscount
     * const CustomerDiscount = await prisma.customerDiscount.create({
     *   data: {
     *     // ... data to create a CustomerDiscount
     *   }
     * })
     * 
     */
    create<T extends CustomerDiscountCreateArgs>(args: SelectSubset<T, CustomerDiscountCreateArgs<ExtArgs>>): Prisma__CustomerDiscountClient<$Result.GetResult<Prisma.$CustomerDiscountPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CustomerDiscounts.
     * @param {CustomerDiscountCreateManyArgs} args - Arguments to create many CustomerDiscounts.
     * @example
     * // Create many CustomerDiscounts
     * const customerDiscount = await prisma.customerDiscount.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CustomerDiscountCreateManyArgs>(args?: SelectSubset<T, CustomerDiscountCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CustomerDiscounts and returns the data saved in the database.
     * @param {CustomerDiscountCreateManyAndReturnArgs} args - Arguments to create many CustomerDiscounts.
     * @example
     * // Create many CustomerDiscounts
     * const customerDiscount = await prisma.customerDiscount.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CustomerDiscounts and only return the `id`
     * const customerDiscountWithIdOnly = await prisma.customerDiscount.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CustomerDiscountCreateManyAndReturnArgs>(args?: SelectSubset<T, CustomerDiscountCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerDiscountPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CustomerDiscount.
     * @param {CustomerDiscountDeleteArgs} args - Arguments to delete one CustomerDiscount.
     * @example
     * // Delete one CustomerDiscount
     * const CustomerDiscount = await prisma.customerDiscount.delete({
     *   where: {
     *     // ... filter to delete one CustomerDiscount
     *   }
     * })
     * 
     */
    delete<T extends CustomerDiscountDeleteArgs>(args: SelectSubset<T, CustomerDiscountDeleteArgs<ExtArgs>>): Prisma__CustomerDiscountClient<$Result.GetResult<Prisma.$CustomerDiscountPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CustomerDiscount.
     * @param {CustomerDiscountUpdateArgs} args - Arguments to update one CustomerDiscount.
     * @example
     * // Update one CustomerDiscount
     * const customerDiscount = await prisma.customerDiscount.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CustomerDiscountUpdateArgs>(args: SelectSubset<T, CustomerDiscountUpdateArgs<ExtArgs>>): Prisma__CustomerDiscountClient<$Result.GetResult<Prisma.$CustomerDiscountPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CustomerDiscounts.
     * @param {CustomerDiscountDeleteManyArgs} args - Arguments to filter CustomerDiscounts to delete.
     * @example
     * // Delete a few CustomerDiscounts
     * const { count } = await prisma.customerDiscount.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CustomerDiscountDeleteManyArgs>(args?: SelectSubset<T, CustomerDiscountDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CustomerDiscounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerDiscountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CustomerDiscounts
     * const customerDiscount = await prisma.customerDiscount.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CustomerDiscountUpdateManyArgs>(args: SelectSubset<T, CustomerDiscountUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CustomerDiscounts and returns the data updated in the database.
     * @param {CustomerDiscountUpdateManyAndReturnArgs} args - Arguments to update many CustomerDiscounts.
     * @example
     * // Update many CustomerDiscounts
     * const customerDiscount = await prisma.customerDiscount.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CustomerDiscounts and only return the `id`
     * const customerDiscountWithIdOnly = await prisma.customerDiscount.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CustomerDiscountUpdateManyAndReturnArgs>(args: SelectSubset<T, CustomerDiscountUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerDiscountPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CustomerDiscount.
     * @param {CustomerDiscountUpsertArgs} args - Arguments to update or create a CustomerDiscount.
     * @example
     * // Update or create a CustomerDiscount
     * const customerDiscount = await prisma.customerDiscount.upsert({
     *   create: {
     *     // ... data to create a CustomerDiscount
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CustomerDiscount we want to update
     *   }
     * })
     */
    upsert<T extends CustomerDiscountUpsertArgs>(args: SelectSubset<T, CustomerDiscountUpsertArgs<ExtArgs>>): Prisma__CustomerDiscountClient<$Result.GetResult<Prisma.$CustomerDiscountPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CustomerDiscounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerDiscountCountArgs} args - Arguments to filter CustomerDiscounts to count.
     * @example
     * // Count the number of CustomerDiscounts
     * const count = await prisma.customerDiscount.count({
     *   where: {
     *     // ... the filter for the CustomerDiscounts we want to count
     *   }
     * })
    **/
    count<T extends CustomerDiscountCountArgs>(
      args?: Subset<T, CustomerDiscountCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CustomerDiscountCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CustomerDiscount.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerDiscountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CustomerDiscountAggregateArgs>(args: Subset<T, CustomerDiscountAggregateArgs>): Prisma.PrismaPromise<GetCustomerDiscountAggregateType<T>>

    /**
     * Group by CustomerDiscount.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerDiscountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CustomerDiscountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CustomerDiscountGroupByArgs['orderBy'] }
        : { orderBy?: CustomerDiscountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CustomerDiscountGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCustomerDiscountGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CustomerDiscount model
   */
  readonly fields: CustomerDiscountFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CustomerDiscount.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CustomerDiscountClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    customer<T extends CustomerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CustomerDefaultArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    discountRule<T extends DiscountRuleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DiscountRuleDefaultArgs<ExtArgs>>): Prisma__DiscountRuleClient<$Result.GetResult<Prisma.$DiscountRulePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CustomerDiscount model
   */
  interface CustomerDiscountFieldRefs {
    readonly id: FieldRef<"CustomerDiscount", 'String'>
    readonly customerId: FieldRef<"CustomerDiscount", 'String'>
    readonly discountRuleId: FieldRef<"CustomerDiscount", 'String'>
    readonly usedAt: FieldRef<"CustomerDiscount", 'DateTime'>
    readonly discountAmount: FieldRef<"CustomerDiscount", 'Decimal'>
  }
    

  // Custom InputTypes
  /**
   * CustomerDiscount findUnique
   */
  export type CustomerDiscountFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerDiscount
     */
    select?: CustomerDiscountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerDiscount
     */
    omit?: CustomerDiscountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerDiscountInclude<ExtArgs> | null
    /**
     * Filter, which CustomerDiscount to fetch.
     */
    where: CustomerDiscountWhereUniqueInput
  }

  /**
   * CustomerDiscount findUniqueOrThrow
   */
  export type CustomerDiscountFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerDiscount
     */
    select?: CustomerDiscountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerDiscount
     */
    omit?: CustomerDiscountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerDiscountInclude<ExtArgs> | null
    /**
     * Filter, which CustomerDiscount to fetch.
     */
    where: CustomerDiscountWhereUniqueInput
  }

  /**
   * CustomerDiscount findFirst
   */
  export type CustomerDiscountFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerDiscount
     */
    select?: CustomerDiscountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerDiscount
     */
    omit?: CustomerDiscountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerDiscountInclude<ExtArgs> | null
    /**
     * Filter, which CustomerDiscount to fetch.
     */
    where?: CustomerDiscountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerDiscounts to fetch.
     */
    orderBy?: CustomerDiscountOrderByWithRelationInput | CustomerDiscountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CustomerDiscounts.
     */
    cursor?: CustomerDiscountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerDiscounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerDiscounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CustomerDiscounts.
     */
    distinct?: CustomerDiscountScalarFieldEnum | CustomerDiscountScalarFieldEnum[]
  }

  /**
   * CustomerDiscount findFirstOrThrow
   */
  export type CustomerDiscountFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerDiscount
     */
    select?: CustomerDiscountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerDiscount
     */
    omit?: CustomerDiscountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerDiscountInclude<ExtArgs> | null
    /**
     * Filter, which CustomerDiscount to fetch.
     */
    where?: CustomerDiscountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerDiscounts to fetch.
     */
    orderBy?: CustomerDiscountOrderByWithRelationInput | CustomerDiscountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CustomerDiscounts.
     */
    cursor?: CustomerDiscountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerDiscounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerDiscounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CustomerDiscounts.
     */
    distinct?: CustomerDiscountScalarFieldEnum | CustomerDiscountScalarFieldEnum[]
  }

  /**
   * CustomerDiscount findMany
   */
  export type CustomerDiscountFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerDiscount
     */
    select?: CustomerDiscountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerDiscount
     */
    omit?: CustomerDiscountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerDiscountInclude<ExtArgs> | null
    /**
     * Filter, which CustomerDiscounts to fetch.
     */
    where?: CustomerDiscountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerDiscounts to fetch.
     */
    orderBy?: CustomerDiscountOrderByWithRelationInput | CustomerDiscountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CustomerDiscounts.
     */
    cursor?: CustomerDiscountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerDiscounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerDiscounts.
     */
    skip?: number
    distinct?: CustomerDiscountScalarFieldEnum | CustomerDiscountScalarFieldEnum[]
  }

  /**
   * CustomerDiscount create
   */
  export type CustomerDiscountCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerDiscount
     */
    select?: CustomerDiscountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerDiscount
     */
    omit?: CustomerDiscountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerDiscountInclude<ExtArgs> | null
    /**
     * The data needed to create a CustomerDiscount.
     */
    data: XOR<CustomerDiscountCreateInput, CustomerDiscountUncheckedCreateInput>
  }

  /**
   * CustomerDiscount createMany
   */
  export type CustomerDiscountCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CustomerDiscounts.
     */
    data: CustomerDiscountCreateManyInput | CustomerDiscountCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CustomerDiscount createManyAndReturn
   */
  export type CustomerDiscountCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerDiscount
     */
    select?: CustomerDiscountSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerDiscount
     */
    omit?: CustomerDiscountOmit<ExtArgs> | null
    /**
     * The data used to create many CustomerDiscounts.
     */
    data: CustomerDiscountCreateManyInput | CustomerDiscountCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerDiscountIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CustomerDiscount update
   */
  export type CustomerDiscountUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerDiscount
     */
    select?: CustomerDiscountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerDiscount
     */
    omit?: CustomerDiscountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerDiscountInclude<ExtArgs> | null
    /**
     * The data needed to update a CustomerDiscount.
     */
    data: XOR<CustomerDiscountUpdateInput, CustomerDiscountUncheckedUpdateInput>
    /**
     * Choose, which CustomerDiscount to update.
     */
    where: CustomerDiscountWhereUniqueInput
  }

  /**
   * CustomerDiscount updateMany
   */
  export type CustomerDiscountUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CustomerDiscounts.
     */
    data: XOR<CustomerDiscountUpdateManyMutationInput, CustomerDiscountUncheckedUpdateManyInput>
    /**
     * Filter which CustomerDiscounts to update
     */
    where?: CustomerDiscountWhereInput
    /**
     * Limit how many CustomerDiscounts to update.
     */
    limit?: number
  }

  /**
   * CustomerDiscount updateManyAndReturn
   */
  export type CustomerDiscountUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerDiscount
     */
    select?: CustomerDiscountSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerDiscount
     */
    omit?: CustomerDiscountOmit<ExtArgs> | null
    /**
     * The data used to update CustomerDiscounts.
     */
    data: XOR<CustomerDiscountUpdateManyMutationInput, CustomerDiscountUncheckedUpdateManyInput>
    /**
     * Filter which CustomerDiscounts to update
     */
    where?: CustomerDiscountWhereInput
    /**
     * Limit how many CustomerDiscounts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerDiscountIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CustomerDiscount upsert
   */
  export type CustomerDiscountUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerDiscount
     */
    select?: CustomerDiscountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerDiscount
     */
    omit?: CustomerDiscountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerDiscountInclude<ExtArgs> | null
    /**
     * The filter to search for the CustomerDiscount to update in case it exists.
     */
    where: CustomerDiscountWhereUniqueInput
    /**
     * In case the CustomerDiscount found by the `where` argument doesn't exist, create a new CustomerDiscount with this data.
     */
    create: XOR<CustomerDiscountCreateInput, CustomerDiscountUncheckedCreateInput>
    /**
     * In case the CustomerDiscount was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CustomerDiscountUpdateInput, CustomerDiscountUncheckedUpdateInput>
  }

  /**
   * CustomerDiscount delete
   */
  export type CustomerDiscountDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerDiscount
     */
    select?: CustomerDiscountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerDiscount
     */
    omit?: CustomerDiscountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerDiscountInclude<ExtArgs> | null
    /**
     * Filter which CustomerDiscount to delete.
     */
    where: CustomerDiscountWhereUniqueInput
  }

  /**
   * CustomerDiscount deleteMany
   */
  export type CustomerDiscountDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CustomerDiscounts to delete
     */
    where?: CustomerDiscountWhereInput
    /**
     * Limit how many CustomerDiscounts to delete.
     */
    limit?: number
  }

  /**
   * CustomerDiscount without action
   */
  export type CustomerDiscountDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerDiscount
     */
    select?: CustomerDiscountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerDiscount
     */
    omit?: CustomerDiscountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerDiscountInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    password: 'password',
    role: 'role',
    phone: 'phone',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const CustomerScalarFieldEnum: {
    id: 'id',
    fullName: 'fullName',
    gender: 'gender',
    location: 'location',
    district: 'district',
    province: 'province',
    phone: 'phone',
    email: 'email',
    birthDay: 'birthDay',
    birthMonth: 'birthMonth',
    birthYear: 'birthYear',
    visitCount: 'visitCount',
    loyaltyPoints: 'loyaltyPoints',
    totalSpent: 'totalSpent',
    lastVisit: 'lastVisit',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CustomerScalarFieldEnum = (typeof CustomerScalarFieldEnum)[keyof typeof CustomerScalarFieldEnum]


  export const ServiceScalarFieldEnum: {
    id: 'id',
    name: 'name',
    category: 'category',
    description: 'description',
    singlePrice: 'singlePrice',
    combinedPrice: 'combinedPrice',
    childPrice: 'childPrice',
    childCombinedPrice: 'childCombinedPrice',
    duration: 'duration',
    isActive: 'isActive',
    isComboEligible: 'isComboEligible',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ServiceScalarFieldEnum = (typeof ServiceScalarFieldEnum)[keyof typeof ServiceScalarFieldEnum]


  export const VisitScalarFieldEnum: {
    id: 'id',
    customerId: 'customerId',
    visitDate: 'visitDate',
    totalAmount: 'totalAmount',
    discountAmount: 'discountAmount',
    finalAmount: 'finalAmount',
    loyaltyPointsEarned: 'loyaltyPointsEarned',
    notes: 'notes',
    isCompleted: 'isCompleted',
    createdById: 'createdById',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type VisitScalarFieldEnum = (typeof VisitScalarFieldEnum)[keyof typeof VisitScalarFieldEnum]


  export const VisitServiceScalarFieldEnum: {
    id: 'id',
    visitId: 'visitId',
    serviceId: 'serviceId',
    quantity: 'quantity',
    unitPrice: 'unitPrice',
    totalPrice: 'totalPrice',
    isChild: 'isChild',
    isCombined: 'isCombined',
    createdAt: 'createdAt'
  };

  export type VisitServiceScalarFieldEnum = (typeof VisitServiceScalarFieldEnum)[keyof typeof VisitServiceScalarFieldEnum]


  export const VisitStaffScalarFieldEnum: {
    id: 'id',
    visitId: 'visitId',
    staffId: 'staffId',
    serviceId: 'serviceId',
    createdAt: 'createdAt'
  };

  export type VisitStaffScalarFieldEnum = (typeof VisitStaffScalarFieldEnum)[keyof typeof VisitStaffScalarFieldEnum]


  export const DiscountRuleScalarFieldEnum: {
    id: 'id',
    name: 'name',
    type: 'type',
    value: 'value',
    isPercentage: 'isPercentage',
    isActive: 'isActive',
    description: 'description',
    minAmount: 'minAmount',
    maxDiscount: 'maxDiscount',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DiscountRuleScalarFieldEnum = (typeof DiscountRuleScalarFieldEnum)[keyof typeof DiscountRuleScalarFieldEnum]


  export const VisitDiscountScalarFieldEnum: {
    id: 'id',
    visitId: 'visitId',
    discountRuleId: 'discountRuleId',
    discountAmount: 'discountAmount',
    createdAt: 'createdAt'
  };

  export type VisitDiscountScalarFieldEnum = (typeof VisitDiscountScalarFieldEnum)[keyof typeof VisitDiscountScalarFieldEnum]


  export const CustomerDiscountScalarFieldEnum: {
    id: 'id',
    customerId: 'customerId',
    discountRuleId: 'discountRuleId',
    usedAt: 'usedAt',
    discountAmount: 'discountAmount'
  };

  export type CustomerDiscountScalarFieldEnum = (typeof CustomerDiscountScalarFieldEnum)[keyof typeof CustomerDiscountScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Role'
   */
  export type EnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role'>
    


  /**
   * Reference to a field of type 'Role[]'
   */
  export type ListEnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Gender'
   */
  export type EnumGenderFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Gender'>
    


  /**
   * Reference to a field of type 'Gender[]'
   */
  export type ListEnumGenderFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Gender[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    


  /**
   * Reference to a field of type 'ServiceCategory'
   */
  export type EnumServiceCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ServiceCategory'>
    


  /**
   * Reference to a field of type 'ServiceCategory[]'
   */
  export type ListEnumServiceCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ServiceCategory[]'>
    


  /**
   * Reference to a field of type 'DiscountType'
   */
  export type EnumDiscountTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DiscountType'>
    


  /**
   * Reference to a field of type 'DiscountType[]'
   */
  export type ListEnumDiscountTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DiscountType[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    name?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    role?: EnumRoleFilter<"User"> | $Enums.Role
    phone?: StringNullableFilter<"User"> | string | null
    isActive?: BoolFilter<"User"> | boolean
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    visits?: VisitListRelationFilter
    staffVisits?: VisitStaffListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
    phone?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    visits?: VisitOrderByRelationAggregateInput
    staffVisits?: VisitStaffOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    name?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    role?: EnumRoleFilter<"User"> | $Enums.Role
    phone?: StringNullableFilter<"User"> | string | null
    isActive?: BoolFilter<"User"> | boolean
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    visits?: VisitListRelationFilter
    staffVisits?: VisitStaffListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
    phone?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    name?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    password?: StringWithAggregatesFilter<"User"> | string
    role?: EnumRoleWithAggregatesFilter<"User"> | $Enums.Role
    phone?: StringNullableWithAggregatesFilter<"User"> | string | null
    isActive?: BoolWithAggregatesFilter<"User"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type CustomerWhereInput = {
    AND?: CustomerWhereInput | CustomerWhereInput[]
    OR?: CustomerWhereInput[]
    NOT?: CustomerWhereInput | CustomerWhereInput[]
    id?: StringFilter<"Customer"> | string
    fullName?: StringFilter<"Customer"> | string
    gender?: EnumGenderFilter<"Customer"> | $Enums.Gender
    location?: StringFilter<"Customer"> | string
    district?: StringFilter<"Customer"> | string
    province?: StringFilter<"Customer"> | string
    phone?: StringFilter<"Customer"> | string
    email?: StringNullableFilter<"Customer"> | string | null
    birthDay?: IntFilter<"Customer"> | number
    birthMonth?: IntFilter<"Customer"> | number
    birthYear?: IntNullableFilter<"Customer"> | number | null
    visitCount?: IntFilter<"Customer"> | number
    loyaltyPoints?: IntFilter<"Customer"> | number
    totalSpent?: DecimalFilter<"Customer"> | Decimal | DecimalJsLike | number | string
    lastVisit?: DateTimeNullableFilter<"Customer"> | Date | string | null
    isActive?: BoolFilter<"Customer"> | boolean
    createdAt?: DateTimeFilter<"Customer"> | Date | string
    updatedAt?: DateTimeFilter<"Customer"> | Date | string
    visits?: VisitListRelationFilter
    discounts?: CustomerDiscountListRelationFilter
  }

  export type CustomerOrderByWithRelationInput = {
    id?: SortOrder
    fullName?: SortOrder
    gender?: SortOrder
    location?: SortOrder
    district?: SortOrder
    province?: SortOrder
    phone?: SortOrder
    email?: SortOrderInput | SortOrder
    birthDay?: SortOrder
    birthMonth?: SortOrder
    birthYear?: SortOrderInput | SortOrder
    visitCount?: SortOrder
    loyaltyPoints?: SortOrder
    totalSpent?: SortOrder
    lastVisit?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    visits?: VisitOrderByRelationAggregateInput
    discounts?: CustomerDiscountOrderByRelationAggregateInput
  }

  export type CustomerWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    phone?: string
    AND?: CustomerWhereInput | CustomerWhereInput[]
    OR?: CustomerWhereInput[]
    NOT?: CustomerWhereInput | CustomerWhereInput[]
    fullName?: StringFilter<"Customer"> | string
    gender?: EnumGenderFilter<"Customer"> | $Enums.Gender
    location?: StringFilter<"Customer"> | string
    district?: StringFilter<"Customer"> | string
    province?: StringFilter<"Customer"> | string
    email?: StringNullableFilter<"Customer"> | string | null
    birthDay?: IntFilter<"Customer"> | number
    birthMonth?: IntFilter<"Customer"> | number
    birthYear?: IntNullableFilter<"Customer"> | number | null
    visitCount?: IntFilter<"Customer"> | number
    loyaltyPoints?: IntFilter<"Customer"> | number
    totalSpent?: DecimalFilter<"Customer"> | Decimal | DecimalJsLike | number | string
    lastVisit?: DateTimeNullableFilter<"Customer"> | Date | string | null
    isActive?: BoolFilter<"Customer"> | boolean
    createdAt?: DateTimeFilter<"Customer"> | Date | string
    updatedAt?: DateTimeFilter<"Customer"> | Date | string
    visits?: VisitListRelationFilter
    discounts?: CustomerDiscountListRelationFilter
  }, "id" | "phone">

  export type CustomerOrderByWithAggregationInput = {
    id?: SortOrder
    fullName?: SortOrder
    gender?: SortOrder
    location?: SortOrder
    district?: SortOrder
    province?: SortOrder
    phone?: SortOrder
    email?: SortOrderInput | SortOrder
    birthDay?: SortOrder
    birthMonth?: SortOrder
    birthYear?: SortOrderInput | SortOrder
    visitCount?: SortOrder
    loyaltyPoints?: SortOrder
    totalSpent?: SortOrder
    lastVisit?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CustomerCountOrderByAggregateInput
    _avg?: CustomerAvgOrderByAggregateInput
    _max?: CustomerMaxOrderByAggregateInput
    _min?: CustomerMinOrderByAggregateInput
    _sum?: CustomerSumOrderByAggregateInput
  }

  export type CustomerScalarWhereWithAggregatesInput = {
    AND?: CustomerScalarWhereWithAggregatesInput | CustomerScalarWhereWithAggregatesInput[]
    OR?: CustomerScalarWhereWithAggregatesInput[]
    NOT?: CustomerScalarWhereWithAggregatesInput | CustomerScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Customer"> | string
    fullName?: StringWithAggregatesFilter<"Customer"> | string
    gender?: EnumGenderWithAggregatesFilter<"Customer"> | $Enums.Gender
    location?: StringWithAggregatesFilter<"Customer"> | string
    district?: StringWithAggregatesFilter<"Customer"> | string
    province?: StringWithAggregatesFilter<"Customer"> | string
    phone?: StringWithAggregatesFilter<"Customer"> | string
    email?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    birthDay?: IntWithAggregatesFilter<"Customer"> | number
    birthMonth?: IntWithAggregatesFilter<"Customer"> | number
    birthYear?: IntNullableWithAggregatesFilter<"Customer"> | number | null
    visitCount?: IntWithAggregatesFilter<"Customer"> | number
    loyaltyPoints?: IntWithAggregatesFilter<"Customer"> | number
    totalSpent?: DecimalWithAggregatesFilter<"Customer"> | Decimal | DecimalJsLike | number | string
    lastVisit?: DateTimeNullableWithAggregatesFilter<"Customer"> | Date | string | null
    isActive?: BoolWithAggregatesFilter<"Customer"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Customer"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Customer"> | Date | string
  }

  export type ServiceWhereInput = {
    AND?: ServiceWhereInput | ServiceWhereInput[]
    OR?: ServiceWhereInput[]
    NOT?: ServiceWhereInput | ServiceWhereInput[]
    id?: StringFilter<"Service"> | string
    name?: StringFilter<"Service"> | string
    category?: EnumServiceCategoryFilter<"Service"> | $Enums.ServiceCategory
    description?: StringFilter<"Service"> | string
    singlePrice?: DecimalFilter<"Service"> | Decimal | DecimalJsLike | number | string
    combinedPrice?: DecimalNullableFilter<"Service"> | Decimal | DecimalJsLike | number | string | null
    childPrice?: DecimalNullableFilter<"Service"> | Decimal | DecimalJsLike | number | string | null
    childCombinedPrice?: DecimalNullableFilter<"Service"> | Decimal | DecimalJsLike | number | string | null
    duration?: IntFilter<"Service"> | number
    isActive?: BoolFilter<"Service"> | boolean
    isComboEligible?: BoolFilter<"Service"> | boolean
    createdAt?: DateTimeFilter<"Service"> | Date | string
    updatedAt?: DateTimeFilter<"Service"> | Date | string
    visitServices?: VisitServiceListRelationFilter
  }

  export type ServiceOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    category?: SortOrder
    description?: SortOrder
    singlePrice?: SortOrder
    combinedPrice?: SortOrderInput | SortOrder
    childPrice?: SortOrderInput | SortOrder
    childCombinedPrice?: SortOrderInput | SortOrder
    duration?: SortOrder
    isActive?: SortOrder
    isComboEligible?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    visitServices?: VisitServiceOrderByRelationAggregateInput
  }

  export type ServiceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: ServiceWhereInput | ServiceWhereInput[]
    OR?: ServiceWhereInput[]
    NOT?: ServiceWhereInput | ServiceWhereInput[]
    category?: EnumServiceCategoryFilter<"Service"> | $Enums.ServiceCategory
    description?: StringFilter<"Service"> | string
    singlePrice?: DecimalFilter<"Service"> | Decimal | DecimalJsLike | number | string
    combinedPrice?: DecimalNullableFilter<"Service"> | Decimal | DecimalJsLike | number | string | null
    childPrice?: DecimalNullableFilter<"Service"> | Decimal | DecimalJsLike | number | string | null
    childCombinedPrice?: DecimalNullableFilter<"Service"> | Decimal | DecimalJsLike | number | string | null
    duration?: IntFilter<"Service"> | number
    isActive?: BoolFilter<"Service"> | boolean
    isComboEligible?: BoolFilter<"Service"> | boolean
    createdAt?: DateTimeFilter<"Service"> | Date | string
    updatedAt?: DateTimeFilter<"Service"> | Date | string
    visitServices?: VisitServiceListRelationFilter
  }, "id" | "name">

  export type ServiceOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    category?: SortOrder
    description?: SortOrder
    singlePrice?: SortOrder
    combinedPrice?: SortOrderInput | SortOrder
    childPrice?: SortOrderInput | SortOrder
    childCombinedPrice?: SortOrderInput | SortOrder
    duration?: SortOrder
    isActive?: SortOrder
    isComboEligible?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ServiceCountOrderByAggregateInput
    _avg?: ServiceAvgOrderByAggregateInput
    _max?: ServiceMaxOrderByAggregateInput
    _min?: ServiceMinOrderByAggregateInput
    _sum?: ServiceSumOrderByAggregateInput
  }

  export type ServiceScalarWhereWithAggregatesInput = {
    AND?: ServiceScalarWhereWithAggregatesInput | ServiceScalarWhereWithAggregatesInput[]
    OR?: ServiceScalarWhereWithAggregatesInput[]
    NOT?: ServiceScalarWhereWithAggregatesInput | ServiceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Service"> | string
    name?: StringWithAggregatesFilter<"Service"> | string
    category?: EnumServiceCategoryWithAggregatesFilter<"Service"> | $Enums.ServiceCategory
    description?: StringWithAggregatesFilter<"Service"> | string
    singlePrice?: DecimalWithAggregatesFilter<"Service"> | Decimal | DecimalJsLike | number | string
    combinedPrice?: DecimalNullableWithAggregatesFilter<"Service"> | Decimal | DecimalJsLike | number | string | null
    childPrice?: DecimalNullableWithAggregatesFilter<"Service"> | Decimal | DecimalJsLike | number | string | null
    childCombinedPrice?: DecimalNullableWithAggregatesFilter<"Service"> | Decimal | DecimalJsLike | number | string | null
    duration?: IntWithAggregatesFilter<"Service"> | number
    isActive?: BoolWithAggregatesFilter<"Service"> | boolean
    isComboEligible?: BoolWithAggregatesFilter<"Service"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Service"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Service"> | Date | string
  }

  export type VisitWhereInput = {
    AND?: VisitWhereInput | VisitWhereInput[]
    OR?: VisitWhereInput[]
    NOT?: VisitWhereInput | VisitWhereInput[]
    id?: StringFilter<"Visit"> | string
    customerId?: StringFilter<"Visit"> | string
    visitDate?: DateTimeFilter<"Visit"> | Date | string
    totalAmount?: DecimalFilter<"Visit"> | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFilter<"Visit"> | Decimal | DecimalJsLike | number | string
    finalAmount?: DecimalFilter<"Visit"> | Decimal | DecimalJsLike | number | string
    loyaltyPointsEarned?: IntFilter<"Visit"> | number
    notes?: StringNullableFilter<"Visit"> | string | null
    isCompleted?: BoolFilter<"Visit"> | boolean
    createdById?: StringFilter<"Visit"> | string
    createdAt?: DateTimeFilter<"Visit"> | Date | string
    updatedAt?: DateTimeFilter<"Visit"> | Date | string
    customer?: XOR<CustomerScalarRelationFilter, CustomerWhereInput>
    createdBy?: XOR<UserScalarRelationFilter, UserWhereInput>
    services?: VisitServiceListRelationFilter
    staff?: VisitStaffListRelationFilter
    discounts?: VisitDiscountListRelationFilter
  }

  export type VisitOrderByWithRelationInput = {
    id?: SortOrder
    customerId?: SortOrder
    visitDate?: SortOrder
    totalAmount?: SortOrder
    discountAmount?: SortOrder
    finalAmount?: SortOrder
    loyaltyPointsEarned?: SortOrder
    notes?: SortOrderInput | SortOrder
    isCompleted?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    customer?: CustomerOrderByWithRelationInput
    createdBy?: UserOrderByWithRelationInput
    services?: VisitServiceOrderByRelationAggregateInput
    staff?: VisitStaffOrderByRelationAggregateInput
    discounts?: VisitDiscountOrderByRelationAggregateInput
  }

  export type VisitWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: VisitWhereInput | VisitWhereInput[]
    OR?: VisitWhereInput[]
    NOT?: VisitWhereInput | VisitWhereInput[]
    customerId?: StringFilter<"Visit"> | string
    visitDate?: DateTimeFilter<"Visit"> | Date | string
    totalAmount?: DecimalFilter<"Visit"> | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFilter<"Visit"> | Decimal | DecimalJsLike | number | string
    finalAmount?: DecimalFilter<"Visit"> | Decimal | DecimalJsLike | number | string
    loyaltyPointsEarned?: IntFilter<"Visit"> | number
    notes?: StringNullableFilter<"Visit"> | string | null
    isCompleted?: BoolFilter<"Visit"> | boolean
    createdById?: StringFilter<"Visit"> | string
    createdAt?: DateTimeFilter<"Visit"> | Date | string
    updatedAt?: DateTimeFilter<"Visit"> | Date | string
    customer?: XOR<CustomerScalarRelationFilter, CustomerWhereInput>
    createdBy?: XOR<UserScalarRelationFilter, UserWhereInput>
    services?: VisitServiceListRelationFilter
    staff?: VisitStaffListRelationFilter
    discounts?: VisitDiscountListRelationFilter
  }, "id">

  export type VisitOrderByWithAggregationInput = {
    id?: SortOrder
    customerId?: SortOrder
    visitDate?: SortOrder
    totalAmount?: SortOrder
    discountAmount?: SortOrder
    finalAmount?: SortOrder
    loyaltyPointsEarned?: SortOrder
    notes?: SortOrderInput | SortOrder
    isCompleted?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: VisitCountOrderByAggregateInput
    _avg?: VisitAvgOrderByAggregateInput
    _max?: VisitMaxOrderByAggregateInput
    _min?: VisitMinOrderByAggregateInput
    _sum?: VisitSumOrderByAggregateInput
  }

  export type VisitScalarWhereWithAggregatesInput = {
    AND?: VisitScalarWhereWithAggregatesInput | VisitScalarWhereWithAggregatesInput[]
    OR?: VisitScalarWhereWithAggregatesInput[]
    NOT?: VisitScalarWhereWithAggregatesInput | VisitScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Visit"> | string
    customerId?: StringWithAggregatesFilter<"Visit"> | string
    visitDate?: DateTimeWithAggregatesFilter<"Visit"> | Date | string
    totalAmount?: DecimalWithAggregatesFilter<"Visit"> | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalWithAggregatesFilter<"Visit"> | Decimal | DecimalJsLike | number | string
    finalAmount?: DecimalWithAggregatesFilter<"Visit"> | Decimal | DecimalJsLike | number | string
    loyaltyPointsEarned?: IntWithAggregatesFilter<"Visit"> | number
    notes?: StringNullableWithAggregatesFilter<"Visit"> | string | null
    isCompleted?: BoolWithAggregatesFilter<"Visit"> | boolean
    createdById?: StringWithAggregatesFilter<"Visit"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Visit"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Visit"> | Date | string
  }

  export type VisitServiceWhereInput = {
    AND?: VisitServiceWhereInput | VisitServiceWhereInput[]
    OR?: VisitServiceWhereInput[]
    NOT?: VisitServiceWhereInput | VisitServiceWhereInput[]
    id?: StringFilter<"VisitService"> | string
    visitId?: StringFilter<"VisitService"> | string
    serviceId?: StringFilter<"VisitService"> | string
    quantity?: IntFilter<"VisitService"> | number
    unitPrice?: DecimalFilter<"VisitService"> | Decimal | DecimalJsLike | number | string
    totalPrice?: DecimalFilter<"VisitService"> | Decimal | DecimalJsLike | number | string
    isChild?: BoolFilter<"VisitService"> | boolean
    isCombined?: BoolFilter<"VisitService"> | boolean
    createdAt?: DateTimeFilter<"VisitService"> | Date | string
    visit?: XOR<VisitScalarRelationFilter, VisitWhereInput>
    service?: XOR<ServiceScalarRelationFilter, ServiceWhereInput>
  }

  export type VisitServiceOrderByWithRelationInput = {
    id?: SortOrder
    visitId?: SortOrder
    serviceId?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    totalPrice?: SortOrder
    isChild?: SortOrder
    isCombined?: SortOrder
    createdAt?: SortOrder
    visit?: VisitOrderByWithRelationInput
    service?: ServiceOrderByWithRelationInput
  }

  export type VisitServiceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: VisitServiceWhereInput | VisitServiceWhereInput[]
    OR?: VisitServiceWhereInput[]
    NOT?: VisitServiceWhereInput | VisitServiceWhereInput[]
    visitId?: StringFilter<"VisitService"> | string
    serviceId?: StringFilter<"VisitService"> | string
    quantity?: IntFilter<"VisitService"> | number
    unitPrice?: DecimalFilter<"VisitService"> | Decimal | DecimalJsLike | number | string
    totalPrice?: DecimalFilter<"VisitService"> | Decimal | DecimalJsLike | number | string
    isChild?: BoolFilter<"VisitService"> | boolean
    isCombined?: BoolFilter<"VisitService"> | boolean
    createdAt?: DateTimeFilter<"VisitService"> | Date | string
    visit?: XOR<VisitScalarRelationFilter, VisitWhereInput>
    service?: XOR<ServiceScalarRelationFilter, ServiceWhereInput>
  }, "id">

  export type VisitServiceOrderByWithAggregationInput = {
    id?: SortOrder
    visitId?: SortOrder
    serviceId?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    totalPrice?: SortOrder
    isChild?: SortOrder
    isCombined?: SortOrder
    createdAt?: SortOrder
    _count?: VisitServiceCountOrderByAggregateInput
    _avg?: VisitServiceAvgOrderByAggregateInput
    _max?: VisitServiceMaxOrderByAggregateInput
    _min?: VisitServiceMinOrderByAggregateInput
    _sum?: VisitServiceSumOrderByAggregateInput
  }

  export type VisitServiceScalarWhereWithAggregatesInput = {
    AND?: VisitServiceScalarWhereWithAggregatesInput | VisitServiceScalarWhereWithAggregatesInput[]
    OR?: VisitServiceScalarWhereWithAggregatesInput[]
    NOT?: VisitServiceScalarWhereWithAggregatesInput | VisitServiceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"VisitService"> | string
    visitId?: StringWithAggregatesFilter<"VisitService"> | string
    serviceId?: StringWithAggregatesFilter<"VisitService"> | string
    quantity?: IntWithAggregatesFilter<"VisitService"> | number
    unitPrice?: DecimalWithAggregatesFilter<"VisitService"> | Decimal | DecimalJsLike | number | string
    totalPrice?: DecimalWithAggregatesFilter<"VisitService"> | Decimal | DecimalJsLike | number | string
    isChild?: BoolWithAggregatesFilter<"VisitService"> | boolean
    isCombined?: BoolWithAggregatesFilter<"VisitService"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"VisitService"> | Date | string
  }

  export type VisitStaffWhereInput = {
    AND?: VisitStaffWhereInput | VisitStaffWhereInput[]
    OR?: VisitStaffWhereInput[]
    NOT?: VisitStaffWhereInput | VisitStaffWhereInput[]
    id?: StringFilter<"VisitStaff"> | string
    visitId?: StringFilter<"VisitStaff"> | string
    staffId?: StringFilter<"VisitStaff"> | string
    serviceId?: StringNullableFilter<"VisitStaff"> | string | null
    createdAt?: DateTimeFilter<"VisitStaff"> | Date | string
    visit?: XOR<VisitScalarRelationFilter, VisitWhereInput>
    staff?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type VisitStaffOrderByWithRelationInput = {
    id?: SortOrder
    visitId?: SortOrder
    staffId?: SortOrder
    serviceId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    visit?: VisitOrderByWithRelationInput
    staff?: UserOrderByWithRelationInput
  }

  export type VisitStaffWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: VisitStaffWhereInput | VisitStaffWhereInput[]
    OR?: VisitStaffWhereInput[]
    NOT?: VisitStaffWhereInput | VisitStaffWhereInput[]
    visitId?: StringFilter<"VisitStaff"> | string
    staffId?: StringFilter<"VisitStaff"> | string
    serviceId?: StringNullableFilter<"VisitStaff"> | string | null
    createdAt?: DateTimeFilter<"VisitStaff"> | Date | string
    visit?: XOR<VisitScalarRelationFilter, VisitWhereInput>
    staff?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type VisitStaffOrderByWithAggregationInput = {
    id?: SortOrder
    visitId?: SortOrder
    staffId?: SortOrder
    serviceId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: VisitStaffCountOrderByAggregateInput
    _max?: VisitStaffMaxOrderByAggregateInput
    _min?: VisitStaffMinOrderByAggregateInput
  }

  export type VisitStaffScalarWhereWithAggregatesInput = {
    AND?: VisitStaffScalarWhereWithAggregatesInput | VisitStaffScalarWhereWithAggregatesInput[]
    OR?: VisitStaffScalarWhereWithAggregatesInput[]
    NOT?: VisitStaffScalarWhereWithAggregatesInput | VisitStaffScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"VisitStaff"> | string
    visitId?: StringWithAggregatesFilter<"VisitStaff"> | string
    staffId?: StringWithAggregatesFilter<"VisitStaff"> | string
    serviceId?: StringNullableWithAggregatesFilter<"VisitStaff"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"VisitStaff"> | Date | string
  }

  export type DiscountRuleWhereInput = {
    AND?: DiscountRuleWhereInput | DiscountRuleWhereInput[]
    OR?: DiscountRuleWhereInput[]
    NOT?: DiscountRuleWhereInput | DiscountRuleWhereInput[]
    id?: StringFilter<"DiscountRule"> | string
    name?: StringFilter<"DiscountRule"> | string
    type?: EnumDiscountTypeFilter<"DiscountRule"> | $Enums.DiscountType
    value?: DecimalFilter<"DiscountRule"> | Decimal | DecimalJsLike | number | string
    isPercentage?: BoolFilter<"DiscountRule"> | boolean
    isActive?: BoolFilter<"DiscountRule"> | boolean
    description?: StringNullableFilter<"DiscountRule"> | string | null
    minAmount?: DecimalNullableFilter<"DiscountRule"> | Decimal | DecimalJsLike | number | string | null
    maxDiscount?: DecimalNullableFilter<"DiscountRule"> | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFilter<"DiscountRule"> | Date | string
    updatedAt?: DateTimeFilter<"DiscountRule"> | Date | string
    visitDiscounts?: VisitDiscountListRelationFilter
    customerDiscounts?: CustomerDiscountListRelationFilter
  }

  export type DiscountRuleOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    value?: SortOrder
    isPercentage?: SortOrder
    isActive?: SortOrder
    description?: SortOrderInput | SortOrder
    minAmount?: SortOrderInput | SortOrder
    maxDiscount?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    visitDiscounts?: VisitDiscountOrderByRelationAggregateInput
    customerDiscounts?: CustomerDiscountOrderByRelationAggregateInput
  }

  export type DiscountRuleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: DiscountRuleWhereInput | DiscountRuleWhereInput[]
    OR?: DiscountRuleWhereInput[]
    NOT?: DiscountRuleWhereInput | DiscountRuleWhereInput[]
    type?: EnumDiscountTypeFilter<"DiscountRule"> | $Enums.DiscountType
    value?: DecimalFilter<"DiscountRule"> | Decimal | DecimalJsLike | number | string
    isPercentage?: BoolFilter<"DiscountRule"> | boolean
    isActive?: BoolFilter<"DiscountRule"> | boolean
    description?: StringNullableFilter<"DiscountRule"> | string | null
    minAmount?: DecimalNullableFilter<"DiscountRule"> | Decimal | DecimalJsLike | number | string | null
    maxDiscount?: DecimalNullableFilter<"DiscountRule"> | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFilter<"DiscountRule"> | Date | string
    updatedAt?: DateTimeFilter<"DiscountRule"> | Date | string
    visitDiscounts?: VisitDiscountListRelationFilter
    customerDiscounts?: CustomerDiscountListRelationFilter
  }, "id" | "name">

  export type DiscountRuleOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    value?: SortOrder
    isPercentage?: SortOrder
    isActive?: SortOrder
    description?: SortOrderInput | SortOrder
    minAmount?: SortOrderInput | SortOrder
    maxDiscount?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DiscountRuleCountOrderByAggregateInput
    _avg?: DiscountRuleAvgOrderByAggregateInput
    _max?: DiscountRuleMaxOrderByAggregateInput
    _min?: DiscountRuleMinOrderByAggregateInput
    _sum?: DiscountRuleSumOrderByAggregateInput
  }

  export type DiscountRuleScalarWhereWithAggregatesInput = {
    AND?: DiscountRuleScalarWhereWithAggregatesInput | DiscountRuleScalarWhereWithAggregatesInput[]
    OR?: DiscountRuleScalarWhereWithAggregatesInput[]
    NOT?: DiscountRuleScalarWhereWithAggregatesInput | DiscountRuleScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DiscountRule"> | string
    name?: StringWithAggregatesFilter<"DiscountRule"> | string
    type?: EnumDiscountTypeWithAggregatesFilter<"DiscountRule"> | $Enums.DiscountType
    value?: DecimalWithAggregatesFilter<"DiscountRule"> | Decimal | DecimalJsLike | number | string
    isPercentage?: BoolWithAggregatesFilter<"DiscountRule"> | boolean
    isActive?: BoolWithAggregatesFilter<"DiscountRule"> | boolean
    description?: StringNullableWithAggregatesFilter<"DiscountRule"> | string | null
    minAmount?: DecimalNullableWithAggregatesFilter<"DiscountRule"> | Decimal | DecimalJsLike | number | string | null
    maxDiscount?: DecimalNullableWithAggregatesFilter<"DiscountRule"> | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeWithAggregatesFilter<"DiscountRule"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"DiscountRule"> | Date | string
  }

  export type VisitDiscountWhereInput = {
    AND?: VisitDiscountWhereInput | VisitDiscountWhereInput[]
    OR?: VisitDiscountWhereInput[]
    NOT?: VisitDiscountWhereInput | VisitDiscountWhereInput[]
    id?: StringFilter<"VisitDiscount"> | string
    visitId?: StringFilter<"VisitDiscount"> | string
    discountRuleId?: StringFilter<"VisitDiscount"> | string
    discountAmount?: DecimalFilter<"VisitDiscount"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"VisitDiscount"> | Date | string
    visit?: XOR<VisitScalarRelationFilter, VisitWhereInput>
    discountRule?: XOR<DiscountRuleScalarRelationFilter, DiscountRuleWhereInput>
  }

  export type VisitDiscountOrderByWithRelationInput = {
    id?: SortOrder
    visitId?: SortOrder
    discountRuleId?: SortOrder
    discountAmount?: SortOrder
    createdAt?: SortOrder
    visit?: VisitOrderByWithRelationInput
    discountRule?: DiscountRuleOrderByWithRelationInput
  }

  export type VisitDiscountWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: VisitDiscountWhereInput | VisitDiscountWhereInput[]
    OR?: VisitDiscountWhereInput[]
    NOT?: VisitDiscountWhereInput | VisitDiscountWhereInput[]
    visitId?: StringFilter<"VisitDiscount"> | string
    discountRuleId?: StringFilter<"VisitDiscount"> | string
    discountAmount?: DecimalFilter<"VisitDiscount"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"VisitDiscount"> | Date | string
    visit?: XOR<VisitScalarRelationFilter, VisitWhereInput>
    discountRule?: XOR<DiscountRuleScalarRelationFilter, DiscountRuleWhereInput>
  }, "id">

  export type VisitDiscountOrderByWithAggregationInput = {
    id?: SortOrder
    visitId?: SortOrder
    discountRuleId?: SortOrder
    discountAmount?: SortOrder
    createdAt?: SortOrder
    _count?: VisitDiscountCountOrderByAggregateInput
    _avg?: VisitDiscountAvgOrderByAggregateInput
    _max?: VisitDiscountMaxOrderByAggregateInput
    _min?: VisitDiscountMinOrderByAggregateInput
    _sum?: VisitDiscountSumOrderByAggregateInput
  }

  export type VisitDiscountScalarWhereWithAggregatesInput = {
    AND?: VisitDiscountScalarWhereWithAggregatesInput | VisitDiscountScalarWhereWithAggregatesInput[]
    OR?: VisitDiscountScalarWhereWithAggregatesInput[]
    NOT?: VisitDiscountScalarWhereWithAggregatesInput | VisitDiscountScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"VisitDiscount"> | string
    visitId?: StringWithAggregatesFilter<"VisitDiscount"> | string
    discountRuleId?: StringWithAggregatesFilter<"VisitDiscount"> | string
    discountAmount?: DecimalWithAggregatesFilter<"VisitDiscount"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeWithAggregatesFilter<"VisitDiscount"> | Date | string
  }

  export type CustomerDiscountWhereInput = {
    AND?: CustomerDiscountWhereInput | CustomerDiscountWhereInput[]
    OR?: CustomerDiscountWhereInput[]
    NOT?: CustomerDiscountWhereInput | CustomerDiscountWhereInput[]
    id?: StringFilter<"CustomerDiscount"> | string
    customerId?: StringFilter<"CustomerDiscount"> | string
    discountRuleId?: StringFilter<"CustomerDiscount"> | string
    usedAt?: DateTimeFilter<"CustomerDiscount"> | Date | string
    discountAmount?: DecimalFilter<"CustomerDiscount"> | Decimal | DecimalJsLike | number | string
    customer?: XOR<CustomerScalarRelationFilter, CustomerWhereInput>
    discountRule?: XOR<DiscountRuleScalarRelationFilter, DiscountRuleWhereInput>
  }

  export type CustomerDiscountOrderByWithRelationInput = {
    id?: SortOrder
    customerId?: SortOrder
    discountRuleId?: SortOrder
    usedAt?: SortOrder
    discountAmount?: SortOrder
    customer?: CustomerOrderByWithRelationInput
    discountRule?: DiscountRuleOrderByWithRelationInput
  }

  export type CustomerDiscountWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CustomerDiscountWhereInput | CustomerDiscountWhereInput[]
    OR?: CustomerDiscountWhereInput[]
    NOT?: CustomerDiscountWhereInput | CustomerDiscountWhereInput[]
    customerId?: StringFilter<"CustomerDiscount"> | string
    discountRuleId?: StringFilter<"CustomerDiscount"> | string
    usedAt?: DateTimeFilter<"CustomerDiscount"> | Date | string
    discountAmount?: DecimalFilter<"CustomerDiscount"> | Decimal | DecimalJsLike | number | string
    customer?: XOR<CustomerScalarRelationFilter, CustomerWhereInput>
    discountRule?: XOR<DiscountRuleScalarRelationFilter, DiscountRuleWhereInput>
  }, "id">

  export type CustomerDiscountOrderByWithAggregationInput = {
    id?: SortOrder
    customerId?: SortOrder
    discountRuleId?: SortOrder
    usedAt?: SortOrder
    discountAmount?: SortOrder
    _count?: CustomerDiscountCountOrderByAggregateInput
    _avg?: CustomerDiscountAvgOrderByAggregateInput
    _max?: CustomerDiscountMaxOrderByAggregateInput
    _min?: CustomerDiscountMinOrderByAggregateInput
    _sum?: CustomerDiscountSumOrderByAggregateInput
  }

  export type CustomerDiscountScalarWhereWithAggregatesInput = {
    AND?: CustomerDiscountScalarWhereWithAggregatesInput | CustomerDiscountScalarWhereWithAggregatesInput[]
    OR?: CustomerDiscountScalarWhereWithAggregatesInput[]
    NOT?: CustomerDiscountScalarWhereWithAggregatesInput | CustomerDiscountScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CustomerDiscount"> | string
    customerId?: StringWithAggregatesFilter<"CustomerDiscount"> | string
    discountRuleId?: StringWithAggregatesFilter<"CustomerDiscount"> | string
    usedAt?: DateTimeWithAggregatesFilter<"CustomerDiscount"> | Date | string
    discountAmount?: DecimalWithAggregatesFilter<"CustomerDiscount"> | Decimal | DecimalJsLike | number | string
  }

  export type UserCreateInput = {
    id?: string
    name: string
    email: string
    password: string
    role?: $Enums.Role
    phone?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    visits?: VisitCreateNestedManyWithoutCreatedByInput
    staffVisits?: VisitStaffCreateNestedManyWithoutStaffInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    name: string
    email: string
    password: string
    role?: $Enums.Role
    phone?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    visits?: VisitUncheckedCreateNestedManyWithoutCreatedByInput
    staffVisits?: VisitStaffUncheckedCreateNestedManyWithoutStaffInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    visits?: VisitUpdateManyWithoutCreatedByNestedInput
    staffVisits?: VisitStaffUpdateManyWithoutStaffNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    visits?: VisitUncheckedUpdateManyWithoutCreatedByNestedInput
    staffVisits?: VisitStaffUncheckedUpdateManyWithoutStaffNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    name: string
    email: string
    password: string
    role?: $Enums.Role
    phone?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerCreateInput = {
    id?: string
    fullName: string
    gender: $Enums.Gender
    location: string
    district: string
    province: string
    phone: string
    email?: string | null
    birthDay: number
    birthMonth: number
    birthYear?: number | null
    visitCount?: number
    loyaltyPoints?: number
    totalSpent?: Decimal | DecimalJsLike | number | string
    lastVisit?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    visits?: VisitCreateNestedManyWithoutCustomerInput
    discounts?: CustomerDiscountCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateInput = {
    id?: string
    fullName: string
    gender: $Enums.Gender
    location: string
    district: string
    province: string
    phone: string
    email?: string | null
    birthDay: number
    birthMonth: number
    birthYear?: number | null
    visitCount?: number
    loyaltyPoints?: number
    totalSpent?: Decimal | DecimalJsLike | number | string
    lastVisit?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    visits?: VisitUncheckedCreateNestedManyWithoutCustomerInput
    discounts?: CustomerDiscountUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    location?: StringFieldUpdateOperationsInput | string
    district?: StringFieldUpdateOperationsInput | string
    province?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    birthDay?: IntFieldUpdateOperationsInput | number
    birthMonth?: IntFieldUpdateOperationsInput | number
    birthYear?: NullableIntFieldUpdateOperationsInput | number | null
    visitCount?: IntFieldUpdateOperationsInput | number
    loyaltyPoints?: IntFieldUpdateOperationsInput | number
    totalSpent?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lastVisit?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    visits?: VisitUpdateManyWithoutCustomerNestedInput
    discounts?: CustomerDiscountUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    location?: StringFieldUpdateOperationsInput | string
    district?: StringFieldUpdateOperationsInput | string
    province?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    birthDay?: IntFieldUpdateOperationsInput | number
    birthMonth?: IntFieldUpdateOperationsInput | number
    birthYear?: NullableIntFieldUpdateOperationsInput | number | null
    visitCount?: IntFieldUpdateOperationsInput | number
    loyaltyPoints?: IntFieldUpdateOperationsInput | number
    totalSpent?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lastVisit?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    visits?: VisitUncheckedUpdateManyWithoutCustomerNestedInput
    discounts?: CustomerDiscountUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerCreateManyInput = {
    id?: string
    fullName: string
    gender: $Enums.Gender
    location: string
    district: string
    province: string
    phone: string
    email?: string | null
    birthDay: number
    birthMonth: number
    birthYear?: number | null
    visitCount?: number
    loyaltyPoints?: number
    totalSpent?: Decimal | DecimalJsLike | number | string
    lastVisit?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CustomerUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    location?: StringFieldUpdateOperationsInput | string
    district?: StringFieldUpdateOperationsInput | string
    province?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    birthDay?: IntFieldUpdateOperationsInput | number
    birthMonth?: IntFieldUpdateOperationsInput | number
    birthYear?: NullableIntFieldUpdateOperationsInput | number | null
    visitCount?: IntFieldUpdateOperationsInput | number
    loyaltyPoints?: IntFieldUpdateOperationsInput | number
    totalSpent?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lastVisit?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    location?: StringFieldUpdateOperationsInput | string
    district?: StringFieldUpdateOperationsInput | string
    province?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    birthDay?: IntFieldUpdateOperationsInput | number
    birthMonth?: IntFieldUpdateOperationsInput | number
    birthYear?: NullableIntFieldUpdateOperationsInput | number | null
    visitCount?: IntFieldUpdateOperationsInput | number
    loyaltyPoints?: IntFieldUpdateOperationsInput | number
    totalSpent?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lastVisit?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceCreateInput = {
    id?: string
    name: string
    category: $Enums.ServiceCategory
    description: string
    singlePrice: Decimal | DecimalJsLike | number | string
    combinedPrice?: Decimal | DecimalJsLike | number | string | null
    childPrice?: Decimal | DecimalJsLike | number | string | null
    childCombinedPrice?: Decimal | DecimalJsLike | number | string | null
    duration: number
    isActive?: boolean
    isComboEligible?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    visitServices?: VisitServiceCreateNestedManyWithoutServiceInput
  }

  export type ServiceUncheckedCreateInput = {
    id?: string
    name: string
    category: $Enums.ServiceCategory
    description: string
    singlePrice: Decimal | DecimalJsLike | number | string
    combinedPrice?: Decimal | DecimalJsLike | number | string | null
    childPrice?: Decimal | DecimalJsLike | number | string | null
    childCombinedPrice?: Decimal | DecimalJsLike | number | string | null
    duration: number
    isActive?: boolean
    isComboEligible?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    visitServices?: VisitServiceUncheckedCreateNestedManyWithoutServiceInput
  }

  export type ServiceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: EnumServiceCategoryFieldUpdateOperationsInput | $Enums.ServiceCategory
    description?: StringFieldUpdateOperationsInput | string
    singlePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    combinedPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    childPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    childCombinedPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    duration?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isComboEligible?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    visitServices?: VisitServiceUpdateManyWithoutServiceNestedInput
  }

  export type ServiceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: EnumServiceCategoryFieldUpdateOperationsInput | $Enums.ServiceCategory
    description?: StringFieldUpdateOperationsInput | string
    singlePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    combinedPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    childPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    childCombinedPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    duration?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isComboEligible?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    visitServices?: VisitServiceUncheckedUpdateManyWithoutServiceNestedInput
  }

  export type ServiceCreateManyInput = {
    id?: string
    name: string
    category: $Enums.ServiceCategory
    description: string
    singlePrice: Decimal | DecimalJsLike | number | string
    combinedPrice?: Decimal | DecimalJsLike | number | string | null
    childPrice?: Decimal | DecimalJsLike | number | string | null
    childCombinedPrice?: Decimal | DecimalJsLike | number | string | null
    duration: number
    isActive?: boolean
    isComboEligible?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ServiceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: EnumServiceCategoryFieldUpdateOperationsInput | $Enums.ServiceCategory
    description?: StringFieldUpdateOperationsInput | string
    singlePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    combinedPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    childPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    childCombinedPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    duration?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isComboEligible?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: EnumServiceCategoryFieldUpdateOperationsInput | $Enums.ServiceCategory
    description?: StringFieldUpdateOperationsInput | string
    singlePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    combinedPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    childPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    childCombinedPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    duration?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isComboEligible?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VisitCreateInput = {
    id?: string
    visitDate?: Date | string
    totalAmount: Decimal | DecimalJsLike | number | string
    discountAmount?: Decimal | DecimalJsLike | number | string
    finalAmount: Decimal | DecimalJsLike | number | string
    loyaltyPointsEarned?: number
    notes?: string | null
    isCompleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    customer: CustomerCreateNestedOneWithoutVisitsInput
    createdBy: UserCreateNestedOneWithoutVisitsInput
    services?: VisitServiceCreateNestedManyWithoutVisitInput
    staff?: VisitStaffCreateNestedManyWithoutVisitInput
    discounts?: VisitDiscountCreateNestedManyWithoutVisitInput
  }

  export type VisitUncheckedCreateInput = {
    id?: string
    customerId: string
    visitDate?: Date | string
    totalAmount: Decimal | DecimalJsLike | number | string
    discountAmount?: Decimal | DecimalJsLike | number | string
    finalAmount: Decimal | DecimalJsLike | number | string
    loyaltyPointsEarned?: number
    notes?: string | null
    isCompleted?: boolean
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
    services?: VisitServiceUncheckedCreateNestedManyWithoutVisitInput
    staff?: VisitStaffUncheckedCreateNestedManyWithoutVisitInput
    discounts?: VisitDiscountUncheckedCreateNestedManyWithoutVisitInput
  }

  export type VisitUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    visitDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    finalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    loyaltyPointsEarned?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomerUpdateOneRequiredWithoutVisitsNestedInput
    createdBy?: UserUpdateOneRequiredWithoutVisitsNestedInput
    services?: VisitServiceUpdateManyWithoutVisitNestedInput
    staff?: VisitStaffUpdateManyWithoutVisitNestedInput
    discounts?: VisitDiscountUpdateManyWithoutVisitNestedInput
  }

  export type VisitUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    visitDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    finalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    loyaltyPointsEarned?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    services?: VisitServiceUncheckedUpdateManyWithoutVisitNestedInput
    staff?: VisitStaffUncheckedUpdateManyWithoutVisitNestedInput
    discounts?: VisitDiscountUncheckedUpdateManyWithoutVisitNestedInput
  }

  export type VisitCreateManyInput = {
    id?: string
    customerId: string
    visitDate?: Date | string
    totalAmount: Decimal | DecimalJsLike | number | string
    discountAmount?: Decimal | DecimalJsLike | number | string
    finalAmount: Decimal | DecimalJsLike | number | string
    loyaltyPointsEarned?: number
    notes?: string | null
    isCompleted?: boolean
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VisitUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    visitDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    finalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    loyaltyPointsEarned?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VisitUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    visitDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    finalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    loyaltyPointsEarned?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VisitServiceCreateInput = {
    id?: string
    quantity?: number
    unitPrice: Decimal | DecimalJsLike | number | string
    totalPrice: Decimal | DecimalJsLike | number | string
    isChild?: boolean
    isCombined?: boolean
    createdAt?: Date | string
    visit: VisitCreateNestedOneWithoutServicesInput
    service: ServiceCreateNestedOneWithoutVisitServicesInput
  }

  export type VisitServiceUncheckedCreateInput = {
    id?: string
    visitId: string
    serviceId: string
    quantity?: number
    unitPrice: Decimal | DecimalJsLike | number | string
    totalPrice: Decimal | DecimalJsLike | number | string
    isChild?: boolean
    isCombined?: boolean
    createdAt?: Date | string
  }

  export type VisitServiceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isChild?: BoolFieldUpdateOperationsInput | boolean
    isCombined?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    visit?: VisitUpdateOneRequiredWithoutServicesNestedInput
    service?: ServiceUpdateOneRequiredWithoutVisitServicesNestedInput
  }

  export type VisitServiceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    visitId?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isChild?: BoolFieldUpdateOperationsInput | boolean
    isCombined?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VisitServiceCreateManyInput = {
    id?: string
    visitId: string
    serviceId: string
    quantity?: number
    unitPrice: Decimal | DecimalJsLike | number | string
    totalPrice: Decimal | DecimalJsLike | number | string
    isChild?: boolean
    isCombined?: boolean
    createdAt?: Date | string
  }

  export type VisitServiceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isChild?: BoolFieldUpdateOperationsInput | boolean
    isCombined?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VisitServiceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    visitId?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isChild?: BoolFieldUpdateOperationsInput | boolean
    isCombined?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VisitStaffCreateInput = {
    id?: string
    serviceId?: string | null
    createdAt?: Date | string
    visit: VisitCreateNestedOneWithoutStaffInput
    staff: UserCreateNestedOneWithoutStaffVisitsInput
  }

  export type VisitStaffUncheckedCreateInput = {
    id?: string
    visitId: string
    staffId: string
    serviceId?: string | null
    createdAt?: Date | string
  }

  export type VisitStaffUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    visit?: VisitUpdateOneRequiredWithoutStaffNestedInput
    staff?: UserUpdateOneRequiredWithoutStaffVisitsNestedInput
  }

  export type VisitStaffUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    visitId?: StringFieldUpdateOperationsInput | string
    staffId?: StringFieldUpdateOperationsInput | string
    serviceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VisitStaffCreateManyInput = {
    id?: string
    visitId: string
    staffId: string
    serviceId?: string | null
    createdAt?: Date | string
  }

  export type VisitStaffUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VisitStaffUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    visitId?: StringFieldUpdateOperationsInput | string
    staffId?: StringFieldUpdateOperationsInput | string
    serviceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DiscountRuleCreateInput = {
    id?: string
    name: string
    type: $Enums.DiscountType
    value: Decimal | DecimalJsLike | number | string
    isPercentage?: boolean
    isActive?: boolean
    description?: string | null
    minAmount?: Decimal | DecimalJsLike | number | string | null
    maxDiscount?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    visitDiscounts?: VisitDiscountCreateNestedManyWithoutDiscountRuleInput
    customerDiscounts?: CustomerDiscountCreateNestedManyWithoutDiscountRuleInput
  }

  export type DiscountRuleUncheckedCreateInput = {
    id?: string
    name: string
    type: $Enums.DiscountType
    value: Decimal | DecimalJsLike | number | string
    isPercentage?: boolean
    isActive?: boolean
    description?: string | null
    minAmount?: Decimal | DecimalJsLike | number | string | null
    maxDiscount?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    visitDiscounts?: VisitDiscountUncheckedCreateNestedManyWithoutDiscountRuleInput
    customerDiscounts?: CustomerDiscountUncheckedCreateNestedManyWithoutDiscountRuleInput
  }

  export type DiscountRuleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumDiscountTypeFieldUpdateOperationsInput | $Enums.DiscountType
    value?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isPercentage?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    minAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    maxDiscount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    visitDiscounts?: VisitDiscountUpdateManyWithoutDiscountRuleNestedInput
    customerDiscounts?: CustomerDiscountUpdateManyWithoutDiscountRuleNestedInput
  }

  export type DiscountRuleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumDiscountTypeFieldUpdateOperationsInput | $Enums.DiscountType
    value?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isPercentage?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    minAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    maxDiscount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    visitDiscounts?: VisitDiscountUncheckedUpdateManyWithoutDiscountRuleNestedInput
    customerDiscounts?: CustomerDiscountUncheckedUpdateManyWithoutDiscountRuleNestedInput
  }

  export type DiscountRuleCreateManyInput = {
    id?: string
    name: string
    type: $Enums.DiscountType
    value: Decimal | DecimalJsLike | number | string
    isPercentage?: boolean
    isActive?: boolean
    description?: string | null
    minAmount?: Decimal | DecimalJsLike | number | string | null
    maxDiscount?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DiscountRuleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumDiscountTypeFieldUpdateOperationsInput | $Enums.DiscountType
    value?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isPercentage?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    minAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    maxDiscount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DiscountRuleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumDiscountTypeFieldUpdateOperationsInput | $Enums.DiscountType
    value?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isPercentage?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    minAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    maxDiscount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VisitDiscountCreateInput = {
    id?: string
    discountAmount: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    visit: VisitCreateNestedOneWithoutDiscountsInput
    discountRule: DiscountRuleCreateNestedOneWithoutVisitDiscountsInput
  }

  export type VisitDiscountUncheckedCreateInput = {
    id?: string
    visitId: string
    discountRuleId: string
    discountAmount: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
  }

  export type VisitDiscountUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    visit?: VisitUpdateOneRequiredWithoutDiscountsNestedInput
    discountRule?: DiscountRuleUpdateOneRequiredWithoutVisitDiscountsNestedInput
  }

  export type VisitDiscountUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    visitId?: StringFieldUpdateOperationsInput | string
    discountRuleId?: StringFieldUpdateOperationsInput | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VisitDiscountCreateManyInput = {
    id?: string
    visitId: string
    discountRuleId: string
    discountAmount: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
  }

  export type VisitDiscountUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VisitDiscountUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    visitId?: StringFieldUpdateOperationsInput | string
    discountRuleId?: StringFieldUpdateOperationsInput | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerDiscountCreateInput = {
    id?: string
    usedAt?: Date | string
    discountAmount: Decimal | DecimalJsLike | number | string
    customer: CustomerCreateNestedOneWithoutDiscountsInput
    discountRule: DiscountRuleCreateNestedOneWithoutCustomerDiscountsInput
  }

  export type CustomerDiscountUncheckedCreateInput = {
    id?: string
    customerId: string
    discountRuleId: string
    usedAt?: Date | string
    discountAmount: Decimal | DecimalJsLike | number | string
  }

  export type CustomerDiscountUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    usedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    customer?: CustomerUpdateOneRequiredWithoutDiscountsNestedInput
    discountRule?: DiscountRuleUpdateOneRequiredWithoutCustomerDiscountsNestedInput
  }

  export type CustomerDiscountUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    discountRuleId?: StringFieldUpdateOperationsInput | string
    usedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type CustomerDiscountCreateManyInput = {
    id?: string
    customerId: string
    discountRuleId: string
    usedAt?: Date | string
    discountAmount: Decimal | DecimalJsLike | number | string
  }

  export type CustomerDiscountUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    usedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type CustomerDiscountUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    discountRuleId?: StringFieldUpdateOperationsInput | string
    usedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type EnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type VisitListRelationFilter = {
    every?: VisitWhereInput
    some?: VisitWhereInput
    none?: VisitWhereInput
  }

  export type VisitStaffListRelationFilter = {
    every?: VisitStaffWhereInput
    some?: VisitStaffWhereInput
    none?: VisitStaffWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type VisitOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VisitStaffOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
    phone?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
    phone?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
    phone?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type EnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleFilter<$PrismaModel>
    _max?: NestedEnumRoleFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type EnumGenderFilter<$PrismaModel = never> = {
    equals?: $Enums.Gender | EnumGenderFieldRefInput<$PrismaModel>
    in?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel>
    notIn?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel>
    not?: NestedEnumGenderFilter<$PrismaModel> | $Enums.Gender
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type CustomerDiscountListRelationFilter = {
    every?: CustomerDiscountWhereInput
    some?: CustomerDiscountWhereInput
    none?: CustomerDiscountWhereInput
  }

  export type CustomerDiscountOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CustomerCountOrderByAggregateInput = {
    id?: SortOrder
    fullName?: SortOrder
    gender?: SortOrder
    location?: SortOrder
    district?: SortOrder
    province?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    birthDay?: SortOrder
    birthMonth?: SortOrder
    birthYear?: SortOrder
    visitCount?: SortOrder
    loyaltyPoints?: SortOrder
    totalSpent?: SortOrder
    lastVisit?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CustomerAvgOrderByAggregateInput = {
    birthDay?: SortOrder
    birthMonth?: SortOrder
    birthYear?: SortOrder
    visitCount?: SortOrder
    loyaltyPoints?: SortOrder
    totalSpent?: SortOrder
  }

  export type CustomerMaxOrderByAggregateInput = {
    id?: SortOrder
    fullName?: SortOrder
    gender?: SortOrder
    location?: SortOrder
    district?: SortOrder
    province?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    birthDay?: SortOrder
    birthMonth?: SortOrder
    birthYear?: SortOrder
    visitCount?: SortOrder
    loyaltyPoints?: SortOrder
    totalSpent?: SortOrder
    lastVisit?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CustomerMinOrderByAggregateInput = {
    id?: SortOrder
    fullName?: SortOrder
    gender?: SortOrder
    location?: SortOrder
    district?: SortOrder
    province?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    birthDay?: SortOrder
    birthMonth?: SortOrder
    birthYear?: SortOrder
    visitCount?: SortOrder
    loyaltyPoints?: SortOrder
    totalSpent?: SortOrder
    lastVisit?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CustomerSumOrderByAggregateInput = {
    birthDay?: SortOrder
    birthMonth?: SortOrder
    birthYear?: SortOrder
    visitCount?: SortOrder
    loyaltyPoints?: SortOrder
    totalSpent?: SortOrder
  }

  export type EnumGenderWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Gender | EnumGenderFieldRefInput<$PrismaModel>
    in?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel>
    notIn?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel>
    not?: NestedEnumGenderWithAggregatesFilter<$PrismaModel> | $Enums.Gender
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumGenderFilter<$PrismaModel>
    _max?: NestedEnumGenderFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type EnumServiceCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.ServiceCategory | EnumServiceCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.ServiceCategory[] | ListEnumServiceCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.ServiceCategory[] | ListEnumServiceCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumServiceCategoryFilter<$PrismaModel> | $Enums.ServiceCategory
  }

  export type DecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type VisitServiceListRelationFilter = {
    every?: VisitServiceWhereInput
    some?: VisitServiceWhereInput
    none?: VisitServiceWhereInput
  }

  export type VisitServiceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ServiceCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    category?: SortOrder
    description?: SortOrder
    singlePrice?: SortOrder
    combinedPrice?: SortOrder
    childPrice?: SortOrder
    childCombinedPrice?: SortOrder
    duration?: SortOrder
    isActive?: SortOrder
    isComboEligible?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ServiceAvgOrderByAggregateInput = {
    singlePrice?: SortOrder
    combinedPrice?: SortOrder
    childPrice?: SortOrder
    childCombinedPrice?: SortOrder
    duration?: SortOrder
  }

  export type ServiceMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    category?: SortOrder
    description?: SortOrder
    singlePrice?: SortOrder
    combinedPrice?: SortOrder
    childPrice?: SortOrder
    childCombinedPrice?: SortOrder
    duration?: SortOrder
    isActive?: SortOrder
    isComboEligible?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ServiceMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    category?: SortOrder
    description?: SortOrder
    singlePrice?: SortOrder
    combinedPrice?: SortOrder
    childPrice?: SortOrder
    childCombinedPrice?: SortOrder
    duration?: SortOrder
    isActive?: SortOrder
    isComboEligible?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ServiceSumOrderByAggregateInput = {
    singlePrice?: SortOrder
    combinedPrice?: SortOrder
    childPrice?: SortOrder
    childCombinedPrice?: SortOrder
    duration?: SortOrder
  }

  export type EnumServiceCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ServiceCategory | EnumServiceCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.ServiceCategory[] | ListEnumServiceCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.ServiceCategory[] | ListEnumServiceCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumServiceCategoryWithAggregatesFilter<$PrismaModel> | $Enums.ServiceCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumServiceCategoryFilter<$PrismaModel>
    _max?: NestedEnumServiceCategoryFilter<$PrismaModel>
  }

  export type DecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type CustomerScalarRelationFilter = {
    is?: CustomerWhereInput
    isNot?: CustomerWhereInput
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type VisitDiscountListRelationFilter = {
    every?: VisitDiscountWhereInput
    some?: VisitDiscountWhereInput
    none?: VisitDiscountWhereInput
  }

  export type VisitDiscountOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VisitCountOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    visitDate?: SortOrder
    totalAmount?: SortOrder
    discountAmount?: SortOrder
    finalAmount?: SortOrder
    loyaltyPointsEarned?: SortOrder
    notes?: SortOrder
    isCompleted?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VisitAvgOrderByAggregateInput = {
    totalAmount?: SortOrder
    discountAmount?: SortOrder
    finalAmount?: SortOrder
    loyaltyPointsEarned?: SortOrder
  }

  export type VisitMaxOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    visitDate?: SortOrder
    totalAmount?: SortOrder
    discountAmount?: SortOrder
    finalAmount?: SortOrder
    loyaltyPointsEarned?: SortOrder
    notes?: SortOrder
    isCompleted?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VisitMinOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    visitDate?: SortOrder
    totalAmount?: SortOrder
    discountAmount?: SortOrder
    finalAmount?: SortOrder
    loyaltyPointsEarned?: SortOrder
    notes?: SortOrder
    isCompleted?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VisitSumOrderByAggregateInput = {
    totalAmount?: SortOrder
    discountAmount?: SortOrder
    finalAmount?: SortOrder
    loyaltyPointsEarned?: SortOrder
  }

  export type VisitScalarRelationFilter = {
    is?: VisitWhereInput
    isNot?: VisitWhereInput
  }

  export type ServiceScalarRelationFilter = {
    is?: ServiceWhereInput
    isNot?: ServiceWhereInput
  }

  export type VisitServiceCountOrderByAggregateInput = {
    id?: SortOrder
    visitId?: SortOrder
    serviceId?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    totalPrice?: SortOrder
    isChild?: SortOrder
    isCombined?: SortOrder
    createdAt?: SortOrder
  }

  export type VisitServiceAvgOrderByAggregateInput = {
    quantity?: SortOrder
    unitPrice?: SortOrder
    totalPrice?: SortOrder
  }

  export type VisitServiceMaxOrderByAggregateInput = {
    id?: SortOrder
    visitId?: SortOrder
    serviceId?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    totalPrice?: SortOrder
    isChild?: SortOrder
    isCombined?: SortOrder
    createdAt?: SortOrder
  }

  export type VisitServiceMinOrderByAggregateInput = {
    id?: SortOrder
    visitId?: SortOrder
    serviceId?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    totalPrice?: SortOrder
    isChild?: SortOrder
    isCombined?: SortOrder
    createdAt?: SortOrder
  }

  export type VisitServiceSumOrderByAggregateInput = {
    quantity?: SortOrder
    unitPrice?: SortOrder
    totalPrice?: SortOrder
  }

  export type VisitStaffCountOrderByAggregateInput = {
    id?: SortOrder
    visitId?: SortOrder
    staffId?: SortOrder
    serviceId?: SortOrder
    createdAt?: SortOrder
  }

  export type VisitStaffMaxOrderByAggregateInput = {
    id?: SortOrder
    visitId?: SortOrder
    staffId?: SortOrder
    serviceId?: SortOrder
    createdAt?: SortOrder
  }

  export type VisitStaffMinOrderByAggregateInput = {
    id?: SortOrder
    visitId?: SortOrder
    staffId?: SortOrder
    serviceId?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumDiscountTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.DiscountType | EnumDiscountTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DiscountType[] | ListEnumDiscountTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DiscountType[] | ListEnumDiscountTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDiscountTypeFilter<$PrismaModel> | $Enums.DiscountType
  }

  export type DiscountRuleCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    value?: SortOrder
    isPercentage?: SortOrder
    isActive?: SortOrder
    description?: SortOrder
    minAmount?: SortOrder
    maxDiscount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DiscountRuleAvgOrderByAggregateInput = {
    value?: SortOrder
    minAmount?: SortOrder
    maxDiscount?: SortOrder
  }

  export type DiscountRuleMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    value?: SortOrder
    isPercentage?: SortOrder
    isActive?: SortOrder
    description?: SortOrder
    minAmount?: SortOrder
    maxDiscount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DiscountRuleMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    value?: SortOrder
    isPercentage?: SortOrder
    isActive?: SortOrder
    description?: SortOrder
    minAmount?: SortOrder
    maxDiscount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DiscountRuleSumOrderByAggregateInput = {
    value?: SortOrder
    minAmount?: SortOrder
    maxDiscount?: SortOrder
  }

  export type EnumDiscountTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DiscountType | EnumDiscountTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DiscountType[] | ListEnumDiscountTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DiscountType[] | ListEnumDiscountTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDiscountTypeWithAggregatesFilter<$PrismaModel> | $Enums.DiscountType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDiscountTypeFilter<$PrismaModel>
    _max?: NestedEnumDiscountTypeFilter<$PrismaModel>
  }

  export type DiscountRuleScalarRelationFilter = {
    is?: DiscountRuleWhereInput
    isNot?: DiscountRuleWhereInput
  }

  export type VisitDiscountCountOrderByAggregateInput = {
    id?: SortOrder
    visitId?: SortOrder
    discountRuleId?: SortOrder
    discountAmount?: SortOrder
    createdAt?: SortOrder
  }

  export type VisitDiscountAvgOrderByAggregateInput = {
    discountAmount?: SortOrder
  }

  export type VisitDiscountMaxOrderByAggregateInput = {
    id?: SortOrder
    visitId?: SortOrder
    discountRuleId?: SortOrder
    discountAmount?: SortOrder
    createdAt?: SortOrder
  }

  export type VisitDiscountMinOrderByAggregateInput = {
    id?: SortOrder
    visitId?: SortOrder
    discountRuleId?: SortOrder
    discountAmount?: SortOrder
    createdAt?: SortOrder
  }

  export type VisitDiscountSumOrderByAggregateInput = {
    discountAmount?: SortOrder
  }

  export type CustomerDiscountCountOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    discountRuleId?: SortOrder
    usedAt?: SortOrder
    discountAmount?: SortOrder
  }

  export type CustomerDiscountAvgOrderByAggregateInput = {
    discountAmount?: SortOrder
  }

  export type CustomerDiscountMaxOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    discountRuleId?: SortOrder
    usedAt?: SortOrder
    discountAmount?: SortOrder
  }

  export type CustomerDiscountMinOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    discountRuleId?: SortOrder
    usedAt?: SortOrder
    discountAmount?: SortOrder
  }

  export type CustomerDiscountSumOrderByAggregateInput = {
    discountAmount?: SortOrder
  }

  export type VisitCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<VisitCreateWithoutCreatedByInput, VisitUncheckedCreateWithoutCreatedByInput> | VisitCreateWithoutCreatedByInput[] | VisitUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: VisitCreateOrConnectWithoutCreatedByInput | VisitCreateOrConnectWithoutCreatedByInput[]
    createMany?: VisitCreateManyCreatedByInputEnvelope
    connect?: VisitWhereUniqueInput | VisitWhereUniqueInput[]
  }

  export type VisitStaffCreateNestedManyWithoutStaffInput = {
    create?: XOR<VisitStaffCreateWithoutStaffInput, VisitStaffUncheckedCreateWithoutStaffInput> | VisitStaffCreateWithoutStaffInput[] | VisitStaffUncheckedCreateWithoutStaffInput[]
    connectOrCreate?: VisitStaffCreateOrConnectWithoutStaffInput | VisitStaffCreateOrConnectWithoutStaffInput[]
    createMany?: VisitStaffCreateManyStaffInputEnvelope
    connect?: VisitStaffWhereUniqueInput | VisitStaffWhereUniqueInput[]
  }

  export type VisitUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<VisitCreateWithoutCreatedByInput, VisitUncheckedCreateWithoutCreatedByInput> | VisitCreateWithoutCreatedByInput[] | VisitUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: VisitCreateOrConnectWithoutCreatedByInput | VisitCreateOrConnectWithoutCreatedByInput[]
    createMany?: VisitCreateManyCreatedByInputEnvelope
    connect?: VisitWhereUniqueInput | VisitWhereUniqueInput[]
  }

  export type VisitStaffUncheckedCreateNestedManyWithoutStaffInput = {
    create?: XOR<VisitStaffCreateWithoutStaffInput, VisitStaffUncheckedCreateWithoutStaffInput> | VisitStaffCreateWithoutStaffInput[] | VisitStaffUncheckedCreateWithoutStaffInput[]
    connectOrCreate?: VisitStaffCreateOrConnectWithoutStaffInput | VisitStaffCreateOrConnectWithoutStaffInput[]
    createMany?: VisitStaffCreateManyStaffInputEnvelope
    connect?: VisitStaffWhereUniqueInput | VisitStaffWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type EnumRoleFieldUpdateOperationsInput = {
    set?: $Enums.Role
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type VisitUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<VisitCreateWithoutCreatedByInput, VisitUncheckedCreateWithoutCreatedByInput> | VisitCreateWithoutCreatedByInput[] | VisitUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: VisitCreateOrConnectWithoutCreatedByInput | VisitCreateOrConnectWithoutCreatedByInput[]
    upsert?: VisitUpsertWithWhereUniqueWithoutCreatedByInput | VisitUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: VisitCreateManyCreatedByInputEnvelope
    set?: VisitWhereUniqueInput | VisitWhereUniqueInput[]
    disconnect?: VisitWhereUniqueInput | VisitWhereUniqueInput[]
    delete?: VisitWhereUniqueInput | VisitWhereUniqueInput[]
    connect?: VisitWhereUniqueInput | VisitWhereUniqueInput[]
    update?: VisitUpdateWithWhereUniqueWithoutCreatedByInput | VisitUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: VisitUpdateManyWithWhereWithoutCreatedByInput | VisitUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: VisitScalarWhereInput | VisitScalarWhereInput[]
  }

  export type VisitStaffUpdateManyWithoutStaffNestedInput = {
    create?: XOR<VisitStaffCreateWithoutStaffInput, VisitStaffUncheckedCreateWithoutStaffInput> | VisitStaffCreateWithoutStaffInput[] | VisitStaffUncheckedCreateWithoutStaffInput[]
    connectOrCreate?: VisitStaffCreateOrConnectWithoutStaffInput | VisitStaffCreateOrConnectWithoutStaffInput[]
    upsert?: VisitStaffUpsertWithWhereUniqueWithoutStaffInput | VisitStaffUpsertWithWhereUniqueWithoutStaffInput[]
    createMany?: VisitStaffCreateManyStaffInputEnvelope
    set?: VisitStaffWhereUniqueInput | VisitStaffWhereUniqueInput[]
    disconnect?: VisitStaffWhereUniqueInput | VisitStaffWhereUniqueInput[]
    delete?: VisitStaffWhereUniqueInput | VisitStaffWhereUniqueInput[]
    connect?: VisitStaffWhereUniqueInput | VisitStaffWhereUniqueInput[]
    update?: VisitStaffUpdateWithWhereUniqueWithoutStaffInput | VisitStaffUpdateWithWhereUniqueWithoutStaffInput[]
    updateMany?: VisitStaffUpdateManyWithWhereWithoutStaffInput | VisitStaffUpdateManyWithWhereWithoutStaffInput[]
    deleteMany?: VisitStaffScalarWhereInput | VisitStaffScalarWhereInput[]
  }

  export type VisitUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<VisitCreateWithoutCreatedByInput, VisitUncheckedCreateWithoutCreatedByInput> | VisitCreateWithoutCreatedByInput[] | VisitUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: VisitCreateOrConnectWithoutCreatedByInput | VisitCreateOrConnectWithoutCreatedByInput[]
    upsert?: VisitUpsertWithWhereUniqueWithoutCreatedByInput | VisitUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: VisitCreateManyCreatedByInputEnvelope
    set?: VisitWhereUniqueInput | VisitWhereUniqueInput[]
    disconnect?: VisitWhereUniqueInput | VisitWhereUniqueInput[]
    delete?: VisitWhereUniqueInput | VisitWhereUniqueInput[]
    connect?: VisitWhereUniqueInput | VisitWhereUniqueInput[]
    update?: VisitUpdateWithWhereUniqueWithoutCreatedByInput | VisitUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: VisitUpdateManyWithWhereWithoutCreatedByInput | VisitUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: VisitScalarWhereInput | VisitScalarWhereInput[]
  }

  export type VisitStaffUncheckedUpdateManyWithoutStaffNestedInput = {
    create?: XOR<VisitStaffCreateWithoutStaffInput, VisitStaffUncheckedCreateWithoutStaffInput> | VisitStaffCreateWithoutStaffInput[] | VisitStaffUncheckedCreateWithoutStaffInput[]
    connectOrCreate?: VisitStaffCreateOrConnectWithoutStaffInput | VisitStaffCreateOrConnectWithoutStaffInput[]
    upsert?: VisitStaffUpsertWithWhereUniqueWithoutStaffInput | VisitStaffUpsertWithWhereUniqueWithoutStaffInput[]
    createMany?: VisitStaffCreateManyStaffInputEnvelope
    set?: VisitStaffWhereUniqueInput | VisitStaffWhereUniqueInput[]
    disconnect?: VisitStaffWhereUniqueInput | VisitStaffWhereUniqueInput[]
    delete?: VisitStaffWhereUniqueInput | VisitStaffWhereUniqueInput[]
    connect?: VisitStaffWhereUniqueInput | VisitStaffWhereUniqueInput[]
    update?: VisitStaffUpdateWithWhereUniqueWithoutStaffInput | VisitStaffUpdateWithWhereUniqueWithoutStaffInput[]
    updateMany?: VisitStaffUpdateManyWithWhereWithoutStaffInput | VisitStaffUpdateManyWithWhereWithoutStaffInput[]
    deleteMany?: VisitStaffScalarWhereInput | VisitStaffScalarWhereInput[]
  }

  export type VisitCreateNestedManyWithoutCustomerInput = {
    create?: XOR<VisitCreateWithoutCustomerInput, VisitUncheckedCreateWithoutCustomerInput> | VisitCreateWithoutCustomerInput[] | VisitUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: VisitCreateOrConnectWithoutCustomerInput | VisitCreateOrConnectWithoutCustomerInput[]
    createMany?: VisitCreateManyCustomerInputEnvelope
    connect?: VisitWhereUniqueInput | VisitWhereUniqueInput[]
  }

  export type CustomerDiscountCreateNestedManyWithoutCustomerInput = {
    create?: XOR<CustomerDiscountCreateWithoutCustomerInput, CustomerDiscountUncheckedCreateWithoutCustomerInput> | CustomerDiscountCreateWithoutCustomerInput[] | CustomerDiscountUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: CustomerDiscountCreateOrConnectWithoutCustomerInput | CustomerDiscountCreateOrConnectWithoutCustomerInput[]
    createMany?: CustomerDiscountCreateManyCustomerInputEnvelope
    connect?: CustomerDiscountWhereUniqueInput | CustomerDiscountWhereUniqueInput[]
  }

  export type VisitUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<VisitCreateWithoutCustomerInput, VisitUncheckedCreateWithoutCustomerInput> | VisitCreateWithoutCustomerInput[] | VisitUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: VisitCreateOrConnectWithoutCustomerInput | VisitCreateOrConnectWithoutCustomerInput[]
    createMany?: VisitCreateManyCustomerInputEnvelope
    connect?: VisitWhereUniqueInput | VisitWhereUniqueInput[]
  }

  export type CustomerDiscountUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<CustomerDiscountCreateWithoutCustomerInput, CustomerDiscountUncheckedCreateWithoutCustomerInput> | CustomerDiscountCreateWithoutCustomerInput[] | CustomerDiscountUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: CustomerDiscountCreateOrConnectWithoutCustomerInput | CustomerDiscountCreateOrConnectWithoutCustomerInput[]
    createMany?: CustomerDiscountCreateManyCustomerInputEnvelope
    connect?: CustomerDiscountWhereUniqueInput | CustomerDiscountWhereUniqueInput[]
  }

  export type EnumGenderFieldUpdateOperationsInput = {
    set?: $Enums.Gender
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type VisitUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<VisitCreateWithoutCustomerInput, VisitUncheckedCreateWithoutCustomerInput> | VisitCreateWithoutCustomerInput[] | VisitUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: VisitCreateOrConnectWithoutCustomerInput | VisitCreateOrConnectWithoutCustomerInput[]
    upsert?: VisitUpsertWithWhereUniqueWithoutCustomerInput | VisitUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: VisitCreateManyCustomerInputEnvelope
    set?: VisitWhereUniqueInput | VisitWhereUniqueInput[]
    disconnect?: VisitWhereUniqueInput | VisitWhereUniqueInput[]
    delete?: VisitWhereUniqueInput | VisitWhereUniqueInput[]
    connect?: VisitWhereUniqueInput | VisitWhereUniqueInput[]
    update?: VisitUpdateWithWhereUniqueWithoutCustomerInput | VisitUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: VisitUpdateManyWithWhereWithoutCustomerInput | VisitUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: VisitScalarWhereInput | VisitScalarWhereInput[]
  }

  export type CustomerDiscountUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<CustomerDiscountCreateWithoutCustomerInput, CustomerDiscountUncheckedCreateWithoutCustomerInput> | CustomerDiscountCreateWithoutCustomerInput[] | CustomerDiscountUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: CustomerDiscountCreateOrConnectWithoutCustomerInput | CustomerDiscountCreateOrConnectWithoutCustomerInput[]
    upsert?: CustomerDiscountUpsertWithWhereUniqueWithoutCustomerInput | CustomerDiscountUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: CustomerDiscountCreateManyCustomerInputEnvelope
    set?: CustomerDiscountWhereUniqueInput | CustomerDiscountWhereUniqueInput[]
    disconnect?: CustomerDiscountWhereUniqueInput | CustomerDiscountWhereUniqueInput[]
    delete?: CustomerDiscountWhereUniqueInput | CustomerDiscountWhereUniqueInput[]
    connect?: CustomerDiscountWhereUniqueInput | CustomerDiscountWhereUniqueInput[]
    update?: CustomerDiscountUpdateWithWhereUniqueWithoutCustomerInput | CustomerDiscountUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: CustomerDiscountUpdateManyWithWhereWithoutCustomerInput | CustomerDiscountUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: CustomerDiscountScalarWhereInput | CustomerDiscountScalarWhereInput[]
  }

  export type VisitUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<VisitCreateWithoutCustomerInput, VisitUncheckedCreateWithoutCustomerInput> | VisitCreateWithoutCustomerInput[] | VisitUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: VisitCreateOrConnectWithoutCustomerInput | VisitCreateOrConnectWithoutCustomerInput[]
    upsert?: VisitUpsertWithWhereUniqueWithoutCustomerInput | VisitUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: VisitCreateManyCustomerInputEnvelope
    set?: VisitWhereUniqueInput | VisitWhereUniqueInput[]
    disconnect?: VisitWhereUniqueInput | VisitWhereUniqueInput[]
    delete?: VisitWhereUniqueInput | VisitWhereUniqueInput[]
    connect?: VisitWhereUniqueInput | VisitWhereUniqueInput[]
    update?: VisitUpdateWithWhereUniqueWithoutCustomerInput | VisitUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: VisitUpdateManyWithWhereWithoutCustomerInput | VisitUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: VisitScalarWhereInput | VisitScalarWhereInput[]
  }

  export type CustomerDiscountUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<CustomerDiscountCreateWithoutCustomerInput, CustomerDiscountUncheckedCreateWithoutCustomerInput> | CustomerDiscountCreateWithoutCustomerInput[] | CustomerDiscountUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: CustomerDiscountCreateOrConnectWithoutCustomerInput | CustomerDiscountCreateOrConnectWithoutCustomerInput[]
    upsert?: CustomerDiscountUpsertWithWhereUniqueWithoutCustomerInput | CustomerDiscountUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: CustomerDiscountCreateManyCustomerInputEnvelope
    set?: CustomerDiscountWhereUniqueInput | CustomerDiscountWhereUniqueInput[]
    disconnect?: CustomerDiscountWhereUniqueInput | CustomerDiscountWhereUniqueInput[]
    delete?: CustomerDiscountWhereUniqueInput | CustomerDiscountWhereUniqueInput[]
    connect?: CustomerDiscountWhereUniqueInput | CustomerDiscountWhereUniqueInput[]
    update?: CustomerDiscountUpdateWithWhereUniqueWithoutCustomerInput | CustomerDiscountUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: CustomerDiscountUpdateManyWithWhereWithoutCustomerInput | CustomerDiscountUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: CustomerDiscountScalarWhereInput | CustomerDiscountScalarWhereInput[]
  }

  export type VisitServiceCreateNestedManyWithoutServiceInput = {
    create?: XOR<VisitServiceCreateWithoutServiceInput, VisitServiceUncheckedCreateWithoutServiceInput> | VisitServiceCreateWithoutServiceInput[] | VisitServiceUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: VisitServiceCreateOrConnectWithoutServiceInput | VisitServiceCreateOrConnectWithoutServiceInput[]
    createMany?: VisitServiceCreateManyServiceInputEnvelope
    connect?: VisitServiceWhereUniqueInput | VisitServiceWhereUniqueInput[]
  }

  export type VisitServiceUncheckedCreateNestedManyWithoutServiceInput = {
    create?: XOR<VisitServiceCreateWithoutServiceInput, VisitServiceUncheckedCreateWithoutServiceInput> | VisitServiceCreateWithoutServiceInput[] | VisitServiceUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: VisitServiceCreateOrConnectWithoutServiceInput | VisitServiceCreateOrConnectWithoutServiceInput[]
    createMany?: VisitServiceCreateManyServiceInputEnvelope
    connect?: VisitServiceWhereUniqueInput | VisitServiceWhereUniqueInput[]
  }

  export type EnumServiceCategoryFieldUpdateOperationsInput = {
    set?: $Enums.ServiceCategory
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type VisitServiceUpdateManyWithoutServiceNestedInput = {
    create?: XOR<VisitServiceCreateWithoutServiceInput, VisitServiceUncheckedCreateWithoutServiceInput> | VisitServiceCreateWithoutServiceInput[] | VisitServiceUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: VisitServiceCreateOrConnectWithoutServiceInput | VisitServiceCreateOrConnectWithoutServiceInput[]
    upsert?: VisitServiceUpsertWithWhereUniqueWithoutServiceInput | VisitServiceUpsertWithWhereUniqueWithoutServiceInput[]
    createMany?: VisitServiceCreateManyServiceInputEnvelope
    set?: VisitServiceWhereUniqueInput | VisitServiceWhereUniqueInput[]
    disconnect?: VisitServiceWhereUniqueInput | VisitServiceWhereUniqueInput[]
    delete?: VisitServiceWhereUniqueInput | VisitServiceWhereUniqueInput[]
    connect?: VisitServiceWhereUniqueInput | VisitServiceWhereUniqueInput[]
    update?: VisitServiceUpdateWithWhereUniqueWithoutServiceInput | VisitServiceUpdateWithWhereUniqueWithoutServiceInput[]
    updateMany?: VisitServiceUpdateManyWithWhereWithoutServiceInput | VisitServiceUpdateManyWithWhereWithoutServiceInput[]
    deleteMany?: VisitServiceScalarWhereInput | VisitServiceScalarWhereInput[]
  }

  export type VisitServiceUncheckedUpdateManyWithoutServiceNestedInput = {
    create?: XOR<VisitServiceCreateWithoutServiceInput, VisitServiceUncheckedCreateWithoutServiceInput> | VisitServiceCreateWithoutServiceInput[] | VisitServiceUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: VisitServiceCreateOrConnectWithoutServiceInput | VisitServiceCreateOrConnectWithoutServiceInput[]
    upsert?: VisitServiceUpsertWithWhereUniqueWithoutServiceInput | VisitServiceUpsertWithWhereUniqueWithoutServiceInput[]
    createMany?: VisitServiceCreateManyServiceInputEnvelope
    set?: VisitServiceWhereUniqueInput | VisitServiceWhereUniqueInput[]
    disconnect?: VisitServiceWhereUniqueInput | VisitServiceWhereUniqueInput[]
    delete?: VisitServiceWhereUniqueInput | VisitServiceWhereUniqueInput[]
    connect?: VisitServiceWhereUniqueInput | VisitServiceWhereUniqueInput[]
    update?: VisitServiceUpdateWithWhereUniqueWithoutServiceInput | VisitServiceUpdateWithWhereUniqueWithoutServiceInput[]
    updateMany?: VisitServiceUpdateManyWithWhereWithoutServiceInput | VisitServiceUpdateManyWithWhereWithoutServiceInput[]
    deleteMany?: VisitServiceScalarWhereInput | VisitServiceScalarWhereInput[]
  }

  export type CustomerCreateNestedOneWithoutVisitsInput = {
    create?: XOR<CustomerCreateWithoutVisitsInput, CustomerUncheckedCreateWithoutVisitsInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutVisitsInput
    connect?: CustomerWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutVisitsInput = {
    create?: XOR<UserCreateWithoutVisitsInput, UserUncheckedCreateWithoutVisitsInput>
    connectOrCreate?: UserCreateOrConnectWithoutVisitsInput
    connect?: UserWhereUniqueInput
  }

  export type VisitServiceCreateNestedManyWithoutVisitInput = {
    create?: XOR<VisitServiceCreateWithoutVisitInput, VisitServiceUncheckedCreateWithoutVisitInput> | VisitServiceCreateWithoutVisitInput[] | VisitServiceUncheckedCreateWithoutVisitInput[]
    connectOrCreate?: VisitServiceCreateOrConnectWithoutVisitInput | VisitServiceCreateOrConnectWithoutVisitInput[]
    createMany?: VisitServiceCreateManyVisitInputEnvelope
    connect?: VisitServiceWhereUniqueInput | VisitServiceWhereUniqueInput[]
  }

  export type VisitStaffCreateNestedManyWithoutVisitInput = {
    create?: XOR<VisitStaffCreateWithoutVisitInput, VisitStaffUncheckedCreateWithoutVisitInput> | VisitStaffCreateWithoutVisitInput[] | VisitStaffUncheckedCreateWithoutVisitInput[]
    connectOrCreate?: VisitStaffCreateOrConnectWithoutVisitInput | VisitStaffCreateOrConnectWithoutVisitInput[]
    createMany?: VisitStaffCreateManyVisitInputEnvelope
    connect?: VisitStaffWhereUniqueInput | VisitStaffWhereUniqueInput[]
  }

  export type VisitDiscountCreateNestedManyWithoutVisitInput = {
    create?: XOR<VisitDiscountCreateWithoutVisitInput, VisitDiscountUncheckedCreateWithoutVisitInput> | VisitDiscountCreateWithoutVisitInput[] | VisitDiscountUncheckedCreateWithoutVisitInput[]
    connectOrCreate?: VisitDiscountCreateOrConnectWithoutVisitInput | VisitDiscountCreateOrConnectWithoutVisitInput[]
    createMany?: VisitDiscountCreateManyVisitInputEnvelope
    connect?: VisitDiscountWhereUniqueInput | VisitDiscountWhereUniqueInput[]
  }

  export type VisitServiceUncheckedCreateNestedManyWithoutVisitInput = {
    create?: XOR<VisitServiceCreateWithoutVisitInput, VisitServiceUncheckedCreateWithoutVisitInput> | VisitServiceCreateWithoutVisitInput[] | VisitServiceUncheckedCreateWithoutVisitInput[]
    connectOrCreate?: VisitServiceCreateOrConnectWithoutVisitInput | VisitServiceCreateOrConnectWithoutVisitInput[]
    createMany?: VisitServiceCreateManyVisitInputEnvelope
    connect?: VisitServiceWhereUniqueInput | VisitServiceWhereUniqueInput[]
  }

  export type VisitStaffUncheckedCreateNestedManyWithoutVisitInput = {
    create?: XOR<VisitStaffCreateWithoutVisitInput, VisitStaffUncheckedCreateWithoutVisitInput> | VisitStaffCreateWithoutVisitInput[] | VisitStaffUncheckedCreateWithoutVisitInput[]
    connectOrCreate?: VisitStaffCreateOrConnectWithoutVisitInput | VisitStaffCreateOrConnectWithoutVisitInput[]
    createMany?: VisitStaffCreateManyVisitInputEnvelope
    connect?: VisitStaffWhereUniqueInput | VisitStaffWhereUniqueInput[]
  }

  export type VisitDiscountUncheckedCreateNestedManyWithoutVisitInput = {
    create?: XOR<VisitDiscountCreateWithoutVisitInput, VisitDiscountUncheckedCreateWithoutVisitInput> | VisitDiscountCreateWithoutVisitInput[] | VisitDiscountUncheckedCreateWithoutVisitInput[]
    connectOrCreate?: VisitDiscountCreateOrConnectWithoutVisitInput | VisitDiscountCreateOrConnectWithoutVisitInput[]
    createMany?: VisitDiscountCreateManyVisitInputEnvelope
    connect?: VisitDiscountWhereUniqueInput | VisitDiscountWhereUniqueInput[]
  }

  export type CustomerUpdateOneRequiredWithoutVisitsNestedInput = {
    create?: XOR<CustomerCreateWithoutVisitsInput, CustomerUncheckedCreateWithoutVisitsInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutVisitsInput
    upsert?: CustomerUpsertWithoutVisitsInput
    connect?: CustomerWhereUniqueInput
    update?: XOR<XOR<CustomerUpdateToOneWithWhereWithoutVisitsInput, CustomerUpdateWithoutVisitsInput>, CustomerUncheckedUpdateWithoutVisitsInput>
  }

  export type UserUpdateOneRequiredWithoutVisitsNestedInput = {
    create?: XOR<UserCreateWithoutVisitsInput, UserUncheckedCreateWithoutVisitsInput>
    connectOrCreate?: UserCreateOrConnectWithoutVisitsInput
    upsert?: UserUpsertWithoutVisitsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutVisitsInput, UserUpdateWithoutVisitsInput>, UserUncheckedUpdateWithoutVisitsInput>
  }

  export type VisitServiceUpdateManyWithoutVisitNestedInput = {
    create?: XOR<VisitServiceCreateWithoutVisitInput, VisitServiceUncheckedCreateWithoutVisitInput> | VisitServiceCreateWithoutVisitInput[] | VisitServiceUncheckedCreateWithoutVisitInput[]
    connectOrCreate?: VisitServiceCreateOrConnectWithoutVisitInput | VisitServiceCreateOrConnectWithoutVisitInput[]
    upsert?: VisitServiceUpsertWithWhereUniqueWithoutVisitInput | VisitServiceUpsertWithWhereUniqueWithoutVisitInput[]
    createMany?: VisitServiceCreateManyVisitInputEnvelope
    set?: VisitServiceWhereUniqueInput | VisitServiceWhereUniqueInput[]
    disconnect?: VisitServiceWhereUniqueInput | VisitServiceWhereUniqueInput[]
    delete?: VisitServiceWhereUniqueInput | VisitServiceWhereUniqueInput[]
    connect?: VisitServiceWhereUniqueInput | VisitServiceWhereUniqueInput[]
    update?: VisitServiceUpdateWithWhereUniqueWithoutVisitInput | VisitServiceUpdateWithWhereUniqueWithoutVisitInput[]
    updateMany?: VisitServiceUpdateManyWithWhereWithoutVisitInput | VisitServiceUpdateManyWithWhereWithoutVisitInput[]
    deleteMany?: VisitServiceScalarWhereInput | VisitServiceScalarWhereInput[]
  }

  export type VisitStaffUpdateManyWithoutVisitNestedInput = {
    create?: XOR<VisitStaffCreateWithoutVisitInput, VisitStaffUncheckedCreateWithoutVisitInput> | VisitStaffCreateWithoutVisitInput[] | VisitStaffUncheckedCreateWithoutVisitInput[]
    connectOrCreate?: VisitStaffCreateOrConnectWithoutVisitInput | VisitStaffCreateOrConnectWithoutVisitInput[]
    upsert?: VisitStaffUpsertWithWhereUniqueWithoutVisitInput | VisitStaffUpsertWithWhereUniqueWithoutVisitInput[]
    createMany?: VisitStaffCreateManyVisitInputEnvelope
    set?: VisitStaffWhereUniqueInput | VisitStaffWhereUniqueInput[]
    disconnect?: VisitStaffWhereUniqueInput | VisitStaffWhereUniqueInput[]
    delete?: VisitStaffWhereUniqueInput | VisitStaffWhereUniqueInput[]
    connect?: VisitStaffWhereUniqueInput | VisitStaffWhereUniqueInput[]
    update?: VisitStaffUpdateWithWhereUniqueWithoutVisitInput | VisitStaffUpdateWithWhereUniqueWithoutVisitInput[]
    updateMany?: VisitStaffUpdateManyWithWhereWithoutVisitInput | VisitStaffUpdateManyWithWhereWithoutVisitInput[]
    deleteMany?: VisitStaffScalarWhereInput | VisitStaffScalarWhereInput[]
  }

  export type VisitDiscountUpdateManyWithoutVisitNestedInput = {
    create?: XOR<VisitDiscountCreateWithoutVisitInput, VisitDiscountUncheckedCreateWithoutVisitInput> | VisitDiscountCreateWithoutVisitInput[] | VisitDiscountUncheckedCreateWithoutVisitInput[]
    connectOrCreate?: VisitDiscountCreateOrConnectWithoutVisitInput | VisitDiscountCreateOrConnectWithoutVisitInput[]
    upsert?: VisitDiscountUpsertWithWhereUniqueWithoutVisitInput | VisitDiscountUpsertWithWhereUniqueWithoutVisitInput[]
    createMany?: VisitDiscountCreateManyVisitInputEnvelope
    set?: VisitDiscountWhereUniqueInput | VisitDiscountWhereUniqueInput[]
    disconnect?: VisitDiscountWhereUniqueInput | VisitDiscountWhereUniqueInput[]
    delete?: VisitDiscountWhereUniqueInput | VisitDiscountWhereUniqueInput[]
    connect?: VisitDiscountWhereUniqueInput | VisitDiscountWhereUniqueInput[]
    update?: VisitDiscountUpdateWithWhereUniqueWithoutVisitInput | VisitDiscountUpdateWithWhereUniqueWithoutVisitInput[]
    updateMany?: VisitDiscountUpdateManyWithWhereWithoutVisitInput | VisitDiscountUpdateManyWithWhereWithoutVisitInput[]
    deleteMany?: VisitDiscountScalarWhereInput | VisitDiscountScalarWhereInput[]
  }

  export type VisitServiceUncheckedUpdateManyWithoutVisitNestedInput = {
    create?: XOR<VisitServiceCreateWithoutVisitInput, VisitServiceUncheckedCreateWithoutVisitInput> | VisitServiceCreateWithoutVisitInput[] | VisitServiceUncheckedCreateWithoutVisitInput[]
    connectOrCreate?: VisitServiceCreateOrConnectWithoutVisitInput | VisitServiceCreateOrConnectWithoutVisitInput[]
    upsert?: VisitServiceUpsertWithWhereUniqueWithoutVisitInput | VisitServiceUpsertWithWhereUniqueWithoutVisitInput[]
    createMany?: VisitServiceCreateManyVisitInputEnvelope
    set?: VisitServiceWhereUniqueInput | VisitServiceWhereUniqueInput[]
    disconnect?: VisitServiceWhereUniqueInput | VisitServiceWhereUniqueInput[]
    delete?: VisitServiceWhereUniqueInput | VisitServiceWhereUniqueInput[]
    connect?: VisitServiceWhereUniqueInput | VisitServiceWhereUniqueInput[]
    update?: VisitServiceUpdateWithWhereUniqueWithoutVisitInput | VisitServiceUpdateWithWhereUniqueWithoutVisitInput[]
    updateMany?: VisitServiceUpdateManyWithWhereWithoutVisitInput | VisitServiceUpdateManyWithWhereWithoutVisitInput[]
    deleteMany?: VisitServiceScalarWhereInput | VisitServiceScalarWhereInput[]
  }

  export type VisitStaffUncheckedUpdateManyWithoutVisitNestedInput = {
    create?: XOR<VisitStaffCreateWithoutVisitInput, VisitStaffUncheckedCreateWithoutVisitInput> | VisitStaffCreateWithoutVisitInput[] | VisitStaffUncheckedCreateWithoutVisitInput[]
    connectOrCreate?: VisitStaffCreateOrConnectWithoutVisitInput | VisitStaffCreateOrConnectWithoutVisitInput[]
    upsert?: VisitStaffUpsertWithWhereUniqueWithoutVisitInput | VisitStaffUpsertWithWhereUniqueWithoutVisitInput[]
    createMany?: VisitStaffCreateManyVisitInputEnvelope
    set?: VisitStaffWhereUniqueInput | VisitStaffWhereUniqueInput[]
    disconnect?: VisitStaffWhereUniqueInput | VisitStaffWhereUniqueInput[]
    delete?: VisitStaffWhereUniqueInput | VisitStaffWhereUniqueInput[]
    connect?: VisitStaffWhereUniqueInput | VisitStaffWhereUniqueInput[]
    update?: VisitStaffUpdateWithWhereUniqueWithoutVisitInput | VisitStaffUpdateWithWhereUniqueWithoutVisitInput[]
    updateMany?: VisitStaffUpdateManyWithWhereWithoutVisitInput | VisitStaffUpdateManyWithWhereWithoutVisitInput[]
    deleteMany?: VisitStaffScalarWhereInput | VisitStaffScalarWhereInput[]
  }

  export type VisitDiscountUncheckedUpdateManyWithoutVisitNestedInput = {
    create?: XOR<VisitDiscountCreateWithoutVisitInput, VisitDiscountUncheckedCreateWithoutVisitInput> | VisitDiscountCreateWithoutVisitInput[] | VisitDiscountUncheckedCreateWithoutVisitInput[]
    connectOrCreate?: VisitDiscountCreateOrConnectWithoutVisitInput | VisitDiscountCreateOrConnectWithoutVisitInput[]
    upsert?: VisitDiscountUpsertWithWhereUniqueWithoutVisitInput | VisitDiscountUpsertWithWhereUniqueWithoutVisitInput[]
    createMany?: VisitDiscountCreateManyVisitInputEnvelope
    set?: VisitDiscountWhereUniqueInput | VisitDiscountWhereUniqueInput[]
    disconnect?: VisitDiscountWhereUniqueInput | VisitDiscountWhereUniqueInput[]
    delete?: VisitDiscountWhereUniqueInput | VisitDiscountWhereUniqueInput[]
    connect?: VisitDiscountWhereUniqueInput | VisitDiscountWhereUniqueInput[]
    update?: VisitDiscountUpdateWithWhereUniqueWithoutVisitInput | VisitDiscountUpdateWithWhereUniqueWithoutVisitInput[]
    updateMany?: VisitDiscountUpdateManyWithWhereWithoutVisitInput | VisitDiscountUpdateManyWithWhereWithoutVisitInput[]
    deleteMany?: VisitDiscountScalarWhereInput | VisitDiscountScalarWhereInput[]
  }

  export type VisitCreateNestedOneWithoutServicesInput = {
    create?: XOR<VisitCreateWithoutServicesInput, VisitUncheckedCreateWithoutServicesInput>
    connectOrCreate?: VisitCreateOrConnectWithoutServicesInput
    connect?: VisitWhereUniqueInput
  }

  export type ServiceCreateNestedOneWithoutVisitServicesInput = {
    create?: XOR<ServiceCreateWithoutVisitServicesInput, ServiceUncheckedCreateWithoutVisitServicesInput>
    connectOrCreate?: ServiceCreateOrConnectWithoutVisitServicesInput
    connect?: ServiceWhereUniqueInput
  }

  export type VisitUpdateOneRequiredWithoutServicesNestedInput = {
    create?: XOR<VisitCreateWithoutServicesInput, VisitUncheckedCreateWithoutServicesInput>
    connectOrCreate?: VisitCreateOrConnectWithoutServicesInput
    upsert?: VisitUpsertWithoutServicesInput
    connect?: VisitWhereUniqueInput
    update?: XOR<XOR<VisitUpdateToOneWithWhereWithoutServicesInput, VisitUpdateWithoutServicesInput>, VisitUncheckedUpdateWithoutServicesInput>
  }

  export type ServiceUpdateOneRequiredWithoutVisitServicesNestedInput = {
    create?: XOR<ServiceCreateWithoutVisitServicesInput, ServiceUncheckedCreateWithoutVisitServicesInput>
    connectOrCreate?: ServiceCreateOrConnectWithoutVisitServicesInput
    upsert?: ServiceUpsertWithoutVisitServicesInput
    connect?: ServiceWhereUniqueInput
    update?: XOR<XOR<ServiceUpdateToOneWithWhereWithoutVisitServicesInput, ServiceUpdateWithoutVisitServicesInput>, ServiceUncheckedUpdateWithoutVisitServicesInput>
  }

  export type VisitCreateNestedOneWithoutStaffInput = {
    create?: XOR<VisitCreateWithoutStaffInput, VisitUncheckedCreateWithoutStaffInput>
    connectOrCreate?: VisitCreateOrConnectWithoutStaffInput
    connect?: VisitWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutStaffVisitsInput = {
    create?: XOR<UserCreateWithoutStaffVisitsInput, UserUncheckedCreateWithoutStaffVisitsInput>
    connectOrCreate?: UserCreateOrConnectWithoutStaffVisitsInput
    connect?: UserWhereUniqueInput
  }

  export type VisitUpdateOneRequiredWithoutStaffNestedInput = {
    create?: XOR<VisitCreateWithoutStaffInput, VisitUncheckedCreateWithoutStaffInput>
    connectOrCreate?: VisitCreateOrConnectWithoutStaffInput
    upsert?: VisitUpsertWithoutStaffInput
    connect?: VisitWhereUniqueInput
    update?: XOR<XOR<VisitUpdateToOneWithWhereWithoutStaffInput, VisitUpdateWithoutStaffInput>, VisitUncheckedUpdateWithoutStaffInput>
  }

  export type UserUpdateOneRequiredWithoutStaffVisitsNestedInput = {
    create?: XOR<UserCreateWithoutStaffVisitsInput, UserUncheckedCreateWithoutStaffVisitsInput>
    connectOrCreate?: UserCreateOrConnectWithoutStaffVisitsInput
    upsert?: UserUpsertWithoutStaffVisitsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutStaffVisitsInput, UserUpdateWithoutStaffVisitsInput>, UserUncheckedUpdateWithoutStaffVisitsInput>
  }

  export type VisitDiscountCreateNestedManyWithoutDiscountRuleInput = {
    create?: XOR<VisitDiscountCreateWithoutDiscountRuleInput, VisitDiscountUncheckedCreateWithoutDiscountRuleInput> | VisitDiscountCreateWithoutDiscountRuleInput[] | VisitDiscountUncheckedCreateWithoutDiscountRuleInput[]
    connectOrCreate?: VisitDiscountCreateOrConnectWithoutDiscountRuleInput | VisitDiscountCreateOrConnectWithoutDiscountRuleInput[]
    createMany?: VisitDiscountCreateManyDiscountRuleInputEnvelope
    connect?: VisitDiscountWhereUniqueInput | VisitDiscountWhereUniqueInput[]
  }

  export type CustomerDiscountCreateNestedManyWithoutDiscountRuleInput = {
    create?: XOR<CustomerDiscountCreateWithoutDiscountRuleInput, CustomerDiscountUncheckedCreateWithoutDiscountRuleInput> | CustomerDiscountCreateWithoutDiscountRuleInput[] | CustomerDiscountUncheckedCreateWithoutDiscountRuleInput[]
    connectOrCreate?: CustomerDiscountCreateOrConnectWithoutDiscountRuleInput | CustomerDiscountCreateOrConnectWithoutDiscountRuleInput[]
    createMany?: CustomerDiscountCreateManyDiscountRuleInputEnvelope
    connect?: CustomerDiscountWhereUniqueInput | CustomerDiscountWhereUniqueInput[]
  }

  export type VisitDiscountUncheckedCreateNestedManyWithoutDiscountRuleInput = {
    create?: XOR<VisitDiscountCreateWithoutDiscountRuleInput, VisitDiscountUncheckedCreateWithoutDiscountRuleInput> | VisitDiscountCreateWithoutDiscountRuleInput[] | VisitDiscountUncheckedCreateWithoutDiscountRuleInput[]
    connectOrCreate?: VisitDiscountCreateOrConnectWithoutDiscountRuleInput | VisitDiscountCreateOrConnectWithoutDiscountRuleInput[]
    createMany?: VisitDiscountCreateManyDiscountRuleInputEnvelope
    connect?: VisitDiscountWhereUniqueInput | VisitDiscountWhereUniqueInput[]
  }

  export type CustomerDiscountUncheckedCreateNestedManyWithoutDiscountRuleInput = {
    create?: XOR<CustomerDiscountCreateWithoutDiscountRuleInput, CustomerDiscountUncheckedCreateWithoutDiscountRuleInput> | CustomerDiscountCreateWithoutDiscountRuleInput[] | CustomerDiscountUncheckedCreateWithoutDiscountRuleInput[]
    connectOrCreate?: CustomerDiscountCreateOrConnectWithoutDiscountRuleInput | CustomerDiscountCreateOrConnectWithoutDiscountRuleInput[]
    createMany?: CustomerDiscountCreateManyDiscountRuleInputEnvelope
    connect?: CustomerDiscountWhereUniqueInput | CustomerDiscountWhereUniqueInput[]
  }

  export type EnumDiscountTypeFieldUpdateOperationsInput = {
    set?: $Enums.DiscountType
  }

  export type VisitDiscountUpdateManyWithoutDiscountRuleNestedInput = {
    create?: XOR<VisitDiscountCreateWithoutDiscountRuleInput, VisitDiscountUncheckedCreateWithoutDiscountRuleInput> | VisitDiscountCreateWithoutDiscountRuleInput[] | VisitDiscountUncheckedCreateWithoutDiscountRuleInput[]
    connectOrCreate?: VisitDiscountCreateOrConnectWithoutDiscountRuleInput | VisitDiscountCreateOrConnectWithoutDiscountRuleInput[]
    upsert?: VisitDiscountUpsertWithWhereUniqueWithoutDiscountRuleInput | VisitDiscountUpsertWithWhereUniqueWithoutDiscountRuleInput[]
    createMany?: VisitDiscountCreateManyDiscountRuleInputEnvelope
    set?: VisitDiscountWhereUniqueInput | VisitDiscountWhereUniqueInput[]
    disconnect?: VisitDiscountWhereUniqueInput | VisitDiscountWhereUniqueInput[]
    delete?: VisitDiscountWhereUniqueInput | VisitDiscountWhereUniqueInput[]
    connect?: VisitDiscountWhereUniqueInput | VisitDiscountWhereUniqueInput[]
    update?: VisitDiscountUpdateWithWhereUniqueWithoutDiscountRuleInput | VisitDiscountUpdateWithWhereUniqueWithoutDiscountRuleInput[]
    updateMany?: VisitDiscountUpdateManyWithWhereWithoutDiscountRuleInput | VisitDiscountUpdateManyWithWhereWithoutDiscountRuleInput[]
    deleteMany?: VisitDiscountScalarWhereInput | VisitDiscountScalarWhereInput[]
  }

  export type CustomerDiscountUpdateManyWithoutDiscountRuleNestedInput = {
    create?: XOR<CustomerDiscountCreateWithoutDiscountRuleInput, CustomerDiscountUncheckedCreateWithoutDiscountRuleInput> | CustomerDiscountCreateWithoutDiscountRuleInput[] | CustomerDiscountUncheckedCreateWithoutDiscountRuleInput[]
    connectOrCreate?: CustomerDiscountCreateOrConnectWithoutDiscountRuleInput | CustomerDiscountCreateOrConnectWithoutDiscountRuleInput[]
    upsert?: CustomerDiscountUpsertWithWhereUniqueWithoutDiscountRuleInput | CustomerDiscountUpsertWithWhereUniqueWithoutDiscountRuleInput[]
    createMany?: CustomerDiscountCreateManyDiscountRuleInputEnvelope
    set?: CustomerDiscountWhereUniqueInput | CustomerDiscountWhereUniqueInput[]
    disconnect?: CustomerDiscountWhereUniqueInput | CustomerDiscountWhereUniqueInput[]
    delete?: CustomerDiscountWhereUniqueInput | CustomerDiscountWhereUniqueInput[]
    connect?: CustomerDiscountWhereUniqueInput | CustomerDiscountWhereUniqueInput[]
    update?: CustomerDiscountUpdateWithWhereUniqueWithoutDiscountRuleInput | CustomerDiscountUpdateWithWhereUniqueWithoutDiscountRuleInput[]
    updateMany?: CustomerDiscountUpdateManyWithWhereWithoutDiscountRuleInput | CustomerDiscountUpdateManyWithWhereWithoutDiscountRuleInput[]
    deleteMany?: CustomerDiscountScalarWhereInput | CustomerDiscountScalarWhereInput[]
  }

  export type VisitDiscountUncheckedUpdateManyWithoutDiscountRuleNestedInput = {
    create?: XOR<VisitDiscountCreateWithoutDiscountRuleInput, VisitDiscountUncheckedCreateWithoutDiscountRuleInput> | VisitDiscountCreateWithoutDiscountRuleInput[] | VisitDiscountUncheckedCreateWithoutDiscountRuleInput[]
    connectOrCreate?: VisitDiscountCreateOrConnectWithoutDiscountRuleInput | VisitDiscountCreateOrConnectWithoutDiscountRuleInput[]
    upsert?: VisitDiscountUpsertWithWhereUniqueWithoutDiscountRuleInput | VisitDiscountUpsertWithWhereUniqueWithoutDiscountRuleInput[]
    createMany?: VisitDiscountCreateManyDiscountRuleInputEnvelope
    set?: VisitDiscountWhereUniqueInput | VisitDiscountWhereUniqueInput[]
    disconnect?: VisitDiscountWhereUniqueInput | VisitDiscountWhereUniqueInput[]
    delete?: VisitDiscountWhereUniqueInput | VisitDiscountWhereUniqueInput[]
    connect?: VisitDiscountWhereUniqueInput | VisitDiscountWhereUniqueInput[]
    update?: VisitDiscountUpdateWithWhereUniqueWithoutDiscountRuleInput | VisitDiscountUpdateWithWhereUniqueWithoutDiscountRuleInput[]
    updateMany?: VisitDiscountUpdateManyWithWhereWithoutDiscountRuleInput | VisitDiscountUpdateManyWithWhereWithoutDiscountRuleInput[]
    deleteMany?: VisitDiscountScalarWhereInput | VisitDiscountScalarWhereInput[]
  }

  export type CustomerDiscountUncheckedUpdateManyWithoutDiscountRuleNestedInput = {
    create?: XOR<CustomerDiscountCreateWithoutDiscountRuleInput, CustomerDiscountUncheckedCreateWithoutDiscountRuleInput> | CustomerDiscountCreateWithoutDiscountRuleInput[] | CustomerDiscountUncheckedCreateWithoutDiscountRuleInput[]
    connectOrCreate?: CustomerDiscountCreateOrConnectWithoutDiscountRuleInput | CustomerDiscountCreateOrConnectWithoutDiscountRuleInput[]
    upsert?: CustomerDiscountUpsertWithWhereUniqueWithoutDiscountRuleInput | CustomerDiscountUpsertWithWhereUniqueWithoutDiscountRuleInput[]
    createMany?: CustomerDiscountCreateManyDiscountRuleInputEnvelope
    set?: CustomerDiscountWhereUniqueInput | CustomerDiscountWhereUniqueInput[]
    disconnect?: CustomerDiscountWhereUniqueInput | CustomerDiscountWhereUniqueInput[]
    delete?: CustomerDiscountWhereUniqueInput | CustomerDiscountWhereUniqueInput[]
    connect?: CustomerDiscountWhereUniqueInput | CustomerDiscountWhereUniqueInput[]
    update?: CustomerDiscountUpdateWithWhereUniqueWithoutDiscountRuleInput | CustomerDiscountUpdateWithWhereUniqueWithoutDiscountRuleInput[]
    updateMany?: CustomerDiscountUpdateManyWithWhereWithoutDiscountRuleInput | CustomerDiscountUpdateManyWithWhereWithoutDiscountRuleInput[]
    deleteMany?: CustomerDiscountScalarWhereInput | CustomerDiscountScalarWhereInput[]
  }

  export type VisitCreateNestedOneWithoutDiscountsInput = {
    create?: XOR<VisitCreateWithoutDiscountsInput, VisitUncheckedCreateWithoutDiscountsInput>
    connectOrCreate?: VisitCreateOrConnectWithoutDiscountsInput
    connect?: VisitWhereUniqueInput
  }

  export type DiscountRuleCreateNestedOneWithoutVisitDiscountsInput = {
    create?: XOR<DiscountRuleCreateWithoutVisitDiscountsInput, DiscountRuleUncheckedCreateWithoutVisitDiscountsInput>
    connectOrCreate?: DiscountRuleCreateOrConnectWithoutVisitDiscountsInput
    connect?: DiscountRuleWhereUniqueInput
  }

  export type VisitUpdateOneRequiredWithoutDiscountsNestedInput = {
    create?: XOR<VisitCreateWithoutDiscountsInput, VisitUncheckedCreateWithoutDiscountsInput>
    connectOrCreate?: VisitCreateOrConnectWithoutDiscountsInput
    upsert?: VisitUpsertWithoutDiscountsInput
    connect?: VisitWhereUniqueInput
    update?: XOR<XOR<VisitUpdateToOneWithWhereWithoutDiscountsInput, VisitUpdateWithoutDiscountsInput>, VisitUncheckedUpdateWithoutDiscountsInput>
  }

  export type DiscountRuleUpdateOneRequiredWithoutVisitDiscountsNestedInput = {
    create?: XOR<DiscountRuleCreateWithoutVisitDiscountsInput, DiscountRuleUncheckedCreateWithoutVisitDiscountsInput>
    connectOrCreate?: DiscountRuleCreateOrConnectWithoutVisitDiscountsInput
    upsert?: DiscountRuleUpsertWithoutVisitDiscountsInput
    connect?: DiscountRuleWhereUniqueInput
    update?: XOR<XOR<DiscountRuleUpdateToOneWithWhereWithoutVisitDiscountsInput, DiscountRuleUpdateWithoutVisitDiscountsInput>, DiscountRuleUncheckedUpdateWithoutVisitDiscountsInput>
  }

  export type CustomerCreateNestedOneWithoutDiscountsInput = {
    create?: XOR<CustomerCreateWithoutDiscountsInput, CustomerUncheckedCreateWithoutDiscountsInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutDiscountsInput
    connect?: CustomerWhereUniqueInput
  }

  export type DiscountRuleCreateNestedOneWithoutCustomerDiscountsInput = {
    create?: XOR<DiscountRuleCreateWithoutCustomerDiscountsInput, DiscountRuleUncheckedCreateWithoutCustomerDiscountsInput>
    connectOrCreate?: DiscountRuleCreateOrConnectWithoutCustomerDiscountsInput
    connect?: DiscountRuleWhereUniqueInput
  }

  export type CustomerUpdateOneRequiredWithoutDiscountsNestedInput = {
    create?: XOR<CustomerCreateWithoutDiscountsInput, CustomerUncheckedCreateWithoutDiscountsInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutDiscountsInput
    upsert?: CustomerUpsertWithoutDiscountsInput
    connect?: CustomerWhereUniqueInput
    update?: XOR<XOR<CustomerUpdateToOneWithWhereWithoutDiscountsInput, CustomerUpdateWithoutDiscountsInput>, CustomerUncheckedUpdateWithoutDiscountsInput>
  }

  export type DiscountRuleUpdateOneRequiredWithoutCustomerDiscountsNestedInput = {
    create?: XOR<DiscountRuleCreateWithoutCustomerDiscountsInput, DiscountRuleUncheckedCreateWithoutCustomerDiscountsInput>
    connectOrCreate?: DiscountRuleCreateOrConnectWithoutCustomerDiscountsInput
    upsert?: DiscountRuleUpsertWithoutCustomerDiscountsInput
    connect?: DiscountRuleWhereUniqueInput
    update?: XOR<XOR<DiscountRuleUpdateToOneWithWhereWithoutCustomerDiscountsInput, DiscountRuleUpdateWithoutCustomerDiscountsInput>, DiscountRuleUncheckedUpdateWithoutCustomerDiscountsInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedEnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedEnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleFilter<$PrismaModel>
    _max?: NestedEnumRoleFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedEnumGenderFilter<$PrismaModel = never> = {
    equals?: $Enums.Gender | EnumGenderFieldRefInput<$PrismaModel>
    in?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel>
    notIn?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel>
    not?: NestedEnumGenderFilter<$PrismaModel> | $Enums.Gender
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedEnumGenderWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Gender | EnumGenderFieldRefInput<$PrismaModel>
    in?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel>
    notIn?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel>
    not?: NestedEnumGenderWithAggregatesFilter<$PrismaModel> | $Enums.Gender
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumGenderFilter<$PrismaModel>
    _max?: NestedEnumGenderFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedEnumServiceCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.ServiceCategory | EnumServiceCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.ServiceCategory[] | ListEnumServiceCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.ServiceCategory[] | ListEnumServiceCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumServiceCategoryFilter<$PrismaModel> | $Enums.ServiceCategory
  }

  export type NestedDecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type NestedEnumServiceCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ServiceCategory | EnumServiceCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.ServiceCategory[] | ListEnumServiceCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.ServiceCategory[] | ListEnumServiceCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumServiceCategoryWithAggregatesFilter<$PrismaModel> | $Enums.ServiceCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumServiceCategoryFilter<$PrismaModel>
    _max?: NestedEnumServiceCategoryFilter<$PrismaModel>
  }

  export type NestedDecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type NestedEnumDiscountTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.DiscountType | EnumDiscountTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DiscountType[] | ListEnumDiscountTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DiscountType[] | ListEnumDiscountTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDiscountTypeFilter<$PrismaModel> | $Enums.DiscountType
  }

  export type NestedEnumDiscountTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DiscountType | EnumDiscountTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DiscountType[] | ListEnumDiscountTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DiscountType[] | ListEnumDiscountTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDiscountTypeWithAggregatesFilter<$PrismaModel> | $Enums.DiscountType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDiscountTypeFilter<$PrismaModel>
    _max?: NestedEnumDiscountTypeFilter<$PrismaModel>
  }

  export type VisitCreateWithoutCreatedByInput = {
    id?: string
    visitDate?: Date | string
    totalAmount: Decimal | DecimalJsLike | number | string
    discountAmount?: Decimal | DecimalJsLike | number | string
    finalAmount: Decimal | DecimalJsLike | number | string
    loyaltyPointsEarned?: number
    notes?: string | null
    isCompleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    customer: CustomerCreateNestedOneWithoutVisitsInput
    services?: VisitServiceCreateNestedManyWithoutVisitInput
    staff?: VisitStaffCreateNestedManyWithoutVisitInput
    discounts?: VisitDiscountCreateNestedManyWithoutVisitInput
  }

  export type VisitUncheckedCreateWithoutCreatedByInput = {
    id?: string
    customerId: string
    visitDate?: Date | string
    totalAmount: Decimal | DecimalJsLike | number | string
    discountAmount?: Decimal | DecimalJsLike | number | string
    finalAmount: Decimal | DecimalJsLike | number | string
    loyaltyPointsEarned?: number
    notes?: string | null
    isCompleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    services?: VisitServiceUncheckedCreateNestedManyWithoutVisitInput
    staff?: VisitStaffUncheckedCreateNestedManyWithoutVisitInput
    discounts?: VisitDiscountUncheckedCreateNestedManyWithoutVisitInput
  }

  export type VisitCreateOrConnectWithoutCreatedByInput = {
    where: VisitWhereUniqueInput
    create: XOR<VisitCreateWithoutCreatedByInput, VisitUncheckedCreateWithoutCreatedByInput>
  }

  export type VisitCreateManyCreatedByInputEnvelope = {
    data: VisitCreateManyCreatedByInput | VisitCreateManyCreatedByInput[]
    skipDuplicates?: boolean
  }

  export type VisitStaffCreateWithoutStaffInput = {
    id?: string
    serviceId?: string | null
    createdAt?: Date | string
    visit: VisitCreateNestedOneWithoutStaffInput
  }

  export type VisitStaffUncheckedCreateWithoutStaffInput = {
    id?: string
    visitId: string
    serviceId?: string | null
    createdAt?: Date | string
  }

  export type VisitStaffCreateOrConnectWithoutStaffInput = {
    where: VisitStaffWhereUniqueInput
    create: XOR<VisitStaffCreateWithoutStaffInput, VisitStaffUncheckedCreateWithoutStaffInput>
  }

  export type VisitStaffCreateManyStaffInputEnvelope = {
    data: VisitStaffCreateManyStaffInput | VisitStaffCreateManyStaffInput[]
    skipDuplicates?: boolean
  }

  export type VisitUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: VisitWhereUniqueInput
    update: XOR<VisitUpdateWithoutCreatedByInput, VisitUncheckedUpdateWithoutCreatedByInput>
    create: XOR<VisitCreateWithoutCreatedByInput, VisitUncheckedCreateWithoutCreatedByInput>
  }

  export type VisitUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: VisitWhereUniqueInput
    data: XOR<VisitUpdateWithoutCreatedByInput, VisitUncheckedUpdateWithoutCreatedByInput>
  }

  export type VisitUpdateManyWithWhereWithoutCreatedByInput = {
    where: VisitScalarWhereInput
    data: XOR<VisitUpdateManyMutationInput, VisitUncheckedUpdateManyWithoutCreatedByInput>
  }

  export type VisitScalarWhereInput = {
    AND?: VisitScalarWhereInput | VisitScalarWhereInput[]
    OR?: VisitScalarWhereInput[]
    NOT?: VisitScalarWhereInput | VisitScalarWhereInput[]
    id?: StringFilter<"Visit"> | string
    customerId?: StringFilter<"Visit"> | string
    visitDate?: DateTimeFilter<"Visit"> | Date | string
    totalAmount?: DecimalFilter<"Visit"> | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFilter<"Visit"> | Decimal | DecimalJsLike | number | string
    finalAmount?: DecimalFilter<"Visit"> | Decimal | DecimalJsLike | number | string
    loyaltyPointsEarned?: IntFilter<"Visit"> | number
    notes?: StringNullableFilter<"Visit"> | string | null
    isCompleted?: BoolFilter<"Visit"> | boolean
    createdById?: StringFilter<"Visit"> | string
    createdAt?: DateTimeFilter<"Visit"> | Date | string
    updatedAt?: DateTimeFilter<"Visit"> | Date | string
  }

  export type VisitStaffUpsertWithWhereUniqueWithoutStaffInput = {
    where: VisitStaffWhereUniqueInput
    update: XOR<VisitStaffUpdateWithoutStaffInput, VisitStaffUncheckedUpdateWithoutStaffInput>
    create: XOR<VisitStaffCreateWithoutStaffInput, VisitStaffUncheckedCreateWithoutStaffInput>
  }

  export type VisitStaffUpdateWithWhereUniqueWithoutStaffInput = {
    where: VisitStaffWhereUniqueInput
    data: XOR<VisitStaffUpdateWithoutStaffInput, VisitStaffUncheckedUpdateWithoutStaffInput>
  }

  export type VisitStaffUpdateManyWithWhereWithoutStaffInput = {
    where: VisitStaffScalarWhereInput
    data: XOR<VisitStaffUpdateManyMutationInput, VisitStaffUncheckedUpdateManyWithoutStaffInput>
  }

  export type VisitStaffScalarWhereInput = {
    AND?: VisitStaffScalarWhereInput | VisitStaffScalarWhereInput[]
    OR?: VisitStaffScalarWhereInput[]
    NOT?: VisitStaffScalarWhereInput | VisitStaffScalarWhereInput[]
    id?: StringFilter<"VisitStaff"> | string
    visitId?: StringFilter<"VisitStaff"> | string
    staffId?: StringFilter<"VisitStaff"> | string
    serviceId?: StringNullableFilter<"VisitStaff"> | string | null
    createdAt?: DateTimeFilter<"VisitStaff"> | Date | string
  }

  export type VisitCreateWithoutCustomerInput = {
    id?: string
    visitDate?: Date | string
    totalAmount: Decimal | DecimalJsLike | number | string
    discountAmount?: Decimal | DecimalJsLike | number | string
    finalAmount: Decimal | DecimalJsLike | number | string
    loyaltyPointsEarned?: number
    notes?: string | null
    isCompleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: UserCreateNestedOneWithoutVisitsInput
    services?: VisitServiceCreateNestedManyWithoutVisitInput
    staff?: VisitStaffCreateNestedManyWithoutVisitInput
    discounts?: VisitDiscountCreateNestedManyWithoutVisitInput
  }

  export type VisitUncheckedCreateWithoutCustomerInput = {
    id?: string
    visitDate?: Date | string
    totalAmount: Decimal | DecimalJsLike | number | string
    discountAmount?: Decimal | DecimalJsLike | number | string
    finalAmount: Decimal | DecimalJsLike | number | string
    loyaltyPointsEarned?: number
    notes?: string | null
    isCompleted?: boolean
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
    services?: VisitServiceUncheckedCreateNestedManyWithoutVisitInput
    staff?: VisitStaffUncheckedCreateNestedManyWithoutVisitInput
    discounts?: VisitDiscountUncheckedCreateNestedManyWithoutVisitInput
  }

  export type VisitCreateOrConnectWithoutCustomerInput = {
    where: VisitWhereUniqueInput
    create: XOR<VisitCreateWithoutCustomerInput, VisitUncheckedCreateWithoutCustomerInput>
  }

  export type VisitCreateManyCustomerInputEnvelope = {
    data: VisitCreateManyCustomerInput | VisitCreateManyCustomerInput[]
    skipDuplicates?: boolean
  }

  export type CustomerDiscountCreateWithoutCustomerInput = {
    id?: string
    usedAt?: Date | string
    discountAmount: Decimal | DecimalJsLike | number | string
    discountRule: DiscountRuleCreateNestedOneWithoutCustomerDiscountsInput
  }

  export type CustomerDiscountUncheckedCreateWithoutCustomerInput = {
    id?: string
    discountRuleId: string
    usedAt?: Date | string
    discountAmount: Decimal | DecimalJsLike | number | string
  }

  export type CustomerDiscountCreateOrConnectWithoutCustomerInput = {
    where: CustomerDiscountWhereUniqueInput
    create: XOR<CustomerDiscountCreateWithoutCustomerInput, CustomerDiscountUncheckedCreateWithoutCustomerInput>
  }

  export type CustomerDiscountCreateManyCustomerInputEnvelope = {
    data: CustomerDiscountCreateManyCustomerInput | CustomerDiscountCreateManyCustomerInput[]
    skipDuplicates?: boolean
  }

  export type VisitUpsertWithWhereUniqueWithoutCustomerInput = {
    where: VisitWhereUniqueInput
    update: XOR<VisitUpdateWithoutCustomerInput, VisitUncheckedUpdateWithoutCustomerInput>
    create: XOR<VisitCreateWithoutCustomerInput, VisitUncheckedCreateWithoutCustomerInput>
  }

  export type VisitUpdateWithWhereUniqueWithoutCustomerInput = {
    where: VisitWhereUniqueInput
    data: XOR<VisitUpdateWithoutCustomerInput, VisitUncheckedUpdateWithoutCustomerInput>
  }

  export type VisitUpdateManyWithWhereWithoutCustomerInput = {
    where: VisitScalarWhereInput
    data: XOR<VisitUpdateManyMutationInput, VisitUncheckedUpdateManyWithoutCustomerInput>
  }

  export type CustomerDiscountUpsertWithWhereUniqueWithoutCustomerInput = {
    where: CustomerDiscountWhereUniqueInput
    update: XOR<CustomerDiscountUpdateWithoutCustomerInput, CustomerDiscountUncheckedUpdateWithoutCustomerInput>
    create: XOR<CustomerDiscountCreateWithoutCustomerInput, CustomerDiscountUncheckedCreateWithoutCustomerInput>
  }

  export type CustomerDiscountUpdateWithWhereUniqueWithoutCustomerInput = {
    where: CustomerDiscountWhereUniqueInput
    data: XOR<CustomerDiscountUpdateWithoutCustomerInput, CustomerDiscountUncheckedUpdateWithoutCustomerInput>
  }

  export type CustomerDiscountUpdateManyWithWhereWithoutCustomerInput = {
    where: CustomerDiscountScalarWhereInput
    data: XOR<CustomerDiscountUpdateManyMutationInput, CustomerDiscountUncheckedUpdateManyWithoutCustomerInput>
  }

  export type CustomerDiscountScalarWhereInput = {
    AND?: CustomerDiscountScalarWhereInput | CustomerDiscountScalarWhereInput[]
    OR?: CustomerDiscountScalarWhereInput[]
    NOT?: CustomerDiscountScalarWhereInput | CustomerDiscountScalarWhereInput[]
    id?: StringFilter<"CustomerDiscount"> | string
    customerId?: StringFilter<"CustomerDiscount"> | string
    discountRuleId?: StringFilter<"CustomerDiscount"> | string
    usedAt?: DateTimeFilter<"CustomerDiscount"> | Date | string
    discountAmount?: DecimalFilter<"CustomerDiscount"> | Decimal | DecimalJsLike | number | string
  }

  export type VisitServiceCreateWithoutServiceInput = {
    id?: string
    quantity?: number
    unitPrice: Decimal | DecimalJsLike | number | string
    totalPrice: Decimal | DecimalJsLike | number | string
    isChild?: boolean
    isCombined?: boolean
    createdAt?: Date | string
    visit: VisitCreateNestedOneWithoutServicesInput
  }

  export type VisitServiceUncheckedCreateWithoutServiceInput = {
    id?: string
    visitId: string
    quantity?: number
    unitPrice: Decimal | DecimalJsLike | number | string
    totalPrice: Decimal | DecimalJsLike | number | string
    isChild?: boolean
    isCombined?: boolean
    createdAt?: Date | string
  }

  export type VisitServiceCreateOrConnectWithoutServiceInput = {
    where: VisitServiceWhereUniqueInput
    create: XOR<VisitServiceCreateWithoutServiceInput, VisitServiceUncheckedCreateWithoutServiceInput>
  }

  export type VisitServiceCreateManyServiceInputEnvelope = {
    data: VisitServiceCreateManyServiceInput | VisitServiceCreateManyServiceInput[]
    skipDuplicates?: boolean
  }

  export type VisitServiceUpsertWithWhereUniqueWithoutServiceInput = {
    where: VisitServiceWhereUniqueInput
    update: XOR<VisitServiceUpdateWithoutServiceInput, VisitServiceUncheckedUpdateWithoutServiceInput>
    create: XOR<VisitServiceCreateWithoutServiceInput, VisitServiceUncheckedCreateWithoutServiceInput>
  }

  export type VisitServiceUpdateWithWhereUniqueWithoutServiceInput = {
    where: VisitServiceWhereUniqueInput
    data: XOR<VisitServiceUpdateWithoutServiceInput, VisitServiceUncheckedUpdateWithoutServiceInput>
  }

  export type VisitServiceUpdateManyWithWhereWithoutServiceInput = {
    where: VisitServiceScalarWhereInput
    data: XOR<VisitServiceUpdateManyMutationInput, VisitServiceUncheckedUpdateManyWithoutServiceInput>
  }

  export type VisitServiceScalarWhereInput = {
    AND?: VisitServiceScalarWhereInput | VisitServiceScalarWhereInput[]
    OR?: VisitServiceScalarWhereInput[]
    NOT?: VisitServiceScalarWhereInput | VisitServiceScalarWhereInput[]
    id?: StringFilter<"VisitService"> | string
    visitId?: StringFilter<"VisitService"> | string
    serviceId?: StringFilter<"VisitService"> | string
    quantity?: IntFilter<"VisitService"> | number
    unitPrice?: DecimalFilter<"VisitService"> | Decimal | DecimalJsLike | number | string
    totalPrice?: DecimalFilter<"VisitService"> | Decimal | DecimalJsLike | number | string
    isChild?: BoolFilter<"VisitService"> | boolean
    isCombined?: BoolFilter<"VisitService"> | boolean
    createdAt?: DateTimeFilter<"VisitService"> | Date | string
  }

  export type CustomerCreateWithoutVisitsInput = {
    id?: string
    fullName: string
    gender: $Enums.Gender
    location: string
    district: string
    province: string
    phone: string
    email?: string | null
    birthDay: number
    birthMonth: number
    birthYear?: number | null
    visitCount?: number
    loyaltyPoints?: number
    totalSpent?: Decimal | DecimalJsLike | number | string
    lastVisit?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    discounts?: CustomerDiscountCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateWithoutVisitsInput = {
    id?: string
    fullName: string
    gender: $Enums.Gender
    location: string
    district: string
    province: string
    phone: string
    email?: string | null
    birthDay: number
    birthMonth: number
    birthYear?: number | null
    visitCount?: number
    loyaltyPoints?: number
    totalSpent?: Decimal | DecimalJsLike | number | string
    lastVisit?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    discounts?: CustomerDiscountUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerCreateOrConnectWithoutVisitsInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutVisitsInput, CustomerUncheckedCreateWithoutVisitsInput>
  }

  export type UserCreateWithoutVisitsInput = {
    id?: string
    name: string
    email: string
    password: string
    role?: $Enums.Role
    phone?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    staffVisits?: VisitStaffCreateNestedManyWithoutStaffInput
  }

  export type UserUncheckedCreateWithoutVisitsInput = {
    id?: string
    name: string
    email: string
    password: string
    role?: $Enums.Role
    phone?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    staffVisits?: VisitStaffUncheckedCreateNestedManyWithoutStaffInput
  }

  export type UserCreateOrConnectWithoutVisitsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutVisitsInput, UserUncheckedCreateWithoutVisitsInput>
  }

  export type VisitServiceCreateWithoutVisitInput = {
    id?: string
    quantity?: number
    unitPrice: Decimal | DecimalJsLike | number | string
    totalPrice: Decimal | DecimalJsLike | number | string
    isChild?: boolean
    isCombined?: boolean
    createdAt?: Date | string
    service: ServiceCreateNestedOneWithoutVisitServicesInput
  }

  export type VisitServiceUncheckedCreateWithoutVisitInput = {
    id?: string
    serviceId: string
    quantity?: number
    unitPrice: Decimal | DecimalJsLike | number | string
    totalPrice: Decimal | DecimalJsLike | number | string
    isChild?: boolean
    isCombined?: boolean
    createdAt?: Date | string
  }

  export type VisitServiceCreateOrConnectWithoutVisitInput = {
    where: VisitServiceWhereUniqueInput
    create: XOR<VisitServiceCreateWithoutVisitInput, VisitServiceUncheckedCreateWithoutVisitInput>
  }

  export type VisitServiceCreateManyVisitInputEnvelope = {
    data: VisitServiceCreateManyVisitInput | VisitServiceCreateManyVisitInput[]
    skipDuplicates?: boolean
  }

  export type VisitStaffCreateWithoutVisitInput = {
    id?: string
    serviceId?: string | null
    createdAt?: Date | string
    staff: UserCreateNestedOneWithoutStaffVisitsInput
  }

  export type VisitStaffUncheckedCreateWithoutVisitInput = {
    id?: string
    staffId: string
    serviceId?: string | null
    createdAt?: Date | string
  }

  export type VisitStaffCreateOrConnectWithoutVisitInput = {
    where: VisitStaffWhereUniqueInput
    create: XOR<VisitStaffCreateWithoutVisitInput, VisitStaffUncheckedCreateWithoutVisitInput>
  }

  export type VisitStaffCreateManyVisitInputEnvelope = {
    data: VisitStaffCreateManyVisitInput | VisitStaffCreateManyVisitInput[]
    skipDuplicates?: boolean
  }

  export type VisitDiscountCreateWithoutVisitInput = {
    id?: string
    discountAmount: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    discountRule: DiscountRuleCreateNestedOneWithoutVisitDiscountsInput
  }

  export type VisitDiscountUncheckedCreateWithoutVisitInput = {
    id?: string
    discountRuleId: string
    discountAmount: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
  }

  export type VisitDiscountCreateOrConnectWithoutVisitInput = {
    where: VisitDiscountWhereUniqueInput
    create: XOR<VisitDiscountCreateWithoutVisitInput, VisitDiscountUncheckedCreateWithoutVisitInput>
  }

  export type VisitDiscountCreateManyVisitInputEnvelope = {
    data: VisitDiscountCreateManyVisitInput | VisitDiscountCreateManyVisitInput[]
    skipDuplicates?: boolean
  }

  export type CustomerUpsertWithoutVisitsInput = {
    update: XOR<CustomerUpdateWithoutVisitsInput, CustomerUncheckedUpdateWithoutVisitsInput>
    create: XOR<CustomerCreateWithoutVisitsInput, CustomerUncheckedCreateWithoutVisitsInput>
    where?: CustomerWhereInput
  }

  export type CustomerUpdateToOneWithWhereWithoutVisitsInput = {
    where?: CustomerWhereInput
    data: XOR<CustomerUpdateWithoutVisitsInput, CustomerUncheckedUpdateWithoutVisitsInput>
  }

  export type CustomerUpdateWithoutVisitsInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    location?: StringFieldUpdateOperationsInput | string
    district?: StringFieldUpdateOperationsInput | string
    province?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    birthDay?: IntFieldUpdateOperationsInput | number
    birthMonth?: IntFieldUpdateOperationsInput | number
    birthYear?: NullableIntFieldUpdateOperationsInput | number | null
    visitCount?: IntFieldUpdateOperationsInput | number
    loyaltyPoints?: IntFieldUpdateOperationsInput | number
    totalSpent?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lastVisit?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    discounts?: CustomerDiscountUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateWithoutVisitsInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    location?: StringFieldUpdateOperationsInput | string
    district?: StringFieldUpdateOperationsInput | string
    province?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    birthDay?: IntFieldUpdateOperationsInput | number
    birthMonth?: IntFieldUpdateOperationsInput | number
    birthYear?: NullableIntFieldUpdateOperationsInput | number | null
    visitCount?: IntFieldUpdateOperationsInput | number
    loyaltyPoints?: IntFieldUpdateOperationsInput | number
    totalSpent?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lastVisit?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    discounts?: CustomerDiscountUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type UserUpsertWithoutVisitsInput = {
    update: XOR<UserUpdateWithoutVisitsInput, UserUncheckedUpdateWithoutVisitsInput>
    create: XOR<UserCreateWithoutVisitsInput, UserUncheckedCreateWithoutVisitsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutVisitsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutVisitsInput, UserUncheckedUpdateWithoutVisitsInput>
  }

  export type UserUpdateWithoutVisitsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    staffVisits?: VisitStaffUpdateManyWithoutStaffNestedInput
  }

  export type UserUncheckedUpdateWithoutVisitsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    staffVisits?: VisitStaffUncheckedUpdateManyWithoutStaffNestedInput
  }

  export type VisitServiceUpsertWithWhereUniqueWithoutVisitInput = {
    where: VisitServiceWhereUniqueInput
    update: XOR<VisitServiceUpdateWithoutVisitInput, VisitServiceUncheckedUpdateWithoutVisitInput>
    create: XOR<VisitServiceCreateWithoutVisitInput, VisitServiceUncheckedCreateWithoutVisitInput>
  }

  export type VisitServiceUpdateWithWhereUniqueWithoutVisitInput = {
    where: VisitServiceWhereUniqueInput
    data: XOR<VisitServiceUpdateWithoutVisitInput, VisitServiceUncheckedUpdateWithoutVisitInput>
  }

  export type VisitServiceUpdateManyWithWhereWithoutVisitInput = {
    where: VisitServiceScalarWhereInput
    data: XOR<VisitServiceUpdateManyMutationInput, VisitServiceUncheckedUpdateManyWithoutVisitInput>
  }

  export type VisitStaffUpsertWithWhereUniqueWithoutVisitInput = {
    where: VisitStaffWhereUniqueInput
    update: XOR<VisitStaffUpdateWithoutVisitInput, VisitStaffUncheckedUpdateWithoutVisitInput>
    create: XOR<VisitStaffCreateWithoutVisitInput, VisitStaffUncheckedCreateWithoutVisitInput>
  }

  export type VisitStaffUpdateWithWhereUniqueWithoutVisitInput = {
    where: VisitStaffWhereUniqueInput
    data: XOR<VisitStaffUpdateWithoutVisitInput, VisitStaffUncheckedUpdateWithoutVisitInput>
  }

  export type VisitStaffUpdateManyWithWhereWithoutVisitInput = {
    where: VisitStaffScalarWhereInput
    data: XOR<VisitStaffUpdateManyMutationInput, VisitStaffUncheckedUpdateManyWithoutVisitInput>
  }

  export type VisitDiscountUpsertWithWhereUniqueWithoutVisitInput = {
    where: VisitDiscountWhereUniqueInput
    update: XOR<VisitDiscountUpdateWithoutVisitInput, VisitDiscountUncheckedUpdateWithoutVisitInput>
    create: XOR<VisitDiscountCreateWithoutVisitInput, VisitDiscountUncheckedCreateWithoutVisitInput>
  }

  export type VisitDiscountUpdateWithWhereUniqueWithoutVisitInput = {
    where: VisitDiscountWhereUniqueInput
    data: XOR<VisitDiscountUpdateWithoutVisitInput, VisitDiscountUncheckedUpdateWithoutVisitInput>
  }

  export type VisitDiscountUpdateManyWithWhereWithoutVisitInput = {
    where: VisitDiscountScalarWhereInput
    data: XOR<VisitDiscountUpdateManyMutationInput, VisitDiscountUncheckedUpdateManyWithoutVisitInput>
  }

  export type VisitDiscountScalarWhereInput = {
    AND?: VisitDiscountScalarWhereInput | VisitDiscountScalarWhereInput[]
    OR?: VisitDiscountScalarWhereInput[]
    NOT?: VisitDiscountScalarWhereInput | VisitDiscountScalarWhereInput[]
    id?: StringFilter<"VisitDiscount"> | string
    visitId?: StringFilter<"VisitDiscount"> | string
    discountRuleId?: StringFilter<"VisitDiscount"> | string
    discountAmount?: DecimalFilter<"VisitDiscount"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"VisitDiscount"> | Date | string
  }

  export type VisitCreateWithoutServicesInput = {
    id?: string
    visitDate?: Date | string
    totalAmount: Decimal | DecimalJsLike | number | string
    discountAmount?: Decimal | DecimalJsLike | number | string
    finalAmount: Decimal | DecimalJsLike | number | string
    loyaltyPointsEarned?: number
    notes?: string | null
    isCompleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    customer: CustomerCreateNestedOneWithoutVisitsInput
    createdBy: UserCreateNestedOneWithoutVisitsInput
    staff?: VisitStaffCreateNestedManyWithoutVisitInput
    discounts?: VisitDiscountCreateNestedManyWithoutVisitInput
  }

  export type VisitUncheckedCreateWithoutServicesInput = {
    id?: string
    customerId: string
    visitDate?: Date | string
    totalAmount: Decimal | DecimalJsLike | number | string
    discountAmount?: Decimal | DecimalJsLike | number | string
    finalAmount: Decimal | DecimalJsLike | number | string
    loyaltyPointsEarned?: number
    notes?: string | null
    isCompleted?: boolean
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
    staff?: VisitStaffUncheckedCreateNestedManyWithoutVisitInput
    discounts?: VisitDiscountUncheckedCreateNestedManyWithoutVisitInput
  }

  export type VisitCreateOrConnectWithoutServicesInput = {
    where: VisitWhereUniqueInput
    create: XOR<VisitCreateWithoutServicesInput, VisitUncheckedCreateWithoutServicesInput>
  }

  export type ServiceCreateWithoutVisitServicesInput = {
    id?: string
    name: string
    category: $Enums.ServiceCategory
    description: string
    singlePrice: Decimal | DecimalJsLike | number | string
    combinedPrice?: Decimal | DecimalJsLike | number | string | null
    childPrice?: Decimal | DecimalJsLike | number | string | null
    childCombinedPrice?: Decimal | DecimalJsLike | number | string | null
    duration: number
    isActive?: boolean
    isComboEligible?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ServiceUncheckedCreateWithoutVisitServicesInput = {
    id?: string
    name: string
    category: $Enums.ServiceCategory
    description: string
    singlePrice: Decimal | DecimalJsLike | number | string
    combinedPrice?: Decimal | DecimalJsLike | number | string | null
    childPrice?: Decimal | DecimalJsLike | number | string | null
    childCombinedPrice?: Decimal | DecimalJsLike | number | string | null
    duration: number
    isActive?: boolean
    isComboEligible?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ServiceCreateOrConnectWithoutVisitServicesInput = {
    where: ServiceWhereUniqueInput
    create: XOR<ServiceCreateWithoutVisitServicesInput, ServiceUncheckedCreateWithoutVisitServicesInput>
  }

  export type VisitUpsertWithoutServicesInput = {
    update: XOR<VisitUpdateWithoutServicesInput, VisitUncheckedUpdateWithoutServicesInput>
    create: XOR<VisitCreateWithoutServicesInput, VisitUncheckedCreateWithoutServicesInput>
    where?: VisitWhereInput
  }

  export type VisitUpdateToOneWithWhereWithoutServicesInput = {
    where?: VisitWhereInput
    data: XOR<VisitUpdateWithoutServicesInput, VisitUncheckedUpdateWithoutServicesInput>
  }

  export type VisitUpdateWithoutServicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    visitDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    finalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    loyaltyPointsEarned?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomerUpdateOneRequiredWithoutVisitsNestedInput
    createdBy?: UserUpdateOneRequiredWithoutVisitsNestedInput
    staff?: VisitStaffUpdateManyWithoutVisitNestedInput
    discounts?: VisitDiscountUpdateManyWithoutVisitNestedInput
  }

  export type VisitUncheckedUpdateWithoutServicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    visitDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    finalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    loyaltyPointsEarned?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    staff?: VisitStaffUncheckedUpdateManyWithoutVisitNestedInput
    discounts?: VisitDiscountUncheckedUpdateManyWithoutVisitNestedInput
  }

  export type ServiceUpsertWithoutVisitServicesInput = {
    update: XOR<ServiceUpdateWithoutVisitServicesInput, ServiceUncheckedUpdateWithoutVisitServicesInput>
    create: XOR<ServiceCreateWithoutVisitServicesInput, ServiceUncheckedCreateWithoutVisitServicesInput>
    where?: ServiceWhereInput
  }

  export type ServiceUpdateToOneWithWhereWithoutVisitServicesInput = {
    where?: ServiceWhereInput
    data: XOR<ServiceUpdateWithoutVisitServicesInput, ServiceUncheckedUpdateWithoutVisitServicesInput>
  }

  export type ServiceUpdateWithoutVisitServicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: EnumServiceCategoryFieldUpdateOperationsInput | $Enums.ServiceCategory
    description?: StringFieldUpdateOperationsInput | string
    singlePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    combinedPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    childPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    childCombinedPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    duration?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isComboEligible?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceUncheckedUpdateWithoutVisitServicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: EnumServiceCategoryFieldUpdateOperationsInput | $Enums.ServiceCategory
    description?: StringFieldUpdateOperationsInput | string
    singlePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    combinedPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    childPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    childCombinedPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    duration?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isComboEligible?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VisitCreateWithoutStaffInput = {
    id?: string
    visitDate?: Date | string
    totalAmount: Decimal | DecimalJsLike | number | string
    discountAmount?: Decimal | DecimalJsLike | number | string
    finalAmount: Decimal | DecimalJsLike | number | string
    loyaltyPointsEarned?: number
    notes?: string | null
    isCompleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    customer: CustomerCreateNestedOneWithoutVisitsInput
    createdBy: UserCreateNestedOneWithoutVisitsInput
    services?: VisitServiceCreateNestedManyWithoutVisitInput
    discounts?: VisitDiscountCreateNestedManyWithoutVisitInput
  }

  export type VisitUncheckedCreateWithoutStaffInput = {
    id?: string
    customerId: string
    visitDate?: Date | string
    totalAmount: Decimal | DecimalJsLike | number | string
    discountAmount?: Decimal | DecimalJsLike | number | string
    finalAmount: Decimal | DecimalJsLike | number | string
    loyaltyPointsEarned?: number
    notes?: string | null
    isCompleted?: boolean
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
    services?: VisitServiceUncheckedCreateNestedManyWithoutVisitInput
    discounts?: VisitDiscountUncheckedCreateNestedManyWithoutVisitInput
  }

  export type VisitCreateOrConnectWithoutStaffInput = {
    where: VisitWhereUniqueInput
    create: XOR<VisitCreateWithoutStaffInput, VisitUncheckedCreateWithoutStaffInput>
  }

  export type UserCreateWithoutStaffVisitsInput = {
    id?: string
    name: string
    email: string
    password: string
    role?: $Enums.Role
    phone?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    visits?: VisitCreateNestedManyWithoutCreatedByInput
  }

  export type UserUncheckedCreateWithoutStaffVisitsInput = {
    id?: string
    name: string
    email: string
    password: string
    role?: $Enums.Role
    phone?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    visits?: VisitUncheckedCreateNestedManyWithoutCreatedByInput
  }

  export type UserCreateOrConnectWithoutStaffVisitsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutStaffVisitsInput, UserUncheckedCreateWithoutStaffVisitsInput>
  }

  export type VisitUpsertWithoutStaffInput = {
    update: XOR<VisitUpdateWithoutStaffInput, VisitUncheckedUpdateWithoutStaffInput>
    create: XOR<VisitCreateWithoutStaffInput, VisitUncheckedCreateWithoutStaffInput>
    where?: VisitWhereInput
  }

  export type VisitUpdateToOneWithWhereWithoutStaffInput = {
    where?: VisitWhereInput
    data: XOR<VisitUpdateWithoutStaffInput, VisitUncheckedUpdateWithoutStaffInput>
  }

  export type VisitUpdateWithoutStaffInput = {
    id?: StringFieldUpdateOperationsInput | string
    visitDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    finalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    loyaltyPointsEarned?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomerUpdateOneRequiredWithoutVisitsNestedInput
    createdBy?: UserUpdateOneRequiredWithoutVisitsNestedInput
    services?: VisitServiceUpdateManyWithoutVisitNestedInput
    discounts?: VisitDiscountUpdateManyWithoutVisitNestedInput
  }

  export type VisitUncheckedUpdateWithoutStaffInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    visitDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    finalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    loyaltyPointsEarned?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    services?: VisitServiceUncheckedUpdateManyWithoutVisitNestedInput
    discounts?: VisitDiscountUncheckedUpdateManyWithoutVisitNestedInput
  }

  export type UserUpsertWithoutStaffVisitsInput = {
    update: XOR<UserUpdateWithoutStaffVisitsInput, UserUncheckedUpdateWithoutStaffVisitsInput>
    create: XOR<UserCreateWithoutStaffVisitsInput, UserUncheckedCreateWithoutStaffVisitsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutStaffVisitsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutStaffVisitsInput, UserUncheckedUpdateWithoutStaffVisitsInput>
  }

  export type UserUpdateWithoutStaffVisitsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    visits?: VisitUpdateManyWithoutCreatedByNestedInput
  }

  export type UserUncheckedUpdateWithoutStaffVisitsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    visits?: VisitUncheckedUpdateManyWithoutCreatedByNestedInput
  }

  export type VisitDiscountCreateWithoutDiscountRuleInput = {
    id?: string
    discountAmount: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    visit: VisitCreateNestedOneWithoutDiscountsInput
  }

  export type VisitDiscountUncheckedCreateWithoutDiscountRuleInput = {
    id?: string
    visitId: string
    discountAmount: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
  }

  export type VisitDiscountCreateOrConnectWithoutDiscountRuleInput = {
    where: VisitDiscountWhereUniqueInput
    create: XOR<VisitDiscountCreateWithoutDiscountRuleInput, VisitDiscountUncheckedCreateWithoutDiscountRuleInput>
  }

  export type VisitDiscountCreateManyDiscountRuleInputEnvelope = {
    data: VisitDiscountCreateManyDiscountRuleInput | VisitDiscountCreateManyDiscountRuleInput[]
    skipDuplicates?: boolean
  }

  export type CustomerDiscountCreateWithoutDiscountRuleInput = {
    id?: string
    usedAt?: Date | string
    discountAmount: Decimal | DecimalJsLike | number | string
    customer: CustomerCreateNestedOneWithoutDiscountsInput
  }

  export type CustomerDiscountUncheckedCreateWithoutDiscountRuleInput = {
    id?: string
    customerId: string
    usedAt?: Date | string
    discountAmount: Decimal | DecimalJsLike | number | string
  }

  export type CustomerDiscountCreateOrConnectWithoutDiscountRuleInput = {
    where: CustomerDiscountWhereUniqueInput
    create: XOR<CustomerDiscountCreateWithoutDiscountRuleInput, CustomerDiscountUncheckedCreateWithoutDiscountRuleInput>
  }

  export type CustomerDiscountCreateManyDiscountRuleInputEnvelope = {
    data: CustomerDiscountCreateManyDiscountRuleInput | CustomerDiscountCreateManyDiscountRuleInput[]
    skipDuplicates?: boolean
  }

  export type VisitDiscountUpsertWithWhereUniqueWithoutDiscountRuleInput = {
    where: VisitDiscountWhereUniqueInput
    update: XOR<VisitDiscountUpdateWithoutDiscountRuleInput, VisitDiscountUncheckedUpdateWithoutDiscountRuleInput>
    create: XOR<VisitDiscountCreateWithoutDiscountRuleInput, VisitDiscountUncheckedCreateWithoutDiscountRuleInput>
  }

  export type VisitDiscountUpdateWithWhereUniqueWithoutDiscountRuleInput = {
    where: VisitDiscountWhereUniqueInput
    data: XOR<VisitDiscountUpdateWithoutDiscountRuleInput, VisitDiscountUncheckedUpdateWithoutDiscountRuleInput>
  }

  export type VisitDiscountUpdateManyWithWhereWithoutDiscountRuleInput = {
    where: VisitDiscountScalarWhereInput
    data: XOR<VisitDiscountUpdateManyMutationInput, VisitDiscountUncheckedUpdateManyWithoutDiscountRuleInput>
  }

  export type CustomerDiscountUpsertWithWhereUniqueWithoutDiscountRuleInput = {
    where: CustomerDiscountWhereUniqueInput
    update: XOR<CustomerDiscountUpdateWithoutDiscountRuleInput, CustomerDiscountUncheckedUpdateWithoutDiscountRuleInput>
    create: XOR<CustomerDiscountCreateWithoutDiscountRuleInput, CustomerDiscountUncheckedCreateWithoutDiscountRuleInput>
  }

  export type CustomerDiscountUpdateWithWhereUniqueWithoutDiscountRuleInput = {
    where: CustomerDiscountWhereUniqueInput
    data: XOR<CustomerDiscountUpdateWithoutDiscountRuleInput, CustomerDiscountUncheckedUpdateWithoutDiscountRuleInput>
  }

  export type CustomerDiscountUpdateManyWithWhereWithoutDiscountRuleInput = {
    where: CustomerDiscountScalarWhereInput
    data: XOR<CustomerDiscountUpdateManyMutationInput, CustomerDiscountUncheckedUpdateManyWithoutDiscountRuleInput>
  }

  export type VisitCreateWithoutDiscountsInput = {
    id?: string
    visitDate?: Date | string
    totalAmount: Decimal | DecimalJsLike | number | string
    discountAmount?: Decimal | DecimalJsLike | number | string
    finalAmount: Decimal | DecimalJsLike | number | string
    loyaltyPointsEarned?: number
    notes?: string | null
    isCompleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    customer: CustomerCreateNestedOneWithoutVisitsInput
    createdBy: UserCreateNestedOneWithoutVisitsInput
    services?: VisitServiceCreateNestedManyWithoutVisitInput
    staff?: VisitStaffCreateNestedManyWithoutVisitInput
  }

  export type VisitUncheckedCreateWithoutDiscountsInput = {
    id?: string
    customerId: string
    visitDate?: Date | string
    totalAmount: Decimal | DecimalJsLike | number | string
    discountAmount?: Decimal | DecimalJsLike | number | string
    finalAmount: Decimal | DecimalJsLike | number | string
    loyaltyPointsEarned?: number
    notes?: string | null
    isCompleted?: boolean
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
    services?: VisitServiceUncheckedCreateNestedManyWithoutVisitInput
    staff?: VisitStaffUncheckedCreateNestedManyWithoutVisitInput
  }

  export type VisitCreateOrConnectWithoutDiscountsInput = {
    where: VisitWhereUniqueInput
    create: XOR<VisitCreateWithoutDiscountsInput, VisitUncheckedCreateWithoutDiscountsInput>
  }

  export type DiscountRuleCreateWithoutVisitDiscountsInput = {
    id?: string
    name: string
    type: $Enums.DiscountType
    value: Decimal | DecimalJsLike | number | string
    isPercentage?: boolean
    isActive?: boolean
    description?: string | null
    minAmount?: Decimal | DecimalJsLike | number | string | null
    maxDiscount?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    customerDiscounts?: CustomerDiscountCreateNestedManyWithoutDiscountRuleInput
  }

  export type DiscountRuleUncheckedCreateWithoutVisitDiscountsInput = {
    id?: string
    name: string
    type: $Enums.DiscountType
    value: Decimal | DecimalJsLike | number | string
    isPercentage?: boolean
    isActive?: boolean
    description?: string | null
    minAmount?: Decimal | DecimalJsLike | number | string | null
    maxDiscount?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    customerDiscounts?: CustomerDiscountUncheckedCreateNestedManyWithoutDiscountRuleInput
  }

  export type DiscountRuleCreateOrConnectWithoutVisitDiscountsInput = {
    where: DiscountRuleWhereUniqueInput
    create: XOR<DiscountRuleCreateWithoutVisitDiscountsInput, DiscountRuleUncheckedCreateWithoutVisitDiscountsInput>
  }

  export type VisitUpsertWithoutDiscountsInput = {
    update: XOR<VisitUpdateWithoutDiscountsInput, VisitUncheckedUpdateWithoutDiscountsInput>
    create: XOR<VisitCreateWithoutDiscountsInput, VisitUncheckedCreateWithoutDiscountsInput>
    where?: VisitWhereInput
  }

  export type VisitUpdateToOneWithWhereWithoutDiscountsInput = {
    where?: VisitWhereInput
    data: XOR<VisitUpdateWithoutDiscountsInput, VisitUncheckedUpdateWithoutDiscountsInput>
  }

  export type VisitUpdateWithoutDiscountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    visitDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    finalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    loyaltyPointsEarned?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomerUpdateOneRequiredWithoutVisitsNestedInput
    createdBy?: UserUpdateOneRequiredWithoutVisitsNestedInput
    services?: VisitServiceUpdateManyWithoutVisitNestedInput
    staff?: VisitStaffUpdateManyWithoutVisitNestedInput
  }

  export type VisitUncheckedUpdateWithoutDiscountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    visitDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    finalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    loyaltyPointsEarned?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    services?: VisitServiceUncheckedUpdateManyWithoutVisitNestedInput
    staff?: VisitStaffUncheckedUpdateManyWithoutVisitNestedInput
  }

  export type DiscountRuleUpsertWithoutVisitDiscountsInput = {
    update: XOR<DiscountRuleUpdateWithoutVisitDiscountsInput, DiscountRuleUncheckedUpdateWithoutVisitDiscountsInput>
    create: XOR<DiscountRuleCreateWithoutVisitDiscountsInput, DiscountRuleUncheckedCreateWithoutVisitDiscountsInput>
    where?: DiscountRuleWhereInput
  }

  export type DiscountRuleUpdateToOneWithWhereWithoutVisitDiscountsInput = {
    where?: DiscountRuleWhereInput
    data: XOR<DiscountRuleUpdateWithoutVisitDiscountsInput, DiscountRuleUncheckedUpdateWithoutVisitDiscountsInput>
  }

  export type DiscountRuleUpdateWithoutVisitDiscountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumDiscountTypeFieldUpdateOperationsInput | $Enums.DiscountType
    value?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isPercentage?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    minAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    maxDiscount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customerDiscounts?: CustomerDiscountUpdateManyWithoutDiscountRuleNestedInput
  }

  export type DiscountRuleUncheckedUpdateWithoutVisitDiscountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumDiscountTypeFieldUpdateOperationsInput | $Enums.DiscountType
    value?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isPercentage?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    minAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    maxDiscount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customerDiscounts?: CustomerDiscountUncheckedUpdateManyWithoutDiscountRuleNestedInput
  }

  export type CustomerCreateWithoutDiscountsInput = {
    id?: string
    fullName: string
    gender: $Enums.Gender
    location: string
    district: string
    province: string
    phone: string
    email?: string | null
    birthDay: number
    birthMonth: number
    birthYear?: number | null
    visitCount?: number
    loyaltyPoints?: number
    totalSpent?: Decimal | DecimalJsLike | number | string
    lastVisit?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    visits?: VisitCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateWithoutDiscountsInput = {
    id?: string
    fullName: string
    gender: $Enums.Gender
    location: string
    district: string
    province: string
    phone: string
    email?: string | null
    birthDay: number
    birthMonth: number
    birthYear?: number | null
    visitCount?: number
    loyaltyPoints?: number
    totalSpent?: Decimal | DecimalJsLike | number | string
    lastVisit?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    visits?: VisitUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerCreateOrConnectWithoutDiscountsInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutDiscountsInput, CustomerUncheckedCreateWithoutDiscountsInput>
  }

  export type DiscountRuleCreateWithoutCustomerDiscountsInput = {
    id?: string
    name: string
    type: $Enums.DiscountType
    value: Decimal | DecimalJsLike | number | string
    isPercentage?: boolean
    isActive?: boolean
    description?: string | null
    minAmount?: Decimal | DecimalJsLike | number | string | null
    maxDiscount?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    visitDiscounts?: VisitDiscountCreateNestedManyWithoutDiscountRuleInput
  }

  export type DiscountRuleUncheckedCreateWithoutCustomerDiscountsInput = {
    id?: string
    name: string
    type: $Enums.DiscountType
    value: Decimal | DecimalJsLike | number | string
    isPercentage?: boolean
    isActive?: boolean
    description?: string | null
    minAmount?: Decimal | DecimalJsLike | number | string | null
    maxDiscount?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    visitDiscounts?: VisitDiscountUncheckedCreateNestedManyWithoutDiscountRuleInput
  }

  export type DiscountRuleCreateOrConnectWithoutCustomerDiscountsInput = {
    where: DiscountRuleWhereUniqueInput
    create: XOR<DiscountRuleCreateWithoutCustomerDiscountsInput, DiscountRuleUncheckedCreateWithoutCustomerDiscountsInput>
  }

  export type CustomerUpsertWithoutDiscountsInput = {
    update: XOR<CustomerUpdateWithoutDiscountsInput, CustomerUncheckedUpdateWithoutDiscountsInput>
    create: XOR<CustomerCreateWithoutDiscountsInput, CustomerUncheckedCreateWithoutDiscountsInput>
    where?: CustomerWhereInput
  }

  export type CustomerUpdateToOneWithWhereWithoutDiscountsInput = {
    where?: CustomerWhereInput
    data: XOR<CustomerUpdateWithoutDiscountsInput, CustomerUncheckedUpdateWithoutDiscountsInput>
  }

  export type CustomerUpdateWithoutDiscountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    location?: StringFieldUpdateOperationsInput | string
    district?: StringFieldUpdateOperationsInput | string
    province?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    birthDay?: IntFieldUpdateOperationsInput | number
    birthMonth?: IntFieldUpdateOperationsInput | number
    birthYear?: NullableIntFieldUpdateOperationsInput | number | null
    visitCount?: IntFieldUpdateOperationsInput | number
    loyaltyPoints?: IntFieldUpdateOperationsInput | number
    totalSpent?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lastVisit?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    visits?: VisitUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateWithoutDiscountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    location?: StringFieldUpdateOperationsInput | string
    district?: StringFieldUpdateOperationsInput | string
    province?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    birthDay?: IntFieldUpdateOperationsInput | number
    birthMonth?: IntFieldUpdateOperationsInput | number
    birthYear?: NullableIntFieldUpdateOperationsInput | number | null
    visitCount?: IntFieldUpdateOperationsInput | number
    loyaltyPoints?: IntFieldUpdateOperationsInput | number
    totalSpent?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lastVisit?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    visits?: VisitUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type DiscountRuleUpsertWithoutCustomerDiscountsInput = {
    update: XOR<DiscountRuleUpdateWithoutCustomerDiscountsInput, DiscountRuleUncheckedUpdateWithoutCustomerDiscountsInput>
    create: XOR<DiscountRuleCreateWithoutCustomerDiscountsInput, DiscountRuleUncheckedCreateWithoutCustomerDiscountsInput>
    where?: DiscountRuleWhereInput
  }

  export type DiscountRuleUpdateToOneWithWhereWithoutCustomerDiscountsInput = {
    where?: DiscountRuleWhereInput
    data: XOR<DiscountRuleUpdateWithoutCustomerDiscountsInput, DiscountRuleUncheckedUpdateWithoutCustomerDiscountsInput>
  }

  export type DiscountRuleUpdateWithoutCustomerDiscountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumDiscountTypeFieldUpdateOperationsInput | $Enums.DiscountType
    value?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isPercentage?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    minAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    maxDiscount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    visitDiscounts?: VisitDiscountUpdateManyWithoutDiscountRuleNestedInput
  }

  export type DiscountRuleUncheckedUpdateWithoutCustomerDiscountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumDiscountTypeFieldUpdateOperationsInput | $Enums.DiscountType
    value?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isPercentage?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    minAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    maxDiscount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    visitDiscounts?: VisitDiscountUncheckedUpdateManyWithoutDiscountRuleNestedInput
  }

  export type VisitCreateManyCreatedByInput = {
    id?: string
    customerId: string
    visitDate?: Date | string
    totalAmount: Decimal | DecimalJsLike | number | string
    discountAmount?: Decimal | DecimalJsLike | number | string
    finalAmount: Decimal | DecimalJsLike | number | string
    loyaltyPointsEarned?: number
    notes?: string | null
    isCompleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VisitStaffCreateManyStaffInput = {
    id?: string
    visitId: string
    serviceId?: string | null
    createdAt?: Date | string
  }

  export type VisitUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    visitDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    finalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    loyaltyPointsEarned?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomerUpdateOneRequiredWithoutVisitsNestedInput
    services?: VisitServiceUpdateManyWithoutVisitNestedInput
    staff?: VisitStaffUpdateManyWithoutVisitNestedInput
    discounts?: VisitDiscountUpdateManyWithoutVisitNestedInput
  }

  export type VisitUncheckedUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    visitDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    finalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    loyaltyPointsEarned?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    services?: VisitServiceUncheckedUpdateManyWithoutVisitNestedInput
    staff?: VisitStaffUncheckedUpdateManyWithoutVisitNestedInput
    discounts?: VisitDiscountUncheckedUpdateManyWithoutVisitNestedInput
  }

  export type VisitUncheckedUpdateManyWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    visitDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    finalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    loyaltyPointsEarned?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VisitStaffUpdateWithoutStaffInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    visit?: VisitUpdateOneRequiredWithoutStaffNestedInput
  }

  export type VisitStaffUncheckedUpdateWithoutStaffInput = {
    id?: StringFieldUpdateOperationsInput | string
    visitId?: StringFieldUpdateOperationsInput | string
    serviceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VisitStaffUncheckedUpdateManyWithoutStaffInput = {
    id?: StringFieldUpdateOperationsInput | string
    visitId?: StringFieldUpdateOperationsInput | string
    serviceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VisitCreateManyCustomerInput = {
    id?: string
    visitDate?: Date | string
    totalAmount: Decimal | DecimalJsLike | number | string
    discountAmount?: Decimal | DecimalJsLike | number | string
    finalAmount: Decimal | DecimalJsLike | number | string
    loyaltyPointsEarned?: number
    notes?: string | null
    isCompleted?: boolean
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CustomerDiscountCreateManyCustomerInput = {
    id?: string
    discountRuleId: string
    usedAt?: Date | string
    discountAmount: Decimal | DecimalJsLike | number | string
  }

  export type VisitUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    visitDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    finalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    loyaltyPointsEarned?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneRequiredWithoutVisitsNestedInput
    services?: VisitServiceUpdateManyWithoutVisitNestedInput
    staff?: VisitStaffUpdateManyWithoutVisitNestedInput
    discounts?: VisitDiscountUpdateManyWithoutVisitNestedInput
  }

  export type VisitUncheckedUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    visitDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    finalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    loyaltyPointsEarned?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    services?: VisitServiceUncheckedUpdateManyWithoutVisitNestedInput
    staff?: VisitStaffUncheckedUpdateManyWithoutVisitNestedInput
    discounts?: VisitDiscountUncheckedUpdateManyWithoutVisitNestedInput
  }

  export type VisitUncheckedUpdateManyWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    visitDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    finalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    loyaltyPointsEarned?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerDiscountUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    usedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountRule?: DiscountRuleUpdateOneRequiredWithoutCustomerDiscountsNestedInput
  }

  export type CustomerDiscountUncheckedUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    discountRuleId?: StringFieldUpdateOperationsInput | string
    usedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type CustomerDiscountUncheckedUpdateManyWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    discountRuleId?: StringFieldUpdateOperationsInput | string
    usedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type VisitServiceCreateManyServiceInput = {
    id?: string
    visitId: string
    quantity?: number
    unitPrice: Decimal | DecimalJsLike | number | string
    totalPrice: Decimal | DecimalJsLike | number | string
    isChild?: boolean
    isCombined?: boolean
    createdAt?: Date | string
  }

  export type VisitServiceUpdateWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isChild?: BoolFieldUpdateOperationsInput | boolean
    isCombined?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    visit?: VisitUpdateOneRequiredWithoutServicesNestedInput
  }

  export type VisitServiceUncheckedUpdateWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    visitId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isChild?: BoolFieldUpdateOperationsInput | boolean
    isCombined?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VisitServiceUncheckedUpdateManyWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    visitId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isChild?: BoolFieldUpdateOperationsInput | boolean
    isCombined?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VisitServiceCreateManyVisitInput = {
    id?: string
    serviceId: string
    quantity?: number
    unitPrice: Decimal | DecimalJsLike | number | string
    totalPrice: Decimal | DecimalJsLike | number | string
    isChild?: boolean
    isCombined?: boolean
    createdAt?: Date | string
  }

  export type VisitStaffCreateManyVisitInput = {
    id?: string
    staffId: string
    serviceId?: string | null
    createdAt?: Date | string
  }

  export type VisitDiscountCreateManyVisitInput = {
    id?: string
    discountRuleId: string
    discountAmount: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
  }

  export type VisitServiceUpdateWithoutVisitInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isChild?: BoolFieldUpdateOperationsInput | boolean
    isCombined?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    service?: ServiceUpdateOneRequiredWithoutVisitServicesNestedInput
  }

  export type VisitServiceUncheckedUpdateWithoutVisitInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isChild?: BoolFieldUpdateOperationsInput | boolean
    isCombined?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VisitServiceUncheckedUpdateManyWithoutVisitInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isChild?: BoolFieldUpdateOperationsInput | boolean
    isCombined?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VisitStaffUpdateWithoutVisitInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    staff?: UserUpdateOneRequiredWithoutStaffVisitsNestedInput
  }

  export type VisitStaffUncheckedUpdateWithoutVisitInput = {
    id?: StringFieldUpdateOperationsInput | string
    staffId?: StringFieldUpdateOperationsInput | string
    serviceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VisitStaffUncheckedUpdateManyWithoutVisitInput = {
    id?: StringFieldUpdateOperationsInput | string
    staffId?: StringFieldUpdateOperationsInput | string
    serviceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VisitDiscountUpdateWithoutVisitInput = {
    id?: StringFieldUpdateOperationsInput | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    discountRule?: DiscountRuleUpdateOneRequiredWithoutVisitDiscountsNestedInput
  }

  export type VisitDiscountUncheckedUpdateWithoutVisitInput = {
    id?: StringFieldUpdateOperationsInput | string
    discountRuleId?: StringFieldUpdateOperationsInput | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VisitDiscountUncheckedUpdateManyWithoutVisitInput = {
    id?: StringFieldUpdateOperationsInput | string
    discountRuleId?: StringFieldUpdateOperationsInput | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VisitDiscountCreateManyDiscountRuleInput = {
    id?: string
    visitId: string
    discountAmount: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
  }

  export type CustomerDiscountCreateManyDiscountRuleInput = {
    id?: string
    customerId: string
    usedAt?: Date | string
    discountAmount: Decimal | DecimalJsLike | number | string
  }

  export type VisitDiscountUpdateWithoutDiscountRuleInput = {
    id?: StringFieldUpdateOperationsInput | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    visit?: VisitUpdateOneRequiredWithoutDiscountsNestedInput
  }

  export type VisitDiscountUncheckedUpdateWithoutDiscountRuleInput = {
    id?: StringFieldUpdateOperationsInput | string
    visitId?: StringFieldUpdateOperationsInput | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VisitDiscountUncheckedUpdateManyWithoutDiscountRuleInput = {
    id?: StringFieldUpdateOperationsInput | string
    visitId?: StringFieldUpdateOperationsInput | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerDiscountUpdateWithoutDiscountRuleInput = {
    id?: StringFieldUpdateOperationsInput | string
    usedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    customer?: CustomerUpdateOneRequiredWithoutDiscountsNestedInput
  }

  export type CustomerDiscountUncheckedUpdateWithoutDiscountRuleInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    usedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type CustomerDiscountUncheckedUpdateManyWithoutDiscountRuleInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    usedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}