
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Customer
 * 
 */
export type Customer = $Result.DefaultSelection<Prisma.$CustomerPayload>
/**
 * Model Service
 * 
 */
export type Service = $Result.DefaultSelection<Prisma.$ServicePayload>
/**
 * Model Sale
 * 
 */
export type Sale = $Result.DefaultSelection<Prisma.$SalePayload>
/**
 * Model SaleService
 * 
 */
export type SaleService = $Result.DefaultSelection<Prisma.$SaleServicePayload>
/**
 * Model SaleStaff
 * 
 */
export type SaleStaff = $Result.DefaultSelection<Prisma.$SaleStaffPayload>
/**
 * Model DiscountRule
 * 
 */
export type DiscountRule = $Result.DefaultSelection<Prisma.$DiscountRulePayload>
/**
 * Model SaleDiscount
 * 
 */
export type SaleDiscount = $Result.DefaultSelection<Prisma.$SaleDiscountPayload>
/**
 * Model CustomerDiscount
 * 
 */
export type CustomerDiscount = $Result.DefaultSelection<Prisma.$CustomerDiscountPayload>
/**
 * Model SalePayment
 * 
 */
export type SalePayment = $Result.DefaultSelection<Prisma.$SalePaymentPayload>
/**
 * Model Product
 * 
 */
export type Product = $Result.DefaultSelection<Prisma.$ProductPayload>
/**
 * Model SaleProduct
 * 
 */
export type SaleProduct = $Result.DefaultSelection<Prisma.$SaleProductPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const Role: {
  ADMIN: 'ADMIN',
  MANAGER: 'MANAGER',
  STAFF: 'STAFF'
};

export type Role = (typeof Role)[keyof typeof Role]


export const Gender: {
  MALE: 'MALE',
  FEMALE: 'FEMALE',
  OTHER: 'OTHER'
};

export type Gender = (typeof Gender)[keyof typeof Gender]


export const ServiceCategory: {
  HAIR_TREATMENTS: 'HAIR_TREATMENTS',
  TWIST_HAIRSTYLE: 'TWIST_HAIRSTYLE',
  CORNROWS_BRAIDS: 'CORNROWS_BRAIDS',
  STRAWSET_CURLS: 'STRAWSET_CURLS',
  STYLING_SERVICE: 'STYLING_SERVICE',
  SPECIAL_OFFERS: 'SPECIAL_OFFERS',
  KIDS_SERVICES: 'KIDS_SERVICES'
};

export type ServiceCategory = (typeof ServiceCategory)[keyof typeof ServiceCategory]


export const DiscountType: {
  SIXTH_VISIT: 'SIXTH_VISIT',
  BIRTHDAY_MONTH: 'BIRTHDAY_MONTH',
  LOYALTY_POINTS: 'LOYALTY_POINTS',
  SERVICE_COMBO: 'SERVICE_COMBO',
  BRING_OWN_PRODUCT: 'BRING_OWN_PRODUCT',
  MANUAL_DISCOUNT: 'MANUAL_DISCOUNT'
};

export type DiscountType = (typeof DiscountType)[keyof typeof DiscountType]


export const PaymentMethod: {
  CASH: 'CASH',
  MOBILE_MONEY: 'MOBILE_MONEY',
  MOMO: 'MOMO',
  BANK_CARD: 'BANK_CARD',
  BANK_TRANSFER: 'BANK_TRANSFER'
};

export type PaymentMethod = (typeof PaymentMethod)[keyof typeof PaymentMethod]

}

export type Role = $Enums.Role

export const Role: typeof $Enums.Role

export type Gender = $Enums.Gender

export const Gender: typeof $Enums.Gender

export type ServiceCategory = $Enums.ServiceCategory

export const ServiceCategory: typeof $Enums.ServiceCategory

export type DiscountType = $Enums.DiscountType

export const DiscountType: typeof $Enums.DiscountType

export type PaymentMethod = $Enums.PaymentMethod

export const PaymentMethod: typeof $Enums.PaymentMethod

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.customer`: Exposes CRUD operations for the **Customer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Customers
    * const customers = await prisma.customer.findMany()
    * ```
    */
  get customer(): Prisma.CustomerDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.service`: Exposes CRUD operations for the **Service** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Services
    * const services = await prisma.service.findMany()
    * ```
    */
  get service(): Prisma.ServiceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.sale`: Exposes CRUD operations for the **Sale** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sales
    * const sales = await prisma.sale.findMany()
    * ```
    */
  get sale(): Prisma.SaleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.saleService`: Exposes CRUD operations for the **SaleService** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SaleServices
    * const saleServices = await prisma.saleService.findMany()
    * ```
    */
  get saleService(): Prisma.SaleServiceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.saleStaff`: Exposes CRUD operations for the **SaleStaff** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SaleStaffs
    * const saleStaffs = await prisma.saleStaff.findMany()
    * ```
    */
  get saleStaff(): Prisma.SaleStaffDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.discountRule`: Exposes CRUD operations for the **DiscountRule** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DiscountRules
    * const discountRules = await prisma.discountRule.findMany()
    * ```
    */
  get discountRule(): Prisma.DiscountRuleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.saleDiscount`: Exposes CRUD operations for the **SaleDiscount** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SaleDiscounts
    * const saleDiscounts = await prisma.saleDiscount.findMany()
    * ```
    */
  get saleDiscount(): Prisma.SaleDiscountDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.customerDiscount`: Exposes CRUD operations for the **CustomerDiscount** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CustomerDiscounts
    * const customerDiscounts = await prisma.customerDiscount.findMany()
    * ```
    */
  get customerDiscount(): Prisma.CustomerDiscountDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.salePayment`: Exposes CRUD operations for the **SalePayment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SalePayments
    * const salePayments = await prisma.salePayment.findMany()
    * ```
    */
  get salePayment(): Prisma.SalePaymentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.product`: Exposes CRUD operations for the **Product** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Products
    * const products = await prisma.product.findMany()
    * ```
    */
  get product(): Prisma.ProductDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.saleProduct`: Exposes CRUD operations for the **SaleProduct** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SaleProducts
    * const saleProducts = await prisma.saleProduct.findMany()
    * ```
    */
  get saleProduct(): Prisma.SaleProductDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.16.2
   * Query Engine version: 1c57fdcd7e44b29b9313256c76699e91c3ac3c43
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Customer: 'Customer',
    Service: 'Service',
    Sale: 'Sale',
    SaleService: 'SaleService',
    SaleStaff: 'SaleStaff',
    DiscountRule: 'DiscountRule',
    SaleDiscount: 'SaleDiscount',
    CustomerDiscount: 'CustomerDiscount',
    SalePayment: 'SalePayment',
    Product: 'Product',
    SaleProduct: 'SaleProduct'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "customer" | "service" | "sale" | "saleService" | "saleStaff" | "discountRule" | "saleDiscount" | "customerDiscount" | "salePayment" | "product" | "saleProduct"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Customer: {
        payload: Prisma.$CustomerPayload<ExtArgs>
        fields: Prisma.CustomerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CustomerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CustomerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          findFirst: {
            args: Prisma.CustomerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CustomerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          findMany: {
            args: Prisma.CustomerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>[]
          }
          create: {
            args: Prisma.CustomerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          createMany: {
            args: Prisma.CustomerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CustomerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>[]
          }
          delete: {
            args: Prisma.CustomerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          update: {
            args: Prisma.CustomerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          deleteMany: {
            args: Prisma.CustomerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CustomerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CustomerUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>[]
          }
          upsert: {
            args: Prisma.CustomerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          aggregate: {
            args: Prisma.CustomerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCustomer>
          }
          groupBy: {
            args: Prisma.CustomerGroupByArgs<ExtArgs>
            result: $Utils.Optional<CustomerGroupByOutputType>[]
          }
          count: {
            args: Prisma.CustomerCountArgs<ExtArgs>
            result: $Utils.Optional<CustomerCountAggregateOutputType> | number
          }
        }
      }
      Service: {
        payload: Prisma.$ServicePayload<ExtArgs>
        fields: Prisma.ServiceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ServiceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ServiceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          findFirst: {
            args: Prisma.ServiceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ServiceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          findMany: {
            args: Prisma.ServiceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>[]
          }
          create: {
            args: Prisma.ServiceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          createMany: {
            args: Prisma.ServiceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ServiceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>[]
          }
          delete: {
            args: Prisma.ServiceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          update: {
            args: Prisma.ServiceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          deleteMany: {
            args: Prisma.ServiceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ServiceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ServiceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>[]
          }
          upsert: {
            args: Prisma.ServiceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          aggregate: {
            args: Prisma.ServiceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateService>
          }
          groupBy: {
            args: Prisma.ServiceGroupByArgs<ExtArgs>
            result: $Utils.Optional<ServiceGroupByOutputType>[]
          }
          count: {
            args: Prisma.ServiceCountArgs<ExtArgs>
            result: $Utils.Optional<ServiceCountAggregateOutputType> | number
          }
        }
      }
      Sale: {
        payload: Prisma.$SalePayload<ExtArgs>
        fields: Prisma.SaleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SaleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SaleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalePayload>
          }
          findFirst: {
            args: Prisma.SaleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SaleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalePayload>
          }
          findMany: {
            args: Prisma.SaleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalePayload>[]
          }
          create: {
            args: Prisma.SaleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalePayload>
          }
          createMany: {
            args: Prisma.SaleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SaleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalePayload>[]
          }
          delete: {
            args: Prisma.SaleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalePayload>
          }
          update: {
            args: Prisma.SaleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalePayload>
          }
          deleteMany: {
            args: Prisma.SaleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SaleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SaleUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalePayload>[]
          }
          upsert: {
            args: Prisma.SaleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalePayload>
          }
          aggregate: {
            args: Prisma.SaleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSale>
          }
          groupBy: {
            args: Prisma.SaleGroupByArgs<ExtArgs>
            result: $Utils.Optional<SaleGroupByOutputType>[]
          }
          count: {
            args: Prisma.SaleCountArgs<ExtArgs>
            result: $Utils.Optional<SaleCountAggregateOutputType> | number
          }
        }
      }
      SaleService: {
        payload: Prisma.$SaleServicePayload<ExtArgs>
        fields: Prisma.SaleServiceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SaleServiceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaleServicePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SaleServiceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaleServicePayload>
          }
          findFirst: {
            args: Prisma.SaleServiceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaleServicePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SaleServiceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaleServicePayload>
          }
          findMany: {
            args: Prisma.SaleServiceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaleServicePayload>[]
          }
          create: {
            args: Prisma.SaleServiceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaleServicePayload>
          }
          createMany: {
            args: Prisma.SaleServiceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SaleServiceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaleServicePayload>[]
          }
          delete: {
            args: Prisma.SaleServiceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaleServicePayload>
          }
          update: {
            args: Prisma.SaleServiceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaleServicePayload>
          }
          deleteMany: {
            args: Prisma.SaleServiceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SaleServiceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SaleServiceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaleServicePayload>[]
          }
          upsert: {
            args: Prisma.SaleServiceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaleServicePayload>
          }
          aggregate: {
            args: Prisma.SaleServiceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSaleService>
          }
          groupBy: {
            args: Prisma.SaleServiceGroupByArgs<ExtArgs>
            result: $Utils.Optional<SaleServiceGroupByOutputType>[]
          }
          count: {
            args: Prisma.SaleServiceCountArgs<ExtArgs>
            result: $Utils.Optional<SaleServiceCountAggregateOutputType> | number
          }
        }
      }
      SaleStaff: {
        payload: Prisma.$SaleStaffPayload<ExtArgs>
        fields: Prisma.SaleStaffFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SaleStaffFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaleStaffPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SaleStaffFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaleStaffPayload>
          }
          findFirst: {
            args: Prisma.SaleStaffFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaleStaffPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SaleStaffFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaleStaffPayload>
          }
          findMany: {
            args: Prisma.SaleStaffFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaleStaffPayload>[]
          }
          create: {
            args: Prisma.SaleStaffCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaleStaffPayload>
          }
          createMany: {
            args: Prisma.SaleStaffCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SaleStaffCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaleStaffPayload>[]
          }
          delete: {
            args: Prisma.SaleStaffDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaleStaffPayload>
          }
          update: {
            args: Prisma.SaleStaffUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaleStaffPayload>
          }
          deleteMany: {
            args: Prisma.SaleStaffDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SaleStaffUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SaleStaffUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaleStaffPayload>[]
          }
          upsert: {
            args: Prisma.SaleStaffUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaleStaffPayload>
          }
          aggregate: {
            args: Prisma.SaleStaffAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSaleStaff>
          }
          groupBy: {
            args: Prisma.SaleStaffGroupByArgs<ExtArgs>
            result: $Utils.Optional<SaleStaffGroupByOutputType>[]
          }
          count: {
            args: Prisma.SaleStaffCountArgs<ExtArgs>
            result: $Utils.Optional<SaleStaffCountAggregateOutputType> | number
          }
        }
      }
      DiscountRule: {
        payload: Prisma.$DiscountRulePayload<ExtArgs>
        fields: Prisma.DiscountRuleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DiscountRuleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiscountRulePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DiscountRuleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiscountRulePayload>
          }
          findFirst: {
            args: Prisma.DiscountRuleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiscountRulePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DiscountRuleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiscountRulePayload>
          }
          findMany: {
            args: Prisma.DiscountRuleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiscountRulePayload>[]
          }
          create: {
            args: Prisma.DiscountRuleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiscountRulePayload>
          }
          createMany: {
            args: Prisma.DiscountRuleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DiscountRuleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiscountRulePayload>[]
          }
          delete: {
            args: Prisma.DiscountRuleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiscountRulePayload>
          }
          update: {
            args: Prisma.DiscountRuleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiscountRulePayload>
          }
          deleteMany: {
            args: Prisma.DiscountRuleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DiscountRuleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DiscountRuleUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiscountRulePayload>[]
          }
          upsert: {
            args: Prisma.DiscountRuleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiscountRulePayload>
          }
          aggregate: {
            args: Prisma.DiscountRuleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDiscountRule>
          }
          groupBy: {
            args: Prisma.DiscountRuleGroupByArgs<ExtArgs>
            result: $Utils.Optional<DiscountRuleGroupByOutputType>[]
          }
          count: {
            args: Prisma.DiscountRuleCountArgs<ExtArgs>
            result: $Utils.Optional<DiscountRuleCountAggregateOutputType> | number
          }
        }
      }
      SaleDiscount: {
        payload: Prisma.$SaleDiscountPayload<ExtArgs>
        fields: Prisma.SaleDiscountFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SaleDiscountFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaleDiscountPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SaleDiscountFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaleDiscountPayload>
          }
          findFirst: {
            args: Prisma.SaleDiscountFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaleDiscountPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SaleDiscountFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaleDiscountPayload>
          }
          findMany: {
            args: Prisma.SaleDiscountFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaleDiscountPayload>[]
          }
          create: {
            args: Prisma.SaleDiscountCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaleDiscountPayload>
          }
          createMany: {
            args: Prisma.SaleDiscountCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SaleDiscountCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaleDiscountPayload>[]
          }
          delete: {
            args: Prisma.SaleDiscountDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaleDiscountPayload>
          }
          update: {
            args: Prisma.SaleDiscountUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaleDiscountPayload>
          }
          deleteMany: {
            args: Prisma.SaleDiscountDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SaleDiscountUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SaleDiscountUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaleDiscountPayload>[]
          }
          upsert: {
            args: Prisma.SaleDiscountUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaleDiscountPayload>
          }
          aggregate: {
            args: Prisma.SaleDiscountAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSaleDiscount>
          }
          groupBy: {
            args: Prisma.SaleDiscountGroupByArgs<ExtArgs>
            result: $Utils.Optional<SaleDiscountGroupByOutputType>[]
          }
          count: {
            args: Prisma.SaleDiscountCountArgs<ExtArgs>
            result: $Utils.Optional<SaleDiscountCountAggregateOutputType> | number
          }
        }
      }
      CustomerDiscount: {
        payload: Prisma.$CustomerDiscountPayload<ExtArgs>
        fields: Prisma.CustomerDiscountFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CustomerDiscountFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerDiscountPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CustomerDiscountFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerDiscountPayload>
          }
          findFirst: {
            args: Prisma.CustomerDiscountFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerDiscountPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CustomerDiscountFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerDiscountPayload>
          }
          findMany: {
            args: Prisma.CustomerDiscountFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerDiscountPayload>[]
          }
          create: {
            args: Prisma.CustomerDiscountCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerDiscountPayload>
          }
          createMany: {
            args: Prisma.CustomerDiscountCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CustomerDiscountCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerDiscountPayload>[]
          }
          delete: {
            args: Prisma.CustomerDiscountDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerDiscountPayload>
          }
          update: {
            args: Prisma.CustomerDiscountUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerDiscountPayload>
          }
          deleteMany: {
            args: Prisma.CustomerDiscountDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CustomerDiscountUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CustomerDiscountUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerDiscountPayload>[]
          }
          upsert: {
            args: Prisma.CustomerDiscountUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerDiscountPayload>
          }
          aggregate: {
            args: Prisma.CustomerDiscountAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCustomerDiscount>
          }
          groupBy: {
            args: Prisma.CustomerDiscountGroupByArgs<ExtArgs>
            result: $Utils.Optional<CustomerDiscountGroupByOutputType>[]
          }
          count: {
            args: Prisma.CustomerDiscountCountArgs<ExtArgs>
            result: $Utils.Optional<CustomerDiscountCountAggregateOutputType> | number
          }
        }
      }
      SalePayment: {
        payload: Prisma.$SalePaymentPayload<ExtArgs>
        fields: Prisma.SalePaymentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SalePaymentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalePaymentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SalePaymentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalePaymentPayload>
          }
          findFirst: {
            args: Prisma.SalePaymentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalePaymentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SalePaymentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalePaymentPayload>
          }
          findMany: {
            args: Prisma.SalePaymentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalePaymentPayload>[]
          }
          create: {
            args: Prisma.SalePaymentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalePaymentPayload>
          }
          createMany: {
            args: Prisma.SalePaymentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SalePaymentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalePaymentPayload>[]
          }
          delete: {
            args: Prisma.SalePaymentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalePaymentPayload>
          }
          update: {
            args: Prisma.SalePaymentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalePaymentPayload>
          }
          deleteMany: {
            args: Prisma.SalePaymentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SalePaymentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SalePaymentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalePaymentPayload>[]
          }
          upsert: {
            args: Prisma.SalePaymentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalePaymentPayload>
          }
          aggregate: {
            args: Prisma.SalePaymentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSalePayment>
          }
          groupBy: {
            args: Prisma.SalePaymentGroupByArgs<ExtArgs>
            result: $Utils.Optional<SalePaymentGroupByOutputType>[]
          }
          count: {
            args: Prisma.SalePaymentCountArgs<ExtArgs>
            result: $Utils.Optional<SalePaymentCountAggregateOutputType> | number
          }
        }
      }
      Product: {
        payload: Prisma.$ProductPayload<ExtArgs>
        fields: Prisma.ProductFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          findFirst: {
            args: Prisma.ProductFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          findMany: {
            args: Prisma.ProductFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>[]
          }
          create: {
            args: Prisma.ProductCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          createMany: {
            args: Prisma.ProductCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProductCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>[]
          }
          delete: {
            args: Prisma.ProductDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          update: {
            args: Prisma.ProductUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          deleteMany: {
            args: Prisma.ProductDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProductUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>[]
          }
          upsert: {
            args: Prisma.ProductUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          aggregate: {
            args: Prisma.ProductAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProduct>
          }
          groupBy: {
            args: Prisma.ProductGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductCountArgs<ExtArgs>
            result: $Utils.Optional<ProductCountAggregateOutputType> | number
          }
        }
      }
      SaleProduct: {
        payload: Prisma.$SaleProductPayload<ExtArgs>
        fields: Prisma.SaleProductFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SaleProductFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaleProductPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SaleProductFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaleProductPayload>
          }
          findFirst: {
            args: Prisma.SaleProductFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaleProductPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SaleProductFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaleProductPayload>
          }
          findMany: {
            args: Prisma.SaleProductFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaleProductPayload>[]
          }
          create: {
            args: Prisma.SaleProductCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaleProductPayload>
          }
          createMany: {
            args: Prisma.SaleProductCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SaleProductCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaleProductPayload>[]
          }
          delete: {
            args: Prisma.SaleProductDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaleProductPayload>
          }
          update: {
            args: Prisma.SaleProductUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaleProductPayload>
          }
          deleteMany: {
            args: Prisma.SaleProductDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SaleProductUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SaleProductUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaleProductPayload>[]
          }
          upsert: {
            args: Prisma.SaleProductUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaleProductPayload>
          }
          aggregate: {
            args: Prisma.SaleProductAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSaleProduct>
          }
          groupBy: {
            args: Prisma.SaleProductGroupByArgs<ExtArgs>
            result: $Utils.Optional<SaleProductGroupByOutputType>[]
          }
          count: {
            args: Prisma.SaleProductCountArgs<ExtArgs>
            result: $Utils.Optional<SaleProductCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory | null
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    customer?: CustomerOmit
    service?: ServiceOmit
    sale?: SaleOmit
    saleService?: SaleServiceOmit
    saleStaff?: SaleStaffOmit
    discountRule?: DiscountRuleOmit
    saleDiscount?: SaleDiscountOmit
    customerDiscount?: CustomerDiscountOmit
    salePayment?: SalePaymentOmit
    product?: ProductOmit
    saleProduct?: SaleProductOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    staffSales: number
    sales: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    staffSales?: boolean | UserCountOutputTypeCountStaffSalesArgs
    sales?: boolean | UserCountOutputTypeCountSalesArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountStaffSalesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SaleStaffWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSalesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SaleWhereInput
  }


  /**
   * Count Type CustomerCountOutputType
   */

  export type CustomerCountOutputType = {
    discounts: number
    dependents: number
    sales: number
  }

  export type CustomerCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    discounts?: boolean | CustomerCountOutputTypeCountDiscountsArgs
    dependents?: boolean | CustomerCountOutputTypeCountDependentsArgs
    sales?: boolean | CustomerCountOutputTypeCountSalesArgs
  }

  // Custom InputTypes
  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerCountOutputType
     */
    select?: CustomerCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeCountDiscountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomerDiscountWhereInput
  }

  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeCountDependentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomerWhereInput
  }

  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeCountSalesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SaleWhereInput
  }


  /**
   * Count Type ServiceCountOutputType
   */

  export type ServiceCountOutputType = {
    saleServices: number
  }

  export type ServiceCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    saleServices?: boolean | ServiceCountOutputTypeCountSaleServicesArgs
  }

  // Custom InputTypes
  /**
   * ServiceCountOutputType without action
   */
  export type ServiceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceCountOutputType
     */
    select?: ServiceCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ServiceCountOutputType without action
   */
  export type ServiceCountOutputTypeCountSaleServicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SaleServiceWhereInput
  }


  /**
   * Count Type SaleCountOutputType
   */

  export type SaleCountOutputType = {
    discounts: number
    services: number
    products: number
    staff: number
    payments: number
  }

  export type SaleCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    discounts?: boolean | SaleCountOutputTypeCountDiscountsArgs
    services?: boolean | SaleCountOutputTypeCountServicesArgs
    products?: boolean | SaleCountOutputTypeCountProductsArgs
    staff?: boolean | SaleCountOutputTypeCountStaffArgs
    payments?: boolean | SaleCountOutputTypeCountPaymentsArgs
  }

  // Custom InputTypes
  /**
   * SaleCountOutputType without action
   */
  export type SaleCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleCountOutputType
     */
    select?: SaleCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SaleCountOutputType without action
   */
  export type SaleCountOutputTypeCountDiscountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SaleDiscountWhereInput
  }

  /**
   * SaleCountOutputType without action
   */
  export type SaleCountOutputTypeCountServicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SaleServiceWhereInput
  }

  /**
   * SaleCountOutputType without action
   */
  export type SaleCountOutputTypeCountProductsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SaleProductWhereInput
  }

  /**
   * SaleCountOutputType without action
   */
  export type SaleCountOutputTypeCountStaffArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SaleStaffWhereInput
  }

  /**
   * SaleCountOutputType without action
   */
  export type SaleCountOutputTypeCountPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SalePaymentWhereInput
  }


  /**
   * Count Type DiscountRuleCountOutputType
   */

  export type DiscountRuleCountOutputType = {
    customerDiscounts: number
    saleDiscounts: number
  }

  export type DiscountRuleCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customerDiscounts?: boolean | DiscountRuleCountOutputTypeCountCustomerDiscountsArgs
    saleDiscounts?: boolean | DiscountRuleCountOutputTypeCountSaleDiscountsArgs
  }

  // Custom InputTypes
  /**
   * DiscountRuleCountOutputType without action
   */
  export type DiscountRuleCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DiscountRuleCountOutputType
     */
    select?: DiscountRuleCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DiscountRuleCountOutputType without action
   */
  export type DiscountRuleCountOutputTypeCountCustomerDiscountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomerDiscountWhereInput
  }

  /**
   * DiscountRuleCountOutputType without action
   */
  export type DiscountRuleCountOutputTypeCountSaleDiscountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SaleDiscountWhereInput
  }


  /**
   * Count Type ProductCountOutputType
   */

  export type ProductCountOutputType = {
    saleProducts: number
  }

  export type ProductCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    saleProducts?: boolean | ProductCountOutputTypeCountSaleProductsArgs
  }

  // Custom InputTypes
  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCountOutputType
     */
    select?: ProductCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountSaleProductsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SaleProductWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    password: string | null
    role: $Enums.Role | null
    phone: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    profilePicture: string | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    password: string | null
    role: $Enums.Role | null
    phone: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    profilePicture: string | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    name: number
    email: number
    password: number
    role: number
    phone: number
    isActive: number
    createdAt: number
    updatedAt: number
    profilePicture: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    name?: true
    email?: true
    password?: true
    role?: true
    phone?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    profilePicture?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    name?: true
    email?: true
    password?: true
    role?: true
    phone?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    profilePicture?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    name?: true
    email?: true
    password?: true
    role?: true
    phone?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    profilePicture?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    name: string
    email: string | null
    password: string
    role: $Enums.Role
    phone: string
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    profilePicture: string | null
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    password?: boolean
    role?: boolean
    phone?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    profilePicture?: boolean
    staffSales?: boolean | User$staffSalesArgs<ExtArgs>
    sales?: boolean | User$salesArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    password?: boolean
    role?: boolean
    phone?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    profilePicture?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    password?: boolean
    role?: boolean
    phone?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    profilePicture?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    name?: boolean
    email?: boolean
    password?: boolean
    role?: boolean
    phone?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    profilePicture?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "email" | "password" | "role" | "phone" | "isActive" | "createdAt" | "updatedAt" | "profilePicture", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    staffSales?: boolean | User$staffSalesArgs<ExtArgs>
    sales?: boolean | User$salesArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      staffSales: Prisma.$SaleStaffPayload<ExtArgs>[]
      sales: Prisma.$SalePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      email: string | null
      password: string
      role: $Enums.Role
      phone: string
      isActive: boolean
      createdAt: Date
      updatedAt: Date
      profilePicture: string | null
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    staffSales<T extends User$staffSalesArgs<ExtArgs> = {}>(args?: Subset<T, User$staffSalesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SaleStaffPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sales<T extends User$salesArgs<ExtArgs> = {}>(args?: Subset<T, User$salesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'Role'>
    readonly phone: FieldRef<"User", 'String'>
    readonly isActive: FieldRef<"User", 'Boolean'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
    readonly profilePicture: FieldRef<"User", 'String'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.staffSales
   */
  export type User$staffSalesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleStaff
     */
    select?: SaleStaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SaleStaff
     */
    omit?: SaleStaffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleStaffInclude<ExtArgs> | null
    where?: SaleStaffWhereInput
    orderBy?: SaleStaffOrderByWithRelationInput | SaleStaffOrderByWithRelationInput[]
    cursor?: SaleStaffWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SaleStaffScalarFieldEnum | SaleStaffScalarFieldEnum[]
  }

  /**
   * User.sales
   */
  export type User$salesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sale
     */
    select?: SaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sale
     */
    omit?: SaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleInclude<ExtArgs> | null
    where?: SaleWhereInput
    orderBy?: SaleOrderByWithRelationInput | SaleOrderByWithRelationInput[]
    cursor?: SaleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SaleScalarFieldEnum | SaleScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Customer
   */

  export type AggregateCustomer = {
    _count: CustomerCountAggregateOutputType | null
    _avg: CustomerAvgAggregateOutputType | null
    _sum: CustomerSumAggregateOutputType | null
    _min: CustomerMinAggregateOutputType | null
    _max: CustomerMaxAggregateOutputType | null
  }

  export type CustomerAvgAggregateOutputType = {
    birthDay: number | null
    birthMonth: number | null
    birthYear: number | null
    loyaltyPoints: number | null
    totalSpent: Decimal | null
    saleCount: number | null
  }

  export type CustomerSumAggregateOutputType = {
    birthDay: number | null
    birthMonth: number | null
    birthYear: number | null
    loyaltyPoints: number | null
    totalSpent: Decimal | null
    saleCount: number | null
  }

  export type CustomerMinAggregateOutputType = {
    id: string | null
    fullName: string | null
    gender: $Enums.Gender | null
    location: string | null
    district: string | null
    province: string | null
    phone: string | null
    email: string | null
    birthDay: number | null
    birthMonth: number | null
    birthYear: number | null
    loyaltyPoints: number | null
    totalSpent: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
    isActive: boolean | null
    additionalLocation: string | null
    isDependent: boolean | null
    lastSale: Date | null
    parentId: string | null
    saleCount: number | null
    sector: string | null
  }

  export type CustomerMaxAggregateOutputType = {
    id: string | null
    fullName: string | null
    gender: $Enums.Gender | null
    location: string | null
    district: string | null
    province: string | null
    phone: string | null
    email: string | null
    birthDay: number | null
    birthMonth: number | null
    birthYear: number | null
    loyaltyPoints: number | null
    totalSpent: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
    isActive: boolean | null
    additionalLocation: string | null
    isDependent: boolean | null
    lastSale: Date | null
    parentId: string | null
    saleCount: number | null
    sector: string | null
  }

  export type CustomerCountAggregateOutputType = {
    id: number
    fullName: number
    gender: number
    location: number
    district: number
    province: number
    phone: number
    email: number
    birthDay: number
    birthMonth: number
    birthYear: number
    loyaltyPoints: number
    totalSpent: number
    createdAt: number
    updatedAt: number
    isActive: number
    additionalLocation: number
    isDependent: number
    lastSale: number
    parentId: number
    saleCount: number
    sector: number
    _all: number
  }


  export type CustomerAvgAggregateInputType = {
    birthDay?: true
    birthMonth?: true
    birthYear?: true
    loyaltyPoints?: true
    totalSpent?: true
    saleCount?: true
  }

  export type CustomerSumAggregateInputType = {
    birthDay?: true
    birthMonth?: true
    birthYear?: true
    loyaltyPoints?: true
    totalSpent?: true
    saleCount?: true
  }

  export type CustomerMinAggregateInputType = {
    id?: true
    fullName?: true
    gender?: true
    location?: true
    district?: true
    province?: true
    phone?: true
    email?: true
    birthDay?: true
    birthMonth?: true
    birthYear?: true
    loyaltyPoints?: true
    totalSpent?: true
    createdAt?: true
    updatedAt?: true
    isActive?: true
    additionalLocation?: true
    isDependent?: true
    lastSale?: true
    parentId?: true
    saleCount?: true
    sector?: true
  }

  export type CustomerMaxAggregateInputType = {
    id?: true
    fullName?: true
    gender?: true
    location?: true
    district?: true
    province?: true
    phone?: true
    email?: true
    birthDay?: true
    birthMonth?: true
    birthYear?: true
    loyaltyPoints?: true
    totalSpent?: true
    createdAt?: true
    updatedAt?: true
    isActive?: true
    additionalLocation?: true
    isDependent?: true
    lastSale?: true
    parentId?: true
    saleCount?: true
    sector?: true
  }

  export type CustomerCountAggregateInputType = {
    id?: true
    fullName?: true
    gender?: true
    location?: true
    district?: true
    province?: true
    phone?: true
    email?: true
    birthDay?: true
    birthMonth?: true
    birthYear?: true
    loyaltyPoints?: true
    totalSpent?: true
    createdAt?: true
    updatedAt?: true
    isActive?: true
    additionalLocation?: true
    isDependent?: true
    lastSale?: true
    parentId?: true
    saleCount?: true
    sector?: true
    _all?: true
  }

  export type CustomerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Customer to aggregate.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Customers
    **/
    _count?: true | CustomerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CustomerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CustomerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CustomerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CustomerMaxAggregateInputType
  }

  export type GetCustomerAggregateType<T extends CustomerAggregateArgs> = {
        [P in keyof T & keyof AggregateCustomer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCustomer[P]>
      : GetScalarType<T[P], AggregateCustomer[P]>
  }




  export type CustomerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomerWhereInput
    orderBy?: CustomerOrderByWithAggregationInput | CustomerOrderByWithAggregationInput[]
    by: CustomerScalarFieldEnum[] | CustomerScalarFieldEnum
    having?: CustomerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CustomerCountAggregateInputType | true
    _avg?: CustomerAvgAggregateInputType
    _sum?: CustomerSumAggregateInputType
    _min?: CustomerMinAggregateInputType
    _max?: CustomerMaxAggregateInputType
  }

  export type CustomerGroupByOutputType = {
    id: string
    fullName: string
    gender: $Enums.Gender
    location: string
    district: string
    province: string
    phone: string | null
    email: string | null
    birthDay: number
    birthMonth: number
    birthYear: number | null
    loyaltyPoints: number
    totalSpent: Decimal
    createdAt: Date
    updatedAt: Date
    isActive: boolean
    additionalLocation: string | null
    isDependent: boolean
    lastSale: Date | null
    parentId: string | null
    saleCount: number
    sector: string | null
    _count: CustomerCountAggregateOutputType | null
    _avg: CustomerAvgAggregateOutputType | null
    _sum: CustomerSumAggregateOutputType | null
    _min: CustomerMinAggregateOutputType | null
    _max: CustomerMaxAggregateOutputType | null
  }

  type GetCustomerGroupByPayload<T extends CustomerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CustomerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CustomerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CustomerGroupByOutputType[P]>
            : GetScalarType<T[P], CustomerGroupByOutputType[P]>
        }
      >
    >


  export type CustomerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    fullName?: boolean
    gender?: boolean
    location?: boolean
    district?: boolean
    province?: boolean
    phone?: boolean
    email?: boolean
    birthDay?: boolean
    birthMonth?: boolean
    birthYear?: boolean
    loyaltyPoints?: boolean
    totalSpent?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isActive?: boolean
    additionalLocation?: boolean
    isDependent?: boolean
    lastSale?: boolean
    parentId?: boolean
    saleCount?: boolean
    sector?: boolean
    discounts?: boolean | Customer$discountsArgs<ExtArgs>
    parent?: boolean | Customer$parentArgs<ExtArgs>
    dependents?: boolean | Customer$dependentsArgs<ExtArgs>
    sales?: boolean | Customer$salesArgs<ExtArgs>
    _count?: boolean | CustomerCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customer"]>

  export type CustomerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    fullName?: boolean
    gender?: boolean
    location?: boolean
    district?: boolean
    province?: boolean
    phone?: boolean
    email?: boolean
    birthDay?: boolean
    birthMonth?: boolean
    birthYear?: boolean
    loyaltyPoints?: boolean
    totalSpent?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isActive?: boolean
    additionalLocation?: boolean
    isDependent?: boolean
    lastSale?: boolean
    parentId?: boolean
    saleCount?: boolean
    sector?: boolean
    parent?: boolean | Customer$parentArgs<ExtArgs>
  }, ExtArgs["result"]["customer"]>

  export type CustomerSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    fullName?: boolean
    gender?: boolean
    location?: boolean
    district?: boolean
    province?: boolean
    phone?: boolean
    email?: boolean
    birthDay?: boolean
    birthMonth?: boolean
    birthYear?: boolean
    loyaltyPoints?: boolean
    totalSpent?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isActive?: boolean
    additionalLocation?: boolean
    isDependent?: boolean
    lastSale?: boolean
    parentId?: boolean
    saleCount?: boolean
    sector?: boolean
    parent?: boolean | Customer$parentArgs<ExtArgs>
  }, ExtArgs["result"]["customer"]>

  export type CustomerSelectScalar = {
    id?: boolean
    fullName?: boolean
    gender?: boolean
    location?: boolean
    district?: boolean
    province?: boolean
    phone?: boolean
    email?: boolean
    birthDay?: boolean
    birthMonth?: boolean
    birthYear?: boolean
    loyaltyPoints?: boolean
    totalSpent?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isActive?: boolean
    additionalLocation?: boolean
    isDependent?: boolean
    lastSale?: boolean
    parentId?: boolean
    saleCount?: boolean
    sector?: boolean
  }

  export type CustomerOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "fullName" | "gender" | "location" | "district" | "province" | "phone" | "email" | "birthDay" | "birthMonth" | "birthYear" | "loyaltyPoints" | "totalSpent" | "createdAt" | "updatedAt" | "isActive" | "additionalLocation" | "isDependent" | "lastSale" | "parentId" | "saleCount" | "sector", ExtArgs["result"]["customer"]>
  export type CustomerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    discounts?: boolean | Customer$discountsArgs<ExtArgs>
    parent?: boolean | Customer$parentArgs<ExtArgs>
    dependents?: boolean | Customer$dependentsArgs<ExtArgs>
    sales?: boolean | Customer$salesArgs<ExtArgs>
    _count?: boolean | CustomerCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CustomerIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parent?: boolean | Customer$parentArgs<ExtArgs>
  }
  export type CustomerIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parent?: boolean | Customer$parentArgs<ExtArgs>
  }

  export type $CustomerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Customer"
    objects: {
      discounts: Prisma.$CustomerDiscountPayload<ExtArgs>[]
      parent: Prisma.$CustomerPayload<ExtArgs> | null
      dependents: Prisma.$CustomerPayload<ExtArgs>[]
      sales: Prisma.$SalePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      fullName: string
      gender: $Enums.Gender
      location: string
      district: string
      province: string
      phone: string | null
      email: string | null
      birthDay: number
      birthMonth: number
      birthYear: number | null
      loyaltyPoints: number
      totalSpent: Prisma.Decimal
      createdAt: Date
      updatedAt: Date
      isActive: boolean
      additionalLocation: string | null
      isDependent: boolean
      lastSale: Date | null
      parentId: string | null
      saleCount: number
      sector: string | null
    }, ExtArgs["result"]["customer"]>
    composites: {}
  }

  type CustomerGetPayload<S extends boolean | null | undefined | CustomerDefaultArgs> = $Result.GetResult<Prisma.$CustomerPayload, S>

  type CustomerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CustomerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CustomerCountAggregateInputType | true
    }

  export interface CustomerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Customer'], meta: { name: 'Customer' } }
    /**
     * Find zero or one Customer that matches the filter.
     * @param {CustomerFindUniqueArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CustomerFindUniqueArgs>(args: SelectSubset<T, CustomerFindUniqueArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Customer that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CustomerFindUniqueOrThrowArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CustomerFindUniqueOrThrowArgs>(args: SelectSubset<T, CustomerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Customer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerFindFirstArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CustomerFindFirstArgs>(args?: SelectSubset<T, CustomerFindFirstArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Customer that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerFindFirstOrThrowArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CustomerFindFirstOrThrowArgs>(args?: SelectSubset<T, CustomerFindFirstOrThrowArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Customers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Customers
     * const customers = await prisma.customer.findMany()
     * 
     * // Get first 10 Customers
     * const customers = await prisma.customer.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const customerWithIdOnly = await prisma.customer.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CustomerFindManyArgs>(args?: SelectSubset<T, CustomerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Customer.
     * @param {CustomerCreateArgs} args - Arguments to create a Customer.
     * @example
     * // Create one Customer
     * const Customer = await prisma.customer.create({
     *   data: {
     *     // ... data to create a Customer
     *   }
     * })
     * 
     */
    create<T extends CustomerCreateArgs>(args: SelectSubset<T, CustomerCreateArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Customers.
     * @param {CustomerCreateManyArgs} args - Arguments to create many Customers.
     * @example
     * // Create many Customers
     * const customer = await prisma.customer.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CustomerCreateManyArgs>(args?: SelectSubset<T, CustomerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Customers and returns the data saved in the database.
     * @param {CustomerCreateManyAndReturnArgs} args - Arguments to create many Customers.
     * @example
     * // Create many Customers
     * const customer = await prisma.customer.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Customers and only return the `id`
     * const customerWithIdOnly = await prisma.customer.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CustomerCreateManyAndReturnArgs>(args?: SelectSubset<T, CustomerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Customer.
     * @param {CustomerDeleteArgs} args - Arguments to delete one Customer.
     * @example
     * // Delete one Customer
     * const Customer = await prisma.customer.delete({
     *   where: {
     *     // ... filter to delete one Customer
     *   }
     * })
     * 
     */
    delete<T extends CustomerDeleteArgs>(args: SelectSubset<T, CustomerDeleteArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Customer.
     * @param {CustomerUpdateArgs} args - Arguments to update one Customer.
     * @example
     * // Update one Customer
     * const customer = await prisma.customer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CustomerUpdateArgs>(args: SelectSubset<T, CustomerUpdateArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Customers.
     * @param {CustomerDeleteManyArgs} args - Arguments to filter Customers to delete.
     * @example
     * // Delete a few Customers
     * const { count } = await prisma.customer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CustomerDeleteManyArgs>(args?: SelectSubset<T, CustomerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Customers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Customers
     * const customer = await prisma.customer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CustomerUpdateManyArgs>(args: SelectSubset<T, CustomerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Customers and returns the data updated in the database.
     * @param {CustomerUpdateManyAndReturnArgs} args - Arguments to update many Customers.
     * @example
     * // Update many Customers
     * const customer = await prisma.customer.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Customers and only return the `id`
     * const customerWithIdOnly = await prisma.customer.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CustomerUpdateManyAndReturnArgs>(args: SelectSubset<T, CustomerUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Customer.
     * @param {CustomerUpsertArgs} args - Arguments to update or create a Customer.
     * @example
     * // Update or create a Customer
     * const customer = await prisma.customer.upsert({
     *   create: {
     *     // ... data to create a Customer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Customer we want to update
     *   }
     * })
     */
    upsert<T extends CustomerUpsertArgs>(args: SelectSubset<T, CustomerUpsertArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Customers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerCountArgs} args - Arguments to filter Customers to count.
     * @example
     * // Count the number of Customers
     * const count = await prisma.customer.count({
     *   where: {
     *     // ... the filter for the Customers we want to count
     *   }
     * })
    **/
    count<T extends CustomerCountArgs>(
      args?: Subset<T, CustomerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CustomerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Customer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CustomerAggregateArgs>(args: Subset<T, CustomerAggregateArgs>): Prisma.PrismaPromise<GetCustomerAggregateType<T>>

    /**
     * Group by Customer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CustomerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CustomerGroupByArgs['orderBy'] }
        : { orderBy?: CustomerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CustomerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCustomerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Customer model
   */
  readonly fields: CustomerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Customer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CustomerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    discounts<T extends Customer$discountsArgs<ExtArgs> = {}>(args?: Subset<T, Customer$discountsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerDiscountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    parent<T extends Customer$parentArgs<ExtArgs> = {}>(args?: Subset<T, Customer$parentArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    dependents<T extends Customer$dependentsArgs<ExtArgs> = {}>(args?: Subset<T, Customer$dependentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sales<T extends Customer$salesArgs<ExtArgs> = {}>(args?: Subset<T, Customer$salesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Customer model
   */
  interface CustomerFieldRefs {
    readonly id: FieldRef<"Customer", 'String'>
    readonly fullName: FieldRef<"Customer", 'String'>
    readonly gender: FieldRef<"Customer", 'Gender'>
    readonly location: FieldRef<"Customer", 'String'>
    readonly district: FieldRef<"Customer", 'String'>
    readonly province: FieldRef<"Customer", 'String'>
    readonly phone: FieldRef<"Customer", 'String'>
    readonly email: FieldRef<"Customer", 'String'>
    readonly birthDay: FieldRef<"Customer", 'Int'>
    readonly birthMonth: FieldRef<"Customer", 'Int'>
    readonly birthYear: FieldRef<"Customer", 'Int'>
    readonly loyaltyPoints: FieldRef<"Customer", 'Int'>
    readonly totalSpent: FieldRef<"Customer", 'Decimal'>
    readonly createdAt: FieldRef<"Customer", 'DateTime'>
    readonly updatedAt: FieldRef<"Customer", 'DateTime'>
    readonly isActive: FieldRef<"Customer", 'Boolean'>
    readonly additionalLocation: FieldRef<"Customer", 'String'>
    readonly isDependent: FieldRef<"Customer", 'Boolean'>
    readonly lastSale: FieldRef<"Customer", 'DateTime'>
    readonly parentId: FieldRef<"Customer", 'String'>
    readonly saleCount: FieldRef<"Customer", 'Int'>
    readonly sector: FieldRef<"Customer", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Customer findUnique
   */
  export type CustomerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where: CustomerWhereUniqueInput
  }

  /**
   * Customer findUniqueOrThrow
   */
  export type CustomerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where: CustomerWhereUniqueInput
  }

  /**
   * Customer findFirst
   */
  export type CustomerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Customers.
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Customers.
     */
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }

  /**
   * Customer findFirstOrThrow
   */
  export type CustomerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Customers.
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Customers.
     */
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }

  /**
   * Customer findMany
   */
  export type CustomerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customers to fetch.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Customers.
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }

  /**
   * Customer create
   */
  export type CustomerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * The data needed to create a Customer.
     */
    data: XOR<CustomerCreateInput, CustomerUncheckedCreateInput>
  }

  /**
   * Customer createMany
   */
  export type CustomerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Customers.
     */
    data: CustomerCreateManyInput | CustomerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Customer createManyAndReturn
   */
  export type CustomerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * The data used to create many Customers.
     */
    data: CustomerCreateManyInput | CustomerCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Customer update
   */
  export type CustomerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * The data needed to update a Customer.
     */
    data: XOR<CustomerUpdateInput, CustomerUncheckedUpdateInput>
    /**
     * Choose, which Customer to update.
     */
    where: CustomerWhereUniqueInput
  }

  /**
   * Customer updateMany
   */
  export type CustomerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Customers.
     */
    data: XOR<CustomerUpdateManyMutationInput, CustomerUncheckedUpdateManyInput>
    /**
     * Filter which Customers to update
     */
    where?: CustomerWhereInput
    /**
     * Limit how many Customers to update.
     */
    limit?: number
  }

  /**
   * Customer updateManyAndReturn
   */
  export type CustomerUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * The data used to update Customers.
     */
    data: XOR<CustomerUpdateManyMutationInput, CustomerUncheckedUpdateManyInput>
    /**
     * Filter which Customers to update
     */
    where?: CustomerWhereInput
    /**
     * Limit how many Customers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Customer upsert
   */
  export type CustomerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * The filter to search for the Customer to update in case it exists.
     */
    where: CustomerWhereUniqueInput
    /**
     * In case the Customer found by the `where` argument doesn't exist, create a new Customer with this data.
     */
    create: XOR<CustomerCreateInput, CustomerUncheckedCreateInput>
    /**
     * In case the Customer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CustomerUpdateInput, CustomerUncheckedUpdateInput>
  }

  /**
   * Customer delete
   */
  export type CustomerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter which Customer to delete.
     */
    where: CustomerWhereUniqueInput
  }

  /**
   * Customer deleteMany
   */
  export type CustomerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Customers to delete
     */
    where?: CustomerWhereInput
    /**
     * Limit how many Customers to delete.
     */
    limit?: number
  }

  /**
   * Customer.discounts
   */
  export type Customer$discountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerDiscount
     */
    select?: CustomerDiscountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerDiscount
     */
    omit?: CustomerDiscountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerDiscountInclude<ExtArgs> | null
    where?: CustomerDiscountWhereInput
    orderBy?: CustomerDiscountOrderByWithRelationInput | CustomerDiscountOrderByWithRelationInput[]
    cursor?: CustomerDiscountWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CustomerDiscountScalarFieldEnum | CustomerDiscountScalarFieldEnum[]
  }

  /**
   * Customer.parent
   */
  export type Customer$parentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    where?: CustomerWhereInput
  }

  /**
   * Customer.dependents
   */
  export type Customer$dependentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    where?: CustomerWhereInput
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    cursor?: CustomerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }

  /**
   * Customer.sales
   */
  export type Customer$salesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sale
     */
    select?: SaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sale
     */
    omit?: SaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleInclude<ExtArgs> | null
    where?: SaleWhereInput
    orderBy?: SaleOrderByWithRelationInput | SaleOrderByWithRelationInput[]
    cursor?: SaleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SaleScalarFieldEnum | SaleScalarFieldEnum[]
  }

  /**
   * Customer without action
   */
  export type CustomerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
  }


  /**
   * Model Service
   */

  export type AggregateService = {
    _count: ServiceCountAggregateOutputType | null
    _avg: ServiceAvgAggregateOutputType | null
    _sum: ServiceSumAggregateOutputType | null
    _min: ServiceMinAggregateOutputType | null
    _max: ServiceMaxAggregateOutputType | null
  }

  export type ServiceAvgAggregateOutputType = {
    singlePrice: Decimal | null
    combinedPrice: Decimal | null
    childPrice: Decimal | null
    childCombinedPrice: Decimal | null
  }

  export type ServiceSumAggregateOutputType = {
    singlePrice: Decimal | null
    combinedPrice: Decimal | null
    childPrice: Decimal | null
    childCombinedPrice: Decimal | null
  }

  export type ServiceMinAggregateOutputType = {
    id: string | null
    name: string | null
    category: $Enums.ServiceCategory | null
    description: string | null
    singlePrice: Decimal | null
    combinedPrice: Decimal | null
    childPrice: Decimal | null
    childCombinedPrice: Decimal | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ServiceMaxAggregateOutputType = {
    id: string | null
    name: string | null
    category: $Enums.ServiceCategory | null
    description: string | null
    singlePrice: Decimal | null
    combinedPrice: Decimal | null
    childPrice: Decimal | null
    childCombinedPrice: Decimal | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ServiceCountAggregateOutputType = {
    id: number
    name: number
    category: number
    description: number
    singlePrice: number
    combinedPrice: number
    childPrice: number
    childCombinedPrice: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ServiceAvgAggregateInputType = {
    singlePrice?: true
    combinedPrice?: true
    childPrice?: true
    childCombinedPrice?: true
  }

  export type ServiceSumAggregateInputType = {
    singlePrice?: true
    combinedPrice?: true
    childPrice?: true
    childCombinedPrice?: true
  }

  export type ServiceMinAggregateInputType = {
    id?: true
    name?: true
    category?: true
    description?: true
    singlePrice?: true
    combinedPrice?: true
    childPrice?: true
    childCombinedPrice?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ServiceMaxAggregateInputType = {
    id?: true
    name?: true
    category?: true
    description?: true
    singlePrice?: true
    combinedPrice?: true
    childPrice?: true
    childCombinedPrice?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ServiceCountAggregateInputType = {
    id?: true
    name?: true
    category?: true
    description?: true
    singlePrice?: true
    combinedPrice?: true
    childPrice?: true
    childCombinedPrice?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ServiceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Service to aggregate.
     */
    where?: ServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Services to fetch.
     */
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Services.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Services
    **/
    _count?: true | ServiceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ServiceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ServiceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ServiceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ServiceMaxAggregateInputType
  }

  export type GetServiceAggregateType<T extends ServiceAggregateArgs> = {
        [P in keyof T & keyof AggregateService]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateService[P]>
      : GetScalarType<T[P], AggregateService[P]>
  }




  export type ServiceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceWhereInput
    orderBy?: ServiceOrderByWithAggregationInput | ServiceOrderByWithAggregationInput[]
    by: ServiceScalarFieldEnum[] | ServiceScalarFieldEnum
    having?: ServiceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ServiceCountAggregateInputType | true
    _avg?: ServiceAvgAggregateInputType
    _sum?: ServiceSumAggregateInputType
    _min?: ServiceMinAggregateInputType
    _max?: ServiceMaxAggregateInputType
  }

  export type ServiceGroupByOutputType = {
    id: string
    name: string
    category: $Enums.ServiceCategory
    description: string | null
    singlePrice: Decimal
    combinedPrice: Decimal | null
    childPrice: Decimal | null
    childCombinedPrice: Decimal | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: ServiceCountAggregateOutputType | null
    _avg: ServiceAvgAggregateOutputType | null
    _sum: ServiceSumAggregateOutputType | null
    _min: ServiceMinAggregateOutputType | null
    _max: ServiceMaxAggregateOutputType | null
  }

  type GetServiceGroupByPayload<T extends ServiceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ServiceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ServiceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ServiceGroupByOutputType[P]>
            : GetScalarType<T[P], ServiceGroupByOutputType[P]>
        }
      >
    >


  export type ServiceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    category?: boolean
    description?: boolean
    singlePrice?: boolean
    combinedPrice?: boolean
    childPrice?: boolean
    childCombinedPrice?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    saleServices?: boolean | Service$saleServicesArgs<ExtArgs>
    _count?: boolean | ServiceCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["service"]>

  export type ServiceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    category?: boolean
    description?: boolean
    singlePrice?: boolean
    combinedPrice?: boolean
    childPrice?: boolean
    childCombinedPrice?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["service"]>

  export type ServiceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    category?: boolean
    description?: boolean
    singlePrice?: boolean
    combinedPrice?: boolean
    childPrice?: boolean
    childCombinedPrice?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["service"]>

  export type ServiceSelectScalar = {
    id?: boolean
    name?: boolean
    category?: boolean
    description?: boolean
    singlePrice?: boolean
    combinedPrice?: boolean
    childPrice?: boolean
    childCombinedPrice?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ServiceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "category" | "description" | "singlePrice" | "combinedPrice" | "childPrice" | "childCombinedPrice" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["service"]>
  export type ServiceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    saleServices?: boolean | Service$saleServicesArgs<ExtArgs>
    _count?: boolean | ServiceCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ServiceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type ServiceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ServicePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Service"
    objects: {
      saleServices: Prisma.$SaleServicePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      category: $Enums.ServiceCategory
      description: string | null
      singlePrice: Prisma.Decimal
      combinedPrice: Prisma.Decimal | null
      childPrice: Prisma.Decimal | null
      childCombinedPrice: Prisma.Decimal | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["service"]>
    composites: {}
  }

  type ServiceGetPayload<S extends boolean | null | undefined | ServiceDefaultArgs> = $Result.GetResult<Prisma.$ServicePayload, S>

  type ServiceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ServiceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ServiceCountAggregateInputType | true
    }

  export interface ServiceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Service'], meta: { name: 'Service' } }
    /**
     * Find zero or one Service that matches the filter.
     * @param {ServiceFindUniqueArgs} args - Arguments to find a Service
     * @example
     * // Get one Service
     * const service = await prisma.service.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ServiceFindUniqueArgs>(args: SelectSubset<T, ServiceFindUniqueArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Service that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ServiceFindUniqueOrThrowArgs} args - Arguments to find a Service
     * @example
     * // Get one Service
     * const service = await prisma.service.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ServiceFindUniqueOrThrowArgs>(args: SelectSubset<T, ServiceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Service that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceFindFirstArgs} args - Arguments to find a Service
     * @example
     * // Get one Service
     * const service = await prisma.service.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ServiceFindFirstArgs>(args?: SelectSubset<T, ServiceFindFirstArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Service that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceFindFirstOrThrowArgs} args - Arguments to find a Service
     * @example
     * // Get one Service
     * const service = await prisma.service.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ServiceFindFirstOrThrowArgs>(args?: SelectSubset<T, ServiceFindFirstOrThrowArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Services that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Services
     * const services = await prisma.service.findMany()
     * 
     * // Get first 10 Services
     * const services = await prisma.service.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const serviceWithIdOnly = await prisma.service.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ServiceFindManyArgs>(args?: SelectSubset<T, ServiceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Service.
     * @param {ServiceCreateArgs} args - Arguments to create a Service.
     * @example
     * // Create one Service
     * const Service = await prisma.service.create({
     *   data: {
     *     // ... data to create a Service
     *   }
     * })
     * 
     */
    create<T extends ServiceCreateArgs>(args: SelectSubset<T, ServiceCreateArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Services.
     * @param {ServiceCreateManyArgs} args - Arguments to create many Services.
     * @example
     * // Create many Services
     * const service = await prisma.service.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ServiceCreateManyArgs>(args?: SelectSubset<T, ServiceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Services and returns the data saved in the database.
     * @param {ServiceCreateManyAndReturnArgs} args - Arguments to create many Services.
     * @example
     * // Create many Services
     * const service = await prisma.service.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Services and only return the `id`
     * const serviceWithIdOnly = await prisma.service.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ServiceCreateManyAndReturnArgs>(args?: SelectSubset<T, ServiceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Service.
     * @param {ServiceDeleteArgs} args - Arguments to delete one Service.
     * @example
     * // Delete one Service
     * const Service = await prisma.service.delete({
     *   where: {
     *     // ... filter to delete one Service
     *   }
     * })
     * 
     */
    delete<T extends ServiceDeleteArgs>(args: SelectSubset<T, ServiceDeleteArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Service.
     * @param {ServiceUpdateArgs} args - Arguments to update one Service.
     * @example
     * // Update one Service
     * const service = await prisma.service.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ServiceUpdateArgs>(args: SelectSubset<T, ServiceUpdateArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Services.
     * @param {ServiceDeleteManyArgs} args - Arguments to filter Services to delete.
     * @example
     * // Delete a few Services
     * const { count } = await prisma.service.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ServiceDeleteManyArgs>(args?: SelectSubset<T, ServiceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Services.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Services
     * const service = await prisma.service.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ServiceUpdateManyArgs>(args: SelectSubset<T, ServiceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Services and returns the data updated in the database.
     * @param {ServiceUpdateManyAndReturnArgs} args - Arguments to update many Services.
     * @example
     * // Update many Services
     * const service = await prisma.service.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Services and only return the `id`
     * const serviceWithIdOnly = await prisma.service.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ServiceUpdateManyAndReturnArgs>(args: SelectSubset<T, ServiceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Service.
     * @param {ServiceUpsertArgs} args - Arguments to update or create a Service.
     * @example
     * // Update or create a Service
     * const service = await prisma.service.upsert({
     *   create: {
     *     // ... data to create a Service
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Service we want to update
     *   }
     * })
     */
    upsert<T extends ServiceUpsertArgs>(args: SelectSubset<T, ServiceUpsertArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Services.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceCountArgs} args - Arguments to filter Services to count.
     * @example
     * // Count the number of Services
     * const count = await prisma.service.count({
     *   where: {
     *     // ... the filter for the Services we want to count
     *   }
     * })
    **/
    count<T extends ServiceCountArgs>(
      args?: Subset<T, ServiceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ServiceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Service.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ServiceAggregateArgs>(args: Subset<T, ServiceAggregateArgs>): Prisma.PrismaPromise<GetServiceAggregateType<T>>

    /**
     * Group by Service.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ServiceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ServiceGroupByArgs['orderBy'] }
        : { orderBy?: ServiceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ServiceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetServiceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Service model
   */
  readonly fields: ServiceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Service.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ServiceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    saleServices<T extends Service$saleServicesArgs<ExtArgs> = {}>(args?: Subset<T, Service$saleServicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SaleServicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Service model
   */
  interface ServiceFieldRefs {
    readonly id: FieldRef<"Service", 'String'>
    readonly name: FieldRef<"Service", 'String'>
    readonly category: FieldRef<"Service", 'ServiceCategory'>
    readonly description: FieldRef<"Service", 'String'>
    readonly singlePrice: FieldRef<"Service", 'Decimal'>
    readonly combinedPrice: FieldRef<"Service", 'Decimal'>
    readonly childPrice: FieldRef<"Service", 'Decimal'>
    readonly childCombinedPrice: FieldRef<"Service", 'Decimal'>
    readonly isActive: FieldRef<"Service", 'Boolean'>
    readonly createdAt: FieldRef<"Service", 'DateTime'>
    readonly updatedAt: FieldRef<"Service", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Service findUnique
   */
  export type ServiceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Service to fetch.
     */
    where: ServiceWhereUniqueInput
  }

  /**
   * Service findUniqueOrThrow
   */
  export type ServiceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Service to fetch.
     */
    where: ServiceWhereUniqueInput
  }

  /**
   * Service findFirst
   */
  export type ServiceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Service to fetch.
     */
    where?: ServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Services to fetch.
     */
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Services.
     */
    cursor?: ServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Services.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Services.
     */
    distinct?: ServiceScalarFieldEnum | ServiceScalarFieldEnum[]
  }

  /**
   * Service findFirstOrThrow
   */
  export type ServiceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Service to fetch.
     */
    where?: ServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Services to fetch.
     */
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Services.
     */
    cursor?: ServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Services.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Services.
     */
    distinct?: ServiceScalarFieldEnum | ServiceScalarFieldEnum[]
  }

  /**
   * Service findMany
   */
  export type ServiceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Services to fetch.
     */
    where?: ServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Services to fetch.
     */
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Services.
     */
    cursor?: ServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Services.
     */
    skip?: number
    distinct?: ServiceScalarFieldEnum | ServiceScalarFieldEnum[]
  }

  /**
   * Service create
   */
  export type ServiceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * The data needed to create a Service.
     */
    data: XOR<ServiceCreateInput, ServiceUncheckedCreateInput>
  }

  /**
   * Service createMany
   */
  export type ServiceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Services.
     */
    data: ServiceCreateManyInput | ServiceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Service createManyAndReturn
   */
  export type ServiceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * The data used to create many Services.
     */
    data: ServiceCreateManyInput | ServiceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Service update
   */
  export type ServiceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * The data needed to update a Service.
     */
    data: XOR<ServiceUpdateInput, ServiceUncheckedUpdateInput>
    /**
     * Choose, which Service to update.
     */
    where: ServiceWhereUniqueInput
  }

  /**
   * Service updateMany
   */
  export type ServiceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Services.
     */
    data: XOR<ServiceUpdateManyMutationInput, ServiceUncheckedUpdateManyInput>
    /**
     * Filter which Services to update
     */
    where?: ServiceWhereInput
    /**
     * Limit how many Services to update.
     */
    limit?: number
  }

  /**
   * Service updateManyAndReturn
   */
  export type ServiceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * The data used to update Services.
     */
    data: XOR<ServiceUpdateManyMutationInput, ServiceUncheckedUpdateManyInput>
    /**
     * Filter which Services to update
     */
    where?: ServiceWhereInput
    /**
     * Limit how many Services to update.
     */
    limit?: number
  }

  /**
   * Service upsert
   */
  export type ServiceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * The filter to search for the Service to update in case it exists.
     */
    where: ServiceWhereUniqueInput
    /**
     * In case the Service found by the `where` argument doesn't exist, create a new Service with this data.
     */
    create: XOR<ServiceCreateInput, ServiceUncheckedCreateInput>
    /**
     * In case the Service was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ServiceUpdateInput, ServiceUncheckedUpdateInput>
  }

  /**
   * Service delete
   */
  export type ServiceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter which Service to delete.
     */
    where: ServiceWhereUniqueInput
  }

  /**
   * Service deleteMany
   */
  export type ServiceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Services to delete
     */
    where?: ServiceWhereInput
    /**
     * Limit how many Services to delete.
     */
    limit?: number
  }

  /**
   * Service.saleServices
   */
  export type Service$saleServicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleService
     */
    select?: SaleServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SaleService
     */
    omit?: SaleServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleServiceInclude<ExtArgs> | null
    where?: SaleServiceWhereInput
    orderBy?: SaleServiceOrderByWithRelationInput | SaleServiceOrderByWithRelationInput[]
    cursor?: SaleServiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SaleServiceScalarFieldEnum | SaleServiceScalarFieldEnum[]
  }

  /**
   * Service without action
   */
  export type ServiceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
  }


  /**
   * Model Sale
   */

  export type AggregateSale = {
    _count: SaleCountAggregateOutputType | null
    _avg: SaleAvgAggregateOutputType | null
    _sum: SaleSumAggregateOutputType | null
    _min: SaleMinAggregateOutputType | null
    _max: SaleMaxAggregateOutputType | null
  }

  export type SaleAvgAggregateOutputType = {
    totalAmount: Decimal | null
    discountAmount: Decimal | null
    finalAmount: Decimal | null
    loyaltyPointsEarned: number | null
  }

  export type SaleSumAggregateOutputType = {
    totalAmount: Decimal | null
    discountAmount: Decimal | null
    finalAmount: Decimal | null
    loyaltyPointsEarned: number | null
  }

  export type SaleMinAggregateOutputType = {
    id: string | null
    customerId: string | null
    saleDate: Date | null
    totalAmount: Decimal | null
    discountAmount: Decimal | null
    finalAmount: Decimal | null
    loyaltyPointsEarned: number | null
    notes: string | null
    isCompleted: boolean | null
    createdById: string | null
    createdAt: Date | null
    updatedAt: Date | null
    birthMonthDiscount: boolean | null
    ownShampooDiscount: boolean | null
    paymentMethod: $Enums.PaymentMethod | null
  }

  export type SaleMaxAggregateOutputType = {
    id: string | null
    customerId: string | null
    saleDate: Date | null
    totalAmount: Decimal | null
    discountAmount: Decimal | null
    finalAmount: Decimal | null
    loyaltyPointsEarned: number | null
    notes: string | null
    isCompleted: boolean | null
    createdById: string | null
    createdAt: Date | null
    updatedAt: Date | null
    birthMonthDiscount: boolean | null
    ownShampooDiscount: boolean | null
    paymentMethod: $Enums.PaymentMethod | null
  }

  export type SaleCountAggregateOutputType = {
    id: number
    customerId: number
    saleDate: number
    totalAmount: number
    discountAmount: number
    finalAmount: number
    loyaltyPointsEarned: number
    notes: number
    isCompleted: number
    createdById: number
    createdAt: number
    updatedAt: number
    birthMonthDiscount: number
    ownShampooDiscount: number
    paymentMethod: number
    _all: number
  }


  export type SaleAvgAggregateInputType = {
    totalAmount?: true
    discountAmount?: true
    finalAmount?: true
    loyaltyPointsEarned?: true
  }

  export type SaleSumAggregateInputType = {
    totalAmount?: true
    discountAmount?: true
    finalAmount?: true
    loyaltyPointsEarned?: true
  }

  export type SaleMinAggregateInputType = {
    id?: true
    customerId?: true
    saleDate?: true
    totalAmount?: true
    discountAmount?: true
    finalAmount?: true
    loyaltyPointsEarned?: true
    notes?: true
    isCompleted?: true
    createdById?: true
    createdAt?: true
    updatedAt?: true
    birthMonthDiscount?: true
    ownShampooDiscount?: true
    paymentMethod?: true
  }

  export type SaleMaxAggregateInputType = {
    id?: true
    customerId?: true
    saleDate?: true
    totalAmount?: true
    discountAmount?: true
    finalAmount?: true
    loyaltyPointsEarned?: true
    notes?: true
    isCompleted?: true
    createdById?: true
    createdAt?: true
    updatedAt?: true
    birthMonthDiscount?: true
    ownShampooDiscount?: true
    paymentMethod?: true
  }

  export type SaleCountAggregateInputType = {
    id?: true
    customerId?: true
    saleDate?: true
    totalAmount?: true
    discountAmount?: true
    finalAmount?: true
    loyaltyPointsEarned?: true
    notes?: true
    isCompleted?: true
    createdById?: true
    createdAt?: true
    updatedAt?: true
    birthMonthDiscount?: true
    ownShampooDiscount?: true
    paymentMethod?: true
    _all?: true
  }

  export type SaleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sale to aggregate.
     */
    where?: SaleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sales to fetch.
     */
    orderBy?: SaleOrderByWithRelationInput | SaleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SaleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sales from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sales.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sales
    **/
    _count?: true | SaleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SaleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SaleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SaleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SaleMaxAggregateInputType
  }

  export type GetSaleAggregateType<T extends SaleAggregateArgs> = {
        [P in keyof T & keyof AggregateSale]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSale[P]>
      : GetScalarType<T[P], AggregateSale[P]>
  }




  export type SaleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SaleWhereInput
    orderBy?: SaleOrderByWithAggregationInput | SaleOrderByWithAggregationInput[]
    by: SaleScalarFieldEnum[] | SaleScalarFieldEnum
    having?: SaleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SaleCountAggregateInputType | true
    _avg?: SaleAvgAggregateInputType
    _sum?: SaleSumAggregateInputType
    _min?: SaleMinAggregateInputType
    _max?: SaleMaxAggregateInputType
  }

  export type SaleGroupByOutputType = {
    id: string
    customerId: string
    saleDate: Date
    totalAmount: Decimal
    discountAmount: Decimal
    finalAmount: Decimal
    loyaltyPointsEarned: number
    notes: string | null
    isCompleted: boolean
    createdById: string
    createdAt: Date
    updatedAt: Date
    birthMonthDiscount: boolean
    ownShampooDiscount: boolean
    paymentMethod: $Enums.PaymentMethod
    _count: SaleCountAggregateOutputType | null
    _avg: SaleAvgAggregateOutputType | null
    _sum: SaleSumAggregateOutputType | null
    _min: SaleMinAggregateOutputType | null
    _max: SaleMaxAggregateOutputType | null
  }

  type GetSaleGroupByPayload<T extends SaleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SaleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SaleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SaleGroupByOutputType[P]>
            : GetScalarType<T[P], SaleGroupByOutputType[P]>
        }
      >
    >


  export type SaleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    customerId?: boolean
    saleDate?: boolean
    totalAmount?: boolean
    discountAmount?: boolean
    finalAmount?: boolean
    loyaltyPointsEarned?: boolean
    notes?: boolean
    isCompleted?: boolean
    createdById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    birthMonthDiscount?: boolean
    ownShampooDiscount?: boolean
    paymentMethod?: boolean
    discounts?: boolean | Sale$discountsArgs<ExtArgs>
    services?: boolean | Sale$servicesArgs<ExtArgs>
    products?: boolean | Sale$productsArgs<ExtArgs>
    staff?: boolean | Sale$staffArgs<ExtArgs>
    payments?: boolean | Sale$paymentsArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    _count?: boolean | SaleCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sale"]>

  export type SaleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    customerId?: boolean
    saleDate?: boolean
    totalAmount?: boolean
    discountAmount?: boolean
    finalAmount?: boolean
    loyaltyPointsEarned?: boolean
    notes?: boolean
    isCompleted?: boolean
    createdById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    birthMonthDiscount?: boolean
    ownShampooDiscount?: boolean
    paymentMethod?: boolean
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sale"]>

  export type SaleSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    customerId?: boolean
    saleDate?: boolean
    totalAmount?: boolean
    discountAmount?: boolean
    finalAmount?: boolean
    loyaltyPointsEarned?: boolean
    notes?: boolean
    isCompleted?: boolean
    createdById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    birthMonthDiscount?: boolean
    ownShampooDiscount?: boolean
    paymentMethod?: boolean
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sale"]>

  export type SaleSelectScalar = {
    id?: boolean
    customerId?: boolean
    saleDate?: boolean
    totalAmount?: boolean
    discountAmount?: boolean
    finalAmount?: boolean
    loyaltyPointsEarned?: boolean
    notes?: boolean
    isCompleted?: boolean
    createdById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    birthMonthDiscount?: boolean
    ownShampooDiscount?: boolean
    paymentMethod?: boolean
  }

  export type SaleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "customerId" | "saleDate" | "totalAmount" | "discountAmount" | "finalAmount" | "loyaltyPointsEarned" | "notes" | "isCompleted" | "createdById" | "createdAt" | "updatedAt" | "birthMonthDiscount" | "ownShampooDiscount" | "paymentMethod", ExtArgs["result"]["sale"]>
  export type SaleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    discounts?: boolean | Sale$discountsArgs<ExtArgs>
    services?: boolean | Sale$servicesArgs<ExtArgs>
    products?: boolean | Sale$productsArgs<ExtArgs>
    staff?: boolean | Sale$staffArgs<ExtArgs>
    payments?: boolean | Sale$paymentsArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    _count?: boolean | SaleCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SaleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
  }
  export type SaleIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
  }

  export type $SalePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Sale"
    objects: {
      discounts: Prisma.$SaleDiscountPayload<ExtArgs>[]
      services: Prisma.$SaleServicePayload<ExtArgs>[]
      products: Prisma.$SaleProductPayload<ExtArgs>[]
      staff: Prisma.$SaleStaffPayload<ExtArgs>[]
      payments: Prisma.$SalePaymentPayload<ExtArgs>[]
      createdBy: Prisma.$UserPayload<ExtArgs>
      customer: Prisma.$CustomerPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      customerId: string
      saleDate: Date
      totalAmount: Prisma.Decimal
      discountAmount: Prisma.Decimal
      finalAmount: Prisma.Decimal
      loyaltyPointsEarned: number
      notes: string | null
      isCompleted: boolean
      createdById: string
      createdAt: Date
      updatedAt: Date
      birthMonthDiscount: boolean
      ownShampooDiscount: boolean
      paymentMethod: $Enums.PaymentMethod
    }, ExtArgs["result"]["sale"]>
    composites: {}
  }

  type SaleGetPayload<S extends boolean | null | undefined | SaleDefaultArgs> = $Result.GetResult<Prisma.$SalePayload, S>

  type SaleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SaleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SaleCountAggregateInputType | true
    }

  export interface SaleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Sale'], meta: { name: 'Sale' } }
    /**
     * Find zero or one Sale that matches the filter.
     * @param {SaleFindUniqueArgs} args - Arguments to find a Sale
     * @example
     * // Get one Sale
     * const sale = await prisma.sale.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SaleFindUniqueArgs>(args: SelectSubset<T, SaleFindUniqueArgs<ExtArgs>>): Prisma__SaleClient<$Result.GetResult<Prisma.$SalePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Sale that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SaleFindUniqueOrThrowArgs} args - Arguments to find a Sale
     * @example
     * // Get one Sale
     * const sale = await prisma.sale.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SaleFindUniqueOrThrowArgs>(args: SelectSubset<T, SaleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SaleClient<$Result.GetResult<Prisma.$SalePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Sale that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleFindFirstArgs} args - Arguments to find a Sale
     * @example
     * // Get one Sale
     * const sale = await prisma.sale.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SaleFindFirstArgs>(args?: SelectSubset<T, SaleFindFirstArgs<ExtArgs>>): Prisma__SaleClient<$Result.GetResult<Prisma.$SalePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Sale that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleFindFirstOrThrowArgs} args - Arguments to find a Sale
     * @example
     * // Get one Sale
     * const sale = await prisma.sale.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SaleFindFirstOrThrowArgs>(args?: SelectSubset<T, SaleFindFirstOrThrowArgs<ExtArgs>>): Prisma__SaleClient<$Result.GetResult<Prisma.$SalePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Sales that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sales
     * const sales = await prisma.sale.findMany()
     * 
     * // Get first 10 Sales
     * const sales = await prisma.sale.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const saleWithIdOnly = await prisma.sale.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SaleFindManyArgs>(args?: SelectSubset<T, SaleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Sale.
     * @param {SaleCreateArgs} args - Arguments to create a Sale.
     * @example
     * // Create one Sale
     * const Sale = await prisma.sale.create({
     *   data: {
     *     // ... data to create a Sale
     *   }
     * })
     * 
     */
    create<T extends SaleCreateArgs>(args: SelectSubset<T, SaleCreateArgs<ExtArgs>>): Prisma__SaleClient<$Result.GetResult<Prisma.$SalePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Sales.
     * @param {SaleCreateManyArgs} args - Arguments to create many Sales.
     * @example
     * // Create many Sales
     * const sale = await prisma.sale.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SaleCreateManyArgs>(args?: SelectSubset<T, SaleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Sales and returns the data saved in the database.
     * @param {SaleCreateManyAndReturnArgs} args - Arguments to create many Sales.
     * @example
     * // Create many Sales
     * const sale = await prisma.sale.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Sales and only return the `id`
     * const saleWithIdOnly = await prisma.sale.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SaleCreateManyAndReturnArgs>(args?: SelectSubset<T, SaleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Sale.
     * @param {SaleDeleteArgs} args - Arguments to delete one Sale.
     * @example
     * // Delete one Sale
     * const Sale = await prisma.sale.delete({
     *   where: {
     *     // ... filter to delete one Sale
     *   }
     * })
     * 
     */
    delete<T extends SaleDeleteArgs>(args: SelectSubset<T, SaleDeleteArgs<ExtArgs>>): Prisma__SaleClient<$Result.GetResult<Prisma.$SalePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Sale.
     * @param {SaleUpdateArgs} args - Arguments to update one Sale.
     * @example
     * // Update one Sale
     * const sale = await prisma.sale.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SaleUpdateArgs>(args: SelectSubset<T, SaleUpdateArgs<ExtArgs>>): Prisma__SaleClient<$Result.GetResult<Prisma.$SalePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Sales.
     * @param {SaleDeleteManyArgs} args - Arguments to filter Sales to delete.
     * @example
     * // Delete a few Sales
     * const { count } = await prisma.sale.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SaleDeleteManyArgs>(args?: SelectSubset<T, SaleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sales.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sales
     * const sale = await prisma.sale.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SaleUpdateManyArgs>(args: SelectSubset<T, SaleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sales and returns the data updated in the database.
     * @param {SaleUpdateManyAndReturnArgs} args - Arguments to update many Sales.
     * @example
     * // Update many Sales
     * const sale = await prisma.sale.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Sales and only return the `id`
     * const saleWithIdOnly = await prisma.sale.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SaleUpdateManyAndReturnArgs>(args: SelectSubset<T, SaleUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Sale.
     * @param {SaleUpsertArgs} args - Arguments to update or create a Sale.
     * @example
     * // Update or create a Sale
     * const sale = await prisma.sale.upsert({
     *   create: {
     *     // ... data to create a Sale
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Sale we want to update
     *   }
     * })
     */
    upsert<T extends SaleUpsertArgs>(args: SelectSubset<T, SaleUpsertArgs<ExtArgs>>): Prisma__SaleClient<$Result.GetResult<Prisma.$SalePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Sales.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleCountArgs} args - Arguments to filter Sales to count.
     * @example
     * // Count the number of Sales
     * const count = await prisma.sale.count({
     *   where: {
     *     // ... the filter for the Sales we want to count
     *   }
     * })
    **/
    count<T extends SaleCountArgs>(
      args?: Subset<T, SaleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SaleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Sale.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SaleAggregateArgs>(args: Subset<T, SaleAggregateArgs>): Prisma.PrismaPromise<GetSaleAggregateType<T>>

    /**
     * Group by Sale.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SaleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SaleGroupByArgs['orderBy'] }
        : { orderBy?: SaleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SaleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSaleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Sale model
   */
  readonly fields: SaleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Sale.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SaleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    discounts<T extends Sale$discountsArgs<ExtArgs> = {}>(args?: Subset<T, Sale$discountsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SaleDiscountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    services<T extends Sale$servicesArgs<ExtArgs> = {}>(args?: Subset<T, Sale$servicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SaleServicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    products<T extends Sale$productsArgs<ExtArgs> = {}>(args?: Subset<T, Sale$productsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SaleProductPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    staff<T extends Sale$staffArgs<ExtArgs> = {}>(args?: Subset<T, Sale$staffArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SaleStaffPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    payments<T extends Sale$paymentsArgs<ExtArgs> = {}>(args?: Subset<T, Sale$paymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalePaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    createdBy<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    customer<T extends CustomerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CustomerDefaultArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Sale model
   */
  interface SaleFieldRefs {
    readonly id: FieldRef<"Sale", 'String'>
    readonly customerId: FieldRef<"Sale", 'String'>
    readonly saleDate: FieldRef<"Sale", 'DateTime'>
    readonly totalAmount: FieldRef<"Sale", 'Decimal'>
    readonly discountAmount: FieldRef<"Sale", 'Decimal'>
    readonly finalAmount: FieldRef<"Sale", 'Decimal'>
    readonly loyaltyPointsEarned: FieldRef<"Sale", 'Int'>
    readonly notes: FieldRef<"Sale", 'String'>
    readonly isCompleted: FieldRef<"Sale", 'Boolean'>
    readonly createdById: FieldRef<"Sale", 'String'>
    readonly createdAt: FieldRef<"Sale", 'DateTime'>
    readonly updatedAt: FieldRef<"Sale", 'DateTime'>
    readonly birthMonthDiscount: FieldRef<"Sale", 'Boolean'>
    readonly ownShampooDiscount: FieldRef<"Sale", 'Boolean'>
    readonly paymentMethod: FieldRef<"Sale", 'PaymentMethod'>
  }
    

  // Custom InputTypes
  /**
   * Sale findUnique
   */
  export type SaleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sale
     */
    select?: SaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sale
     */
    omit?: SaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleInclude<ExtArgs> | null
    /**
     * Filter, which Sale to fetch.
     */
    where: SaleWhereUniqueInput
  }

  /**
   * Sale findUniqueOrThrow
   */
  export type SaleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sale
     */
    select?: SaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sale
     */
    omit?: SaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleInclude<ExtArgs> | null
    /**
     * Filter, which Sale to fetch.
     */
    where: SaleWhereUniqueInput
  }

  /**
   * Sale findFirst
   */
  export type SaleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sale
     */
    select?: SaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sale
     */
    omit?: SaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleInclude<ExtArgs> | null
    /**
     * Filter, which Sale to fetch.
     */
    where?: SaleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sales to fetch.
     */
    orderBy?: SaleOrderByWithRelationInput | SaleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sales.
     */
    cursor?: SaleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sales from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sales.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sales.
     */
    distinct?: SaleScalarFieldEnum | SaleScalarFieldEnum[]
  }

  /**
   * Sale findFirstOrThrow
   */
  export type SaleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sale
     */
    select?: SaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sale
     */
    omit?: SaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleInclude<ExtArgs> | null
    /**
     * Filter, which Sale to fetch.
     */
    where?: SaleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sales to fetch.
     */
    orderBy?: SaleOrderByWithRelationInput | SaleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sales.
     */
    cursor?: SaleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sales from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sales.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sales.
     */
    distinct?: SaleScalarFieldEnum | SaleScalarFieldEnum[]
  }

  /**
   * Sale findMany
   */
  export type SaleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sale
     */
    select?: SaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sale
     */
    omit?: SaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleInclude<ExtArgs> | null
    /**
     * Filter, which Sales to fetch.
     */
    where?: SaleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sales to fetch.
     */
    orderBy?: SaleOrderByWithRelationInput | SaleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sales.
     */
    cursor?: SaleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sales from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sales.
     */
    skip?: number
    distinct?: SaleScalarFieldEnum | SaleScalarFieldEnum[]
  }

  /**
   * Sale create
   */
  export type SaleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sale
     */
    select?: SaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sale
     */
    omit?: SaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleInclude<ExtArgs> | null
    /**
     * The data needed to create a Sale.
     */
    data: XOR<SaleCreateInput, SaleUncheckedCreateInput>
  }

  /**
   * Sale createMany
   */
  export type SaleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Sales.
     */
    data: SaleCreateManyInput | SaleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Sale createManyAndReturn
   */
  export type SaleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sale
     */
    select?: SaleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Sale
     */
    omit?: SaleOmit<ExtArgs> | null
    /**
     * The data used to create many Sales.
     */
    data: SaleCreateManyInput | SaleCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Sale update
   */
  export type SaleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sale
     */
    select?: SaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sale
     */
    omit?: SaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleInclude<ExtArgs> | null
    /**
     * The data needed to update a Sale.
     */
    data: XOR<SaleUpdateInput, SaleUncheckedUpdateInput>
    /**
     * Choose, which Sale to update.
     */
    where: SaleWhereUniqueInput
  }

  /**
   * Sale updateMany
   */
  export type SaleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Sales.
     */
    data: XOR<SaleUpdateManyMutationInput, SaleUncheckedUpdateManyInput>
    /**
     * Filter which Sales to update
     */
    where?: SaleWhereInput
    /**
     * Limit how many Sales to update.
     */
    limit?: number
  }

  /**
   * Sale updateManyAndReturn
   */
  export type SaleUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sale
     */
    select?: SaleSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Sale
     */
    omit?: SaleOmit<ExtArgs> | null
    /**
     * The data used to update Sales.
     */
    data: XOR<SaleUpdateManyMutationInput, SaleUncheckedUpdateManyInput>
    /**
     * Filter which Sales to update
     */
    where?: SaleWhereInput
    /**
     * Limit how many Sales to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Sale upsert
   */
  export type SaleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sale
     */
    select?: SaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sale
     */
    omit?: SaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleInclude<ExtArgs> | null
    /**
     * The filter to search for the Sale to update in case it exists.
     */
    where: SaleWhereUniqueInput
    /**
     * In case the Sale found by the `where` argument doesn't exist, create a new Sale with this data.
     */
    create: XOR<SaleCreateInput, SaleUncheckedCreateInput>
    /**
     * In case the Sale was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SaleUpdateInput, SaleUncheckedUpdateInput>
  }

  /**
   * Sale delete
   */
  export type SaleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sale
     */
    select?: SaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sale
     */
    omit?: SaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleInclude<ExtArgs> | null
    /**
     * Filter which Sale to delete.
     */
    where: SaleWhereUniqueInput
  }

  /**
   * Sale deleteMany
   */
  export type SaleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sales to delete
     */
    where?: SaleWhereInput
    /**
     * Limit how many Sales to delete.
     */
    limit?: number
  }

  /**
   * Sale.discounts
   */
  export type Sale$discountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleDiscount
     */
    select?: SaleDiscountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SaleDiscount
     */
    omit?: SaleDiscountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleDiscountInclude<ExtArgs> | null
    where?: SaleDiscountWhereInput
    orderBy?: SaleDiscountOrderByWithRelationInput | SaleDiscountOrderByWithRelationInput[]
    cursor?: SaleDiscountWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SaleDiscountScalarFieldEnum | SaleDiscountScalarFieldEnum[]
  }

  /**
   * Sale.services
   */
  export type Sale$servicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleService
     */
    select?: SaleServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SaleService
     */
    omit?: SaleServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleServiceInclude<ExtArgs> | null
    where?: SaleServiceWhereInput
    orderBy?: SaleServiceOrderByWithRelationInput | SaleServiceOrderByWithRelationInput[]
    cursor?: SaleServiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SaleServiceScalarFieldEnum | SaleServiceScalarFieldEnum[]
  }

  /**
   * Sale.products
   */
  export type Sale$productsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleProduct
     */
    select?: SaleProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SaleProduct
     */
    omit?: SaleProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleProductInclude<ExtArgs> | null
    where?: SaleProductWhereInput
    orderBy?: SaleProductOrderByWithRelationInput | SaleProductOrderByWithRelationInput[]
    cursor?: SaleProductWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SaleProductScalarFieldEnum | SaleProductScalarFieldEnum[]
  }

  /**
   * Sale.staff
   */
  export type Sale$staffArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleStaff
     */
    select?: SaleStaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SaleStaff
     */
    omit?: SaleStaffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleStaffInclude<ExtArgs> | null
    where?: SaleStaffWhereInput
    orderBy?: SaleStaffOrderByWithRelationInput | SaleStaffOrderByWithRelationInput[]
    cursor?: SaleStaffWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SaleStaffScalarFieldEnum | SaleStaffScalarFieldEnum[]
  }

  /**
   * Sale.payments
   */
  export type Sale$paymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalePayment
     */
    select?: SalePaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalePayment
     */
    omit?: SalePaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalePaymentInclude<ExtArgs> | null
    where?: SalePaymentWhereInput
    orderBy?: SalePaymentOrderByWithRelationInput | SalePaymentOrderByWithRelationInput[]
    cursor?: SalePaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SalePaymentScalarFieldEnum | SalePaymentScalarFieldEnum[]
  }

  /**
   * Sale without action
   */
  export type SaleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sale
     */
    select?: SaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sale
     */
    omit?: SaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleInclude<ExtArgs> | null
  }


  /**
   * Model SaleService
   */

  export type AggregateSaleService = {
    _count: SaleServiceCountAggregateOutputType | null
    _avg: SaleServiceAvgAggregateOutputType | null
    _sum: SaleServiceSumAggregateOutputType | null
    _min: SaleServiceMinAggregateOutputType | null
    _max: SaleServiceMaxAggregateOutputType | null
  }

  export type SaleServiceAvgAggregateOutputType = {
    quantity: number | null
    unitPrice: Decimal | null
    totalPrice: Decimal | null
  }

  export type SaleServiceSumAggregateOutputType = {
    quantity: number | null
    unitPrice: Decimal | null
    totalPrice: Decimal | null
  }

  export type SaleServiceMinAggregateOutputType = {
    id: string | null
    saleId: string | null
    serviceId: string | null
    quantity: number | null
    unitPrice: Decimal | null
    totalPrice: Decimal | null
    isChild: boolean | null
    isCombined: boolean | null
    addShampoo: boolean | null
    createdAt: Date | null
  }

  export type SaleServiceMaxAggregateOutputType = {
    id: string | null
    saleId: string | null
    serviceId: string | null
    quantity: number | null
    unitPrice: Decimal | null
    totalPrice: Decimal | null
    isChild: boolean | null
    isCombined: boolean | null
    addShampoo: boolean | null
    createdAt: Date | null
  }

  export type SaleServiceCountAggregateOutputType = {
    id: number
    saleId: number
    serviceId: number
    quantity: number
    unitPrice: number
    totalPrice: number
    isChild: number
    isCombined: number
    addShampoo: number
    createdAt: number
    _all: number
  }


  export type SaleServiceAvgAggregateInputType = {
    quantity?: true
    unitPrice?: true
    totalPrice?: true
  }

  export type SaleServiceSumAggregateInputType = {
    quantity?: true
    unitPrice?: true
    totalPrice?: true
  }

  export type SaleServiceMinAggregateInputType = {
    id?: true
    saleId?: true
    serviceId?: true
    quantity?: true
    unitPrice?: true
    totalPrice?: true
    isChild?: true
    isCombined?: true
    addShampoo?: true
    createdAt?: true
  }

  export type SaleServiceMaxAggregateInputType = {
    id?: true
    saleId?: true
    serviceId?: true
    quantity?: true
    unitPrice?: true
    totalPrice?: true
    isChild?: true
    isCombined?: true
    addShampoo?: true
    createdAt?: true
  }

  export type SaleServiceCountAggregateInputType = {
    id?: true
    saleId?: true
    serviceId?: true
    quantity?: true
    unitPrice?: true
    totalPrice?: true
    isChild?: true
    isCombined?: true
    addShampoo?: true
    createdAt?: true
    _all?: true
  }

  export type SaleServiceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SaleService to aggregate.
     */
    where?: SaleServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SaleServices to fetch.
     */
    orderBy?: SaleServiceOrderByWithRelationInput | SaleServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SaleServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SaleServices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SaleServices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SaleServices
    **/
    _count?: true | SaleServiceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SaleServiceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SaleServiceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SaleServiceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SaleServiceMaxAggregateInputType
  }

  export type GetSaleServiceAggregateType<T extends SaleServiceAggregateArgs> = {
        [P in keyof T & keyof AggregateSaleService]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSaleService[P]>
      : GetScalarType<T[P], AggregateSaleService[P]>
  }




  export type SaleServiceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SaleServiceWhereInput
    orderBy?: SaleServiceOrderByWithAggregationInput | SaleServiceOrderByWithAggregationInput[]
    by: SaleServiceScalarFieldEnum[] | SaleServiceScalarFieldEnum
    having?: SaleServiceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SaleServiceCountAggregateInputType | true
    _avg?: SaleServiceAvgAggregateInputType
    _sum?: SaleServiceSumAggregateInputType
    _min?: SaleServiceMinAggregateInputType
    _max?: SaleServiceMaxAggregateInputType
  }

  export type SaleServiceGroupByOutputType = {
    id: string
    saleId: string
    serviceId: string
    quantity: number
    unitPrice: Decimal
    totalPrice: Decimal
    isChild: boolean
    isCombined: boolean
    addShampoo: boolean
    createdAt: Date
    _count: SaleServiceCountAggregateOutputType | null
    _avg: SaleServiceAvgAggregateOutputType | null
    _sum: SaleServiceSumAggregateOutputType | null
    _min: SaleServiceMinAggregateOutputType | null
    _max: SaleServiceMaxAggregateOutputType | null
  }

  type GetSaleServiceGroupByPayload<T extends SaleServiceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SaleServiceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SaleServiceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SaleServiceGroupByOutputType[P]>
            : GetScalarType<T[P], SaleServiceGroupByOutputType[P]>
        }
      >
    >


  export type SaleServiceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    saleId?: boolean
    serviceId?: boolean
    quantity?: boolean
    unitPrice?: boolean
    totalPrice?: boolean
    isChild?: boolean
    isCombined?: boolean
    addShampoo?: boolean
    createdAt?: boolean
    sale?: boolean | SaleDefaultArgs<ExtArgs>
    service?: boolean | ServiceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["saleService"]>

  export type SaleServiceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    saleId?: boolean
    serviceId?: boolean
    quantity?: boolean
    unitPrice?: boolean
    totalPrice?: boolean
    isChild?: boolean
    isCombined?: boolean
    addShampoo?: boolean
    createdAt?: boolean
    sale?: boolean | SaleDefaultArgs<ExtArgs>
    service?: boolean | ServiceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["saleService"]>

  export type SaleServiceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    saleId?: boolean
    serviceId?: boolean
    quantity?: boolean
    unitPrice?: boolean
    totalPrice?: boolean
    isChild?: boolean
    isCombined?: boolean
    addShampoo?: boolean
    createdAt?: boolean
    sale?: boolean | SaleDefaultArgs<ExtArgs>
    service?: boolean | ServiceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["saleService"]>

  export type SaleServiceSelectScalar = {
    id?: boolean
    saleId?: boolean
    serviceId?: boolean
    quantity?: boolean
    unitPrice?: boolean
    totalPrice?: boolean
    isChild?: boolean
    isCombined?: boolean
    addShampoo?: boolean
    createdAt?: boolean
  }

  export type SaleServiceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "saleId" | "serviceId" | "quantity" | "unitPrice" | "totalPrice" | "isChild" | "isCombined" | "addShampoo" | "createdAt", ExtArgs["result"]["saleService"]>
  export type SaleServiceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sale?: boolean | SaleDefaultArgs<ExtArgs>
    service?: boolean | ServiceDefaultArgs<ExtArgs>
  }
  export type SaleServiceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sale?: boolean | SaleDefaultArgs<ExtArgs>
    service?: boolean | ServiceDefaultArgs<ExtArgs>
  }
  export type SaleServiceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sale?: boolean | SaleDefaultArgs<ExtArgs>
    service?: boolean | ServiceDefaultArgs<ExtArgs>
  }

  export type $SaleServicePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SaleService"
    objects: {
      sale: Prisma.$SalePayload<ExtArgs>
      service: Prisma.$ServicePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      saleId: string
      serviceId: string
      quantity: number
      unitPrice: Prisma.Decimal
      totalPrice: Prisma.Decimal
      isChild: boolean
      isCombined: boolean
      addShampoo: boolean
      createdAt: Date
    }, ExtArgs["result"]["saleService"]>
    composites: {}
  }

  type SaleServiceGetPayload<S extends boolean | null | undefined | SaleServiceDefaultArgs> = $Result.GetResult<Prisma.$SaleServicePayload, S>

  type SaleServiceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SaleServiceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SaleServiceCountAggregateInputType | true
    }

  export interface SaleServiceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SaleService'], meta: { name: 'SaleService' } }
    /**
     * Find zero or one SaleService that matches the filter.
     * @param {SaleServiceFindUniqueArgs} args - Arguments to find a SaleService
     * @example
     * // Get one SaleService
     * const saleService = await prisma.saleService.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SaleServiceFindUniqueArgs>(args: SelectSubset<T, SaleServiceFindUniqueArgs<ExtArgs>>): Prisma__SaleServiceClient<$Result.GetResult<Prisma.$SaleServicePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SaleService that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SaleServiceFindUniqueOrThrowArgs} args - Arguments to find a SaleService
     * @example
     * // Get one SaleService
     * const saleService = await prisma.saleService.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SaleServiceFindUniqueOrThrowArgs>(args: SelectSubset<T, SaleServiceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SaleServiceClient<$Result.GetResult<Prisma.$SaleServicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SaleService that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleServiceFindFirstArgs} args - Arguments to find a SaleService
     * @example
     * // Get one SaleService
     * const saleService = await prisma.saleService.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SaleServiceFindFirstArgs>(args?: SelectSubset<T, SaleServiceFindFirstArgs<ExtArgs>>): Prisma__SaleServiceClient<$Result.GetResult<Prisma.$SaleServicePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SaleService that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleServiceFindFirstOrThrowArgs} args - Arguments to find a SaleService
     * @example
     * // Get one SaleService
     * const saleService = await prisma.saleService.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SaleServiceFindFirstOrThrowArgs>(args?: SelectSubset<T, SaleServiceFindFirstOrThrowArgs<ExtArgs>>): Prisma__SaleServiceClient<$Result.GetResult<Prisma.$SaleServicePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SaleServices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleServiceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SaleServices
     * const saleServices = await prisma.saleService.findMany()
     * 
     * // Get first 10 SaleServices
     * const saleServices = await prisma.saleService.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const saleServiceWithIdOnly = await prisma.saleService.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SaleServiceFindManyArgs>(args?: SelectSubset<T, SaleServiceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SaleServicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SaleService.
     * @param {SaleServiceCreateArgs} args - Arguments to create a SaleService.
     * @example
     * // Create one SaleService
     * const SaleService = await prisma.saleService.create({
     *   data: {
     *     // ... data to create a SaleService
     *   }
     * })
     * 
     */
    create<T extends SaleServiceCreateArgs>(args: SelectSubset<T, SaleServiceCreateArgs<ExtArgs>>): Prisma__SaleServiceClient<$Result.GetResult<Prisma.$SaleServicePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SaleServices.
     * @param {SaleServiceCreateManyArgs} args - Arguments to create many SaleServices.
     * @example
     * // Create many SaleServices
     * const saleService = await prisma.saleService.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SaleServiceCreateManyArgs>(args?: SelectSubset<T, SaleServiceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SaleServices and returns the data saved in the database.
     * @param {SaleServiceCreateManyAndReturnArgs} args - Arguments to create many SaleServices.
     * @example
     * // Create many SaleServices
     * const saleService = await prisma.saleService.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SaleServices and only return the `id`
     * const saleServiceWithIdOnly = await prisma.saleService.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SaleServiceCreateManyAndReturnArgs>(args?: SelectSubset<T, SaleServiceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SaleServicePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SaleService.
     * @param {SaleServiceDeleteArgs} args - Arguments to delete one SaleService.
     * @example
     * // Delete one SaleService
     * const SaleService = await prisma.saleService.delete({
     *   where: {
     *     // ... filter to delete one SaleService
     *   }
     * })
     * 
     */
    delete<T extends SaleServiceDeleteArgs>(args: SelectSubset<T, SaleServiceDeleteArgs<ExtArgs>>): Prisma__SaleServiceClient<$Result.GetResult<Prisma.$SaleServicePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SaleService.
     * @param {SaleServiceUpdateArgs} args - Arguments to update one SaleService.
     * @example
     * // Update one SaleService
     * const saleService = await prisma.saleService.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SaleServiceUpdateArgs>(args: SelectSubset<T, SaleServiceUpdateArgs<ExtArgs>>): Prisma__SaleServiceClient<$Result.GetResult<Prisma.$SaleServicePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SaleServices.
     * @param {SaleServiceDeleteManyArgs} args - Arguments to filter SaleServices to delete.
     * @example
     * // Delete a few SaleServices
     * const { count } = await prisma.saleService.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SaleServiceDeleteManyArgs>(args?: SelectSubset<T, SaleServiceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SaleServices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleServiceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SaleServices
     * const saleService = await prisma.saleService.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SaleServiceUpdateManyArgs>(args: SelectSubset<T, SaleServiceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SaleServices and returns the data updated in the database.
     * @param {SaleServiceUpdateManyAndReturnArgs} args - Arguments to update many SaleServices.
     * @example
     * // Update many SaleServices
     * const saleService = await prisma.saleService.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SaleServices and only return the `id`
     * const saleServiceWithIdOnly = await prisma.saleService.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SaleServiceUpdateManyAndReturnArgs>(args: SelectSubset<T, SaleServiceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SaleServicePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SaleService.
     * @param {SaleServiceUpsertArgs} args - Arguments to update or create a SaleService.
     * @example
     * // Update or create a SaleService
     * const saleService = await prisma.saleService.upsert({
     *   create: {
     *     // ... data to create a SaleService
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SaleService we want to update
     *   }
     * })
     */
    upsert<T extends SaleServiceUpsertArgs>(args: SelectSubset<T, SaleServiceUpsertArgs<ExtArgs>>): Prisma__SaleServiceClient<$Result.GetResult<Prisma.$SaleServicePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SaleServices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleServiceCountArgs} args - Arguments to filter SaleServices to count.
     * @example
     * // Count the number of SaleServices
     * const count = await prisma.saleService.count({
     *   where: {
     *     // ... the filter for the SaleServices we want to count
     *   }
     * })
    **/
    count<T extends SaleServiceCountArgs>(
      args?: Subset<T, SaleServiceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SaleServiceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SaleService.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleServiceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SaleServiceAggregateArgs>(args: Subset<T, SaleServiceAggregateArgs>): Prisma.PrismaPromise<GetSaleServiceAggregateType<T>>

    /**
     * Group by SaleService.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleServiceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SaleServiceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SaleServiceGroupByArgs['orderBy'] }
        : { orderBy?: SaleServiceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SaleServiceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSaleServiceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SaleService model
   */
  readonly fields: SaleServiceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SaleService.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SaleServiceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    sale<T extends SaleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SaleDefaultArgs<ExtArgs>>): Prisma__SaleClient<$Result.GetResult<Prisma.$SalePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    service<T extends ServiceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ServiceDefaultArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SaleService model
   */
  interface SaleServiceFieldRefs {
    readonly id: FieldRef<"SaleService", 'String'>
    readonly saleId: FieldRef<"SaleService", 'String'>
    readonly serviceId: FieldRef<"SaleService", 'String'>
    readonly quantity: FieldRef<"SaleService", 'Int'>
    readonly unitPrice: FieldRef<"SaleService", 'Decimal'>
    readonly totalPrice: FieldRef<"SaleService", 'Decimal'>
    readonly isChild: FieldRef<"SaleService", 'Boolean'>
    readonly isCombined: FieldRef<"SaleService", 'Boolean'>
    readonly addShampoo: FieldRef<"SaleService", 'Boolean'>
    readonly createdAt: FieldRef<"SaleService", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SaleService findUnique
   */
  export type SaleServiceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleService
     */
    select?: SaleServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SaleService
     */
    omit?: SaleServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleServiceInclude<ExtArgs> | null
    /**
     * Filter, which SaleService to fetch.
     */
    where: SaleServiceWhereUniqueInput
  }

  /**
   * SaleService findUniqueOrThrow
   */
  export type SaleServiceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleService
     */
    select?: SaleServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SaleService
     */
    omit?: SaleServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleServiceInclude<ExtArgs> | null
    /**
     * Filter, which SaleService to fetch.
     */
    where: SaleServiceWhereUniqueInput
  }

  /**
   * SaleService findFirst
   */
  export type SaleServiceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleService
     */
    select?: SaleServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SaleService
     */
    omit?: SaleServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleServiceInclude<ExtArgs> | null
    /**
     * Filter, which SaleService to fetch.
     */
    where?: SaleServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SaleServices to fetch.
     */
    orderBy?: SaleServiceOrderByWithRelationInput | SaleServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SaleServices.
     */
    cursor?: SaleServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SaleServices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SaleServices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SaleServices.
     */
    distinct?: SaleServiceScalarFieldEnum | SaleServiceScalarFieldEnum[]
  }

  /**
   * SaleService findFirstOrThrow
   */
  export type SaleServiceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleService
     */
    select?: SaleServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SaleService
     */
    omit?: SaleServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleServiceInclude<ExtArgs> | null
    /**
     * Filter, which SaleService to fetch.
     */
    where?: SaleServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SaleServices to fetch.
     */
    orderBy?: SaleServiceOrderByWithRelationInput | SaleServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SaleServices.
     */
    cursor?: SaleServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SaleServices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SaleServices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SaleServices.
     */
    distinct?: SaleServiceScalarFieldEnum | SaleServiceScalarFieldEnum[]
  }

  /**
   * SaleService findMany
   */
  export type SaleServiceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleService
     */
    select?: SaleServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SaleService
     */
    omit?: SaleServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleServiceInclude<ExtArgs> | null
    /**
     * Filter, which SaleServices to fetch.
     */
    where?: SaleServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SaleServices to fetch.
     */
    orderBy?: SaleServiceOrderByWithRelationInput | SaleServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SaleServices.
     */
    cursor?: SaleServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SaleServices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SaleServices.
     */
    skip?: number
    distinct?: SaleServiceScalarFieldEnum | SaleServiceScalarFieldEnum[]
  }

  /**
   * SaleService create
   */
  export type SaleServiceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleService
     */
    select?: SaleServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SaleService
     */
    omit?: SaleServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleServiceInclude<ExtArgs> | null
    /**
     * The data needed to create a SaleService.
     */
    data: XOR<SaleServiceCreateInput, SaleServiceUncheckedCreateInput>
  }

  /**
   * SaleService createMany
   */
  export type SaleServiceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SaleServices.
     */
    data: SaleServiceCreateManyInput | SaleServiceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SaleService createManyAndReturn
   */
  export type SaleServiceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleService
     */
    select?: SaleServiceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SaleService
     */
    omit?: SaleServiceOmit<ExtArgs> | null
    /**
     * The data used to create many SaleServices.
     */
    data: SaleServiceCreateManyInput | SaleServiceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleServiceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SaleService update
   */
  export type SaleServiceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleService
     */
    select?: SaleServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SaleService
     */
    omit?: SaleServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleServiceInclude<ExtArgs> | null
    /**
     * The data needed to update a SaleService.
     */
    data: XOR<SaleServiceUpdateInput, SaleServiceUncheckedUpdateInput>
    /**
     * Choose, which SaleService to update.
     */
    where: SaleServiceWhereUniqueInput
  }

  /**
   * SaleService updateMany
   */
  export type SaleServiceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SaleServices.
     */
    data: XOR<SaleServiceUpdateManyMutationInput, SaleServiceUncheckedUpdateManyInput>
    /**
     * Filter which SaleServices to update
     */
    where?: SaleServiceWhereInput
    /**
     * Limit how many SaleServices to update.
     */
    limit?: number
  }

  /**
   * SaleService updateManyAndReturn
   */
  export type SaleServiceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleService
     */
    select?: SaleServiceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SaleService
     */
    omit?: SaleServiceOmit<ExtArgs> | null
    /**
     * The data used to update SaleServices.
     */
    data: XOR<SaleServiceUpdateManyMutationInput, SaleServiceUncheckedUpdateManyInput>
    /**
     * Filter which SaleServices to update
     */
    where?: SaleServiceWhereInput
    /**
     * Limit how many SaleServices to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleServiceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SaleService upsert
   */
  export type SaleServiceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleService
     */
    select?: SaleServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SaleService
     */
    omit?: SaleServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleServiceInclude<ExtArgs> | null
    /**
     * The filter to search for the SaleService to update in case it exists.
     */
    where: SaleServiceWhereUniqueInput
    /**
     * In case the SaleService found by the `where` argument doesn't exist, create a new SaleService with this data.
     */
    create: XOR<SaleServiceCreateInput, SaleServiceUncheckedCreateInput>
    /**
     * In case the SaleService was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SaleServiceUpdateInput, SaleServiceUncheckedUpdateInput>
  }

  /**
   * SaleService delete
   */
  export type SaleServiceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleService
     */
    select?: SaleServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SaleService
     */
    omit?: SaleServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleServiceInclude<ExtArgs> | null
    /**
     * Filter which SaleService to delete.
     */
    where: SaleServiceWhereUniqueInput
  }

  /**
   * SaleService deleteMany
   */
  export type SaleServiceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SaleServices to delete
     */
    where?: SaleServiceWhereInput
    /**
     * Limit how many SaleServices to delete.
     */
    limit?: number
  }

  /**
   * SaleService without action
   */
  export type SaleServiceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleService
     */
    select?: SaleServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SaleService
     */
    omit?: SaleServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleServiceInclude<ExtArgs> | null
  }


  /**
   * Model SaleStaff
   */

  export type AggregateSaleStaff = {
    _count: SaleStaffCountAggregateOutputType | null
    _min: SaleStaffMinAggregateOutputType | null
    _max: SaleStaffMaxAggregateOutputType | null
  }

  export type SaleStaffMinAggregateOutputType = {
    id: string | null
    saleId: string | null
    staffId: string | null
    customName: string | null
    serviceId: string | null
    createdAt: Date | null
  }

  export type SaleStaffMaxAggregateOutputType = {
    id: string | null
    saleId: string | null
    staffId: string | null
    customName: string | null
    serviceId: string | null
    createdAt: Date | null
  }

  export type SaleStaffCountAggregateOutputType = {
    id: number
    saleId: number
    staffId: number
    customName: number
    serviceId: number
    createdAt: number
    _all: number
  }


  export type SaleStaffMinAggregateInputType = {
    id?: true
    saleId?: true
    staffId?: true
    customName?: true
    serviceId?: true
    createdAt?: true
  }

  export type SaleStaffMaxAggregateInputType = {
    id?: true
    saleId?: true
    staffId?: true
    customName?: true
    serviceId?: true
    createdAt?: true
  }

  export type SaleStaffCountAggregateInputType = {
    id?: true
    saleId?: true
    staffId?: true
    customName?: true
    serviceId?: true
    createdAt?: true
    _all?: true
  }

  export type SaleStaffAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SaleStaff to aggregate.
     */
    where?: SaleStaffWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SaleStaffs to fetch.
     */
    orderBy?: SaleStaffOrderByWithRelationInput | SaleStaffOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SaleStaffWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SaleStaffs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SaleStaffs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SaleStaffs
    **/
    _count?: true | SaleStaffCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SaleStaffMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SaleStaffMaxAggregateInputType
  }

  export type GetSaleStaffAggregateType<T extends SaleStaffAggregateArgs> = {
        [P in keyof T & keyof AggregateSaleStaff]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSaleStaff[P]>
      : GetScalarType<T[P], AggregateSaleStaff[P]>
  }




  export type SaleStaffGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SaleStaffWhereInput
    orderBy?: SaleStaffOrderByWithAggregationInput | SaleStaffOrderByWithAggregationInput[]
    by: SaleStaffScalarFieldEnum[] | SaleStaffScalarFieldEnum
    having?: SaleStaffScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SaleStaffCountAggregateInputType | true
    _min?: SaleStaffMinAggregateInputType
    _max?: SaleStaffMaxAggregateInputType
  }

  export type SaleStaffGroupByOutputType = {
    id: string
    saleId: string
    staffId: string | null
    customName: string | null
    serviceId: string | null
    createdAt: Date
    _count: SaleStaffCountAggregateOutputType | null
    _min: SaleStaffMinAggregateOutputType | null
    _max: SaleStaffMaxAggregateOutputType | null
  }

  type GetSaleStaffGroupByPayload<T extends SaleStaffGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SaleStaffGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SaleStaffGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SaleStaffGroupByOutputType[P]>
            : GetScalarType<T[P], SaleStaffGroupByOutputType[P]>
        }
      >
    >


  export type SaleStaffSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    saleId?: boolean
    staffId?: boolean
    customName?: boolean
    serviceId?: boolean
    createdAt?: boolean
    sale?: boolean | SaleDefaultArgs<ExtArgs>
    staff?: boolean | SaleStaff$staffArgs<ExtArgs>
  }, ExtArgs["result"]["saleStaff"]>

  export type SaleStaffSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    saleId?: boolean
    staffId?: boolean
    customName?: boolean
    serviceId?: boolean
    createdAt?: boolean
    sale?: boolean | SaleDefaultArgs<ExtArgs>
    staff?: boolean | SaleStaff$staffArgs<ExtArgs>
  }, ExtArgs["result"]["saleStaff"]>

  export type SaleStaffSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    saleId?: boolean
    staffId?: boolean
    customName?: boolean
    serviceId?: boolean
    createdAt?: boolean
    sale?: boolean | SaleDefaultArgs<ExtArgs>
    staff?: boolean | SaleStaff$staffArgs<ExtArgs>
  }, ExtArgs["result"]["saleStaff"]>

  export type SaleStaffSelectScalar = {
    id?: boolean
    saleId?: boolean
    staffId?: boolean
    customName?: boolean
    serviceId?: boolean
    createdAt?: boolean
  }

  export type SaleStaffOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "saleId" | "staffId" | "customName" | "serviceId" | "createdAt", ExtArgs["result"]["saleStaff"]>
  export type SaleStaffInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sale?: boolean | SaleDefaultArgs<ExtArgs>
    staff?: boolean | SaleStaff$staffArgs<ExtArgs>
  }
  export type SaleStaffIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sale?: boolean | SaleDefaultArgs<ExtArgs>
    staff?: boolean | SaleStaff$staffArgs<ExtArgs>
  }
  export type SaleStaffIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sale?: boolean | SaleDefaultArgs<ExtArgs>
    staff?: boolean | SaleStaff$staffArgs<ExtArgs>
  }

  export type $SaleStaffPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SaleStaff"
    objects: {
      sale: Prisma.$SalePayload<ExtArgs>
      staff: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      saleId: string
      staffId: string | null
      customName: string | null
      serviceId: string | null
      createdAt: Date
    }, ExtArgs["result"]["saleStaff"]>
    composites: {}
  }

  type SaleStaffGetPayload<S extends boolean | null | undefined | SaleStaffDefaultArgs> = $Result.GetResult<Prisma.$SaleStaffPayload, S>

  type SaleStaffCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SaleStaffFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SaleStaffCountAggregateInputType | true
    }

  export interface SaleStaffDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SaleStaff'], meta: { name: 'SaleStaff' } }
    /**
     * Find zero or one SaleStaff that matches the filter.
     * @param {SaleStaffFindUniqueArgs} args - Arguments to find a SaleStaff
     * @example
     * // Get one SaleStaff
     * const saleStaff = await prisma.saleStaff.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SaleStaffFindUniqueArgs>(args: SelectSubset<T, SaleStaffFindUniqueArgs<ExtArgs>>): Prisma__SaleStaffClient<$Result.GetResult<Prisma.$SaleStaffPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SaleStaff that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SaleStaffFindUniqueOrThrowArgs} args - Arguments to find a SaleStaff
     * @example
     * // Get one SaleStaff
     * const saleStaff = await prisma.saleStaff.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SaleStaffFindUniqueOrThrowArgs>(args: SelectSubset<T, SaleStaffFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SaleStaffClient<$Result.GetResult<Prisma.$SaleStaffPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SaleStaff that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleStaffFindFirstArgs} args - Arguments to find a SaleStaff
     * @example
     * // Get one SaleStaff
     * const saleStaff = await prisma.saleStaff.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SaleStaffFindFirstArgs>(args?: SelectSubset<T, SaleStaffFindFirstArgs<ExtArgs>>): Prisma__SaleStaffClient<$Result.GetResult<Prisma.$SaleStaffPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SaleStaff that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleStaffFindFirstOrThrowArgs} args - Arguments to find a SaleStaff
     * @example
     * // Get one SaleStaff
     * const saleStaff = await prisma.saleStaff.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SaleStaffFindFirstOrThrowArgs>(args?: SelectSubset<T, SaleStaffFindFirstOrThrowArgs<ExtArgs>>): Prisma__SaleStaffClient<$Result.GetResult<Prisma.$SaleStaffPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SaleStaffs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleStaffFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SaleStaffs
     * const saleStaffs = await prisma.saleStaff.findMany()
     * 
     * // Get first 10 SaleStaffs
     * const saleStaffs = await prisma.saleStaff.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const saleStaffWithIdOnly = await prisma.saleStaff.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SaleStaffFindManyArgs>(args?: SelectSubset<T, SaleStaffFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SaleStaffPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SaleStaff.
     * @param {SaleStaffCreateArgs} args - Arguments to create a SaleStaff.
     * @example
     * // Create one SaleStaff
     * const SaleStaff = await prisma.saleStaff.create({
     *   data: {
     *     // ... data to create a SaleStaff
     *   }
     * })
     * 
     */
    create<T extends SaleStaffCreateArgs>(args: SelectSubset<T, SaleStaffCreateArgs<ExtArgs>>): Prisma__SaleStaffClient<$Result.GetResult<Prisma.$SaleStaffPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SaleStaffs.
     * @param {SaleStaffCreateManyArgs} args - Arguments to create many SaleStaffs.
     * @example
     * // Create many SaleStaffs
     * const saleStaff = await prisma.saleStaff.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SaleStaffCreateManyArgs>(args?: SelectSubset<T, SaleStaffCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SaleStaffs and returns the data saved in the database.
     * @param {SaleStaffCreateManyAndReturnArgs} args - Arguments to create many SaleStaffs.
     * @example
     * // Create many SaleStaffs
     * const saleStaff = await prisma.saleStaff.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SaleStaffs and only return the `id`
     * const saleStaffWithIdOnly = await prisma.saleStaff.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SaleStaffCreateManyAndReturnArgs>(args?: SelectSubset<T, SaleStaffCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SaleStaffPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SaleStaff.
     * @param {SaleStaffDeleteArgs} args - Arguments to delete one SaleStaff.
     * @example
     * // Delete one SaleStaff
     * const SaleStaff = await prisma.saleStaff.delete({
     *   where: {
     *     // ... filter to delete one SaleStaff
     *   }
     * })
     * 
     */
    delete<T extends SaleStaffDeleteArgs>(args: SelectSubset<T, SaleStaffDeleteArgs<ExtArgs>>): Prisma__SaleStaffClient<$Result.GetResult<Prisma.$SaleStaffPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SaleStaff.
     * @param {SaleStaffUpdateArgs} args - Arguments to update one SaleStaff.
     * @example
     * // Update one SaleStaff
     * const saleStaff = await prisma.saleStaff.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SaleStaffUpdateArgs>(args: SelectSubset<T, SaleStaffUpdateArgs<ExtArgs>>): Prisma__SaleStaffClient<$Result.GetResult<Prisma.$SaleStaffPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SaleStaffs.
     * @param {SaleStaffDeleteManyArgs} args - Arguments to filter SaleStaffs to delete.
     * @example
     * // Delete a few SaleStaffs
     * const { count } = await prisma.saleStaff.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SaleStaffDeleteManyArgs>(args?: SelectSubset<T, SaleStaffDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SaleStaffs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleStaffUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SaleStaffs
     * const saleStaff = await prisma.saleStaff.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SaleStaffUpdateManyArgs>(args: SelectSubset<T, SaleStaffUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SaleStaffs and returns the data updated in the database.
     * @param {SaleStaffUpdateManyAndReturnArgs} args - Arguments to update many SaleStaffs.
     * @example
     * // Update many SaleStaffs
     * const saleStaff = await prisma.saleStaff.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SaleStaffs and only return the `id`
     * const saleStaffWithIdOnly = await prisma.saleStaff.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SaleStaffUpdateManyAndReturnArgs>(args: SelectSubset<T, SaleStaffUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SaleStaffPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SaleStaff.
     * @param {SaleStaffUpsertArgs} args - Arguments to update or create a SaleStaff.
     * @example
     * // Update or create a SaleStaff
     * const saleStaff = await prisma.saleStaff.upsert({
     *   create: {
     *     // ... data to create a SaleStaff
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SaleStaff we want to update
     *   }
     * })
     */
    upsert<T extends SaleStaffUpsertArgs>(args: SelectSubset<T, SaleStaffUpsertArgs<ExtArgs>>): Prisma__SaleStaffClient<$Result.GetResult<Prisma.$SaleStaffPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SaleStaffs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleStaffCountArgs} args - Arguments to filter SaleStaffs to count.
     * @example
     * // Count the number of SaleStaffs
     * const count = await prisma.saleStaff.count({
     *   where: {
     *     // ... the filter for the SaleStaffs we want to count
     *   }
     * })
    **/
    count<T extends SaleStaffCountArgs>(
      args?: Subset<T, SaleStaffCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SaleStaffCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SaleStaff.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleStaffAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SaleStaffAggregateArgs>(args: Subset<T, SaleStaffAggregateArgs>): Prisma.PrismaPromise<GetSaleStaffAggregateType<T>>

    /**
     * Group by SaleStaff.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleStaffGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SaleStaffGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SaleStaffGroupByArgs['orderBy'] }
        : { orderBy?: SaleStaffGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SaleStaffGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSaleStaffGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SaleStaff model
   */
  readonly fields: SaleStaffFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SaleStaff.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SaleStaffClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    sale<T extends SaleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SaleDefaultArgs<ExtArgs>>): Prisma__SaleClient<$Result.GetResult<Prisma.$SalePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    staff<T extends SaleStaff$staffArgs<ExtArgs> = {}>(args?: Subset<T, SaleStaff$staffArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SaleStaff model
   */
  interface SaleStaffFieldRefs {
    readonly id: FieldRef<"SaleStaff", 'String'>
    readonly saleId: FieldRef<"SaleStaff", 'String'>
    readonly staffId: FieldRef<"SaleStaff", 'String'>
    readonly customName: FieldRef<"SaleStaff", 'String'>
    readonly serviceId: FieldRef<"SaleStaff", 'String'>
    readonly createdAt: FieldRef<"SaleStaff", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SaleStaff findUnique
   */
  export type SaleStaffFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleStaff
     */
    select?: SaleStaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SaleStaff
     */
    omit?: SaleStaffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleStaffInclude<ExtArgs> | null
    /**
     * Filter, which SaleStaff to fetch.
     */
    where: SaleStaffWhereUniqueInput
  }

  /**
   * SaleStaff findUniqueOrThrow
   */
  export type SaleStaffFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleStaff
     */
    select?: SaleStaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SaleStaff
     */
    omit?: SaleStaffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleStaffInclude<ExtArgs> | null
    /**
     * Filter, which SaleStaff to fetch.
     */
    where: SaleStaffWhereUniqueInput
  }

  /**
   * SaleStaff findFirst
   */
  export type SaleStaffFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleStaff
     */
    select?: SaleStaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SaleStaff
     */
    omit?: SaleStaffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleStaffInclude<ExtArgs> | null
    /**
     * Filter, which SaleStaff to fetch.
     */
    where?: SaleStaffWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SaleStaffs to fetch.
     */
    orderBy?: SaleStaffOrderByWithRelationInput | SaleStaffOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SaleStaffs.
     */
    cursor?: SaleStaffWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SaleStaffs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SaleStaffs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SaleStaffs.
     */
    distinct?: SaleStaffScalarFieldEnum | SaleStaffScalarFieldEnum[]
  }

  /**
   * SaleStaff findFirstOrThrow
   */
  export type SaleStaffFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleStaff
     */
    select?: SaleStaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SaleStaff
     */
    omit?: SaleStaffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleStaffInclude<ExtArgs> | null
    /**
     * Filter, which SaleStaff to fetch.
     */
    where?: SaleStaffWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SaleStaffs to fetch.
     */
    orderBy?: SaleStaffOrderByWithRelationInput | SaleStaffOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SaleStaffs.
     */
    cursor?: SaleStaffWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SaleStaffs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SaleStaffs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SaleStaffs.
     */
    distinct?: SaleStaffScalarFieldEnum | SaleStaffScalarFieldEnum[]
  }

  /**
   * SaleStaff findMany
   */
  export type SaleStaffFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleStaff
     */
    select?: SaleStaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SaleStaff
     */
    omit?: SaleStaffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleStaffInclude<ExtArgs> | null
    /**
     * Filter, which SaleStaffs to fetch.
     */
    where?: SaleStaffWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SaleStaffs to fetch.
     */
    orderBy?: SaleStaffOrderByWithRelationInput | SaleStaffOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SaleStaffs.
     */
    cursor?: SaleStaffWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SaleStaffs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SaleStaffs.
     */
    skip?: number
    distinct?: SaleStaffScalarFieldEnum | SaleStaffScalarFieldEnum[]
  }

  /**
   * SaleStaff create
   */
  export type SaleStaffCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleStaff
     */
    select?: SaleStaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SaleStaff
     */
    omit?: SaleStaffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleStaffInclude<ExtArgs> | null
    /**
     * The data needed to create a SaleStaff.
     */
    data: XOR<SaleStaffCreateInput, SaleStaffUncheckedCreateInput>
  }

  /**
   * SaleStaff createMany
   */
  export type SaleStaffCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SaleStaffs.
     */
    data: SaleStaffCreateManyInput | SaleStaffCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SaleStaff createManyAndReturn
   */
  export type SaleStaffCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleStaff
     */
    select?: SaleStaffSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SaleStaff
     */
    omit?: SaleStaffOmit<ExtArgs> | null
    /**
     * The data used to create many SaleStaffs.
     */
    data: SaleStaffCreateManyInput | SaleStaffCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleStaffIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SaleStaff update
   */
  export type SaleStaffUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleStaff
     */
    select?: SaleStaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SaleStaff
     */
    omit?: SaleStaffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleStaffInclude<ExtArgs> | null
    /**
     * The data needed to update a SaleStaff.
     */
    data: XOR<SaleStaffUpdateInput, SaleStaffUncheckedUpdateInput>
    /**
     * Choose, which SaleStaff to update.
     */
    where: SaleStaffWhereUniqueInput
  }

  /**
   * SaleStaff updateMany
   */
  export type SaleStaffUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SaleStaffs.
     */
    data: XOR<SaleStaffUpdateManyMutationInput, SaleStaffUncheckedUpdateManyInput>
    /**
     * Filter which SaleStaffs to update
     */
    where?: SaleStaffWhereInput
    /**
     * Limit how many SaleStaffs to update.
     */
    limit?: number
  }

  /**
   * SaleStaff updateManyAndReturn
   */
  export type SaleStaffUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleStaff
     */
    select?: SaleStaffSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SaleStaff
     */
    omit?: SaleStaffOmit<ExtArgs> | null
    /**
     * The data used to update SaleStaffs.
     */
    data: XOR<SaleStaffUpdateManyMutationInput, SaleStaffUncheckedUpdateManyInput>
    /**
     * Filter which SaleStaffs to update
     */
    where?: SaleStaffWhereInput
    /**
     * Limit how many SaleStaffs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleStaffIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SaleStaff upsert
   */
  export type SaleStaffUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleStaff
     */
    select?: SaleStaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SaleStaff
     */
    omit?: SaleStaffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleStaffInclude<ExtArgs> | null
    /**
     * The filter to search for the SaleStaff to update in case it exists.
     */
    where: SaleStaffWhereUniqueInput
    /**
     * In case the SaleStaff found by the `where` argument doesn't exist, create a new SaleStaff with this data.
     */
    create: XOR<SaleStaffCreateInput, SaleStaffUncheckedCreateInput>
    /**
     * In case the SaleStaff was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SaleStaffUpdateInput, SaleStaffUncheckedUpdateInput>
  }

  /**
   * SaleStaff delete
   */
  export type SaleStaffDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleStaff
     */
    select?: SaleStaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SaleStaff
     */
    omit?: SaleStaffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleStaffInclude<ExtArgs> | null
    /**
     * Filter which SaleStaff to delete.
     */
    where: SaleStaffWhereUniqueInput
  }

  /**
   * SaleStaff deleteMany
   */
  export type SaleStaffDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SaleStaffs to delete
     */
    where?: SaleStaffWhereInput
    /**
     * Limit how many SaleStaffs to delete.
     */
    limit?: number
  }

  /**
   * SaleStaff.staff
   */
  export type SaleStaff$staffArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * SaleStaff without action
   */
  export type SaleStaffDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleStaff
     */
    select?: SaleStaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SaleStaff
     */
    omit?: SaleStaffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleStaffInclude<ExtArgs> | null
  }


  /**
   * Model DiscountRule
   */

  export type AggregateDiscountRule = {
    _count: DiscountRuleCountAggregateOutputType | null
    _avg: DiscountRuleAvgAggregateOutputType | null
    _sum: DiscountRuleSumAggregateOutputType | null
    _min: DiscountRuleMinAggregateOutputType | null
    _max: DiscountRuleMaxAggregateOutputType | null
  }

  export type DiscountRuleAvgAggregateOutputType = {
    value: Decimal | null
    minAmount: Decimal | null
    maxDiscount: Decimal | null
  }

  export type DiscountRuleSumAggregateOutputType = {
    value: Decimal | null
    minAmount: Decimal | null
    maxDiscount: Decimal | null
  }

  export type DiscountRuleMinAggregateOutputType = {
    id: string | null
    name: string | null
    type: $Enums.DiscountType | null
    value: Decimal | null
    isPercentage: boolean | null
    isActive: boolean | null
    description: string | null
    minAmount: Decimal | null
    maxDiscount: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DiscountRuleMaxAggregateOutputType = {
    id: string | null
    name: string | null
    type: $Enums.DiscountType | null
    value: Decimal | null
    isPercentage: boolean | null
    isActive: boolean | null
    description: string | null
    minAmount: Decimal | null
    maxDiscount: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DiscountRuleCountAggregateOutputType = {
    id: number
    name: number
    type: number
    value: number
    isPercentage: number
    isActive: number
    description: number
    minAmount: number
    maxDiscount: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DiscountRuleAvgAggregateInputType = {
    value?: true
    minAmount?: true
    maxDiscount?: true
  }

  export type DiscountRuleSumAggregateInputType = {
    value?: true
    minAmount?: true
    maxDiscount?: true
  }

  export type DiscountRuleMinAggregateInputType = {
    id?: true
    name?: true
    type?: true
    value?: true
    isPercentage?: true
    isActive?: true
    description?: true
    minAmount?: true
    maxDiscount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DiscountRuleMaxAggregateInputType = {
    id?: true
    name?: true
    type?: true
    value?: true
    isPercentage?: true
    isActive?: true
    description?: true
    minAmount?: true
    maxDiscount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DiscountRuleCountAggregateInputType = {
    id?: true
    name?: true
    type?: true
    value?: true
    isPercentage?: true
    isActive?: true
    description?: true
    minAmount?: true
    maxDiscount?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DiscountRuleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DiscountRule to aggregate.
     */
    where?: DiscountRuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DiscountRules to fetch.
     */
    orderBy?: DiscountRuleOrderByWithRelationInput | DiscountRuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DiscountRuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DiscountRules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DiscountRules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DiscountRules
    **/
    _count?: true | DiscountRuleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DiscountRuleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DiscountRuleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DiscountRuleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DiscountRuleMaxAggregateInputType
  }

  export type GetDiscountRuleAggregateType<T extends DiscountRuleAggregateArgs> = {
        [P in keyof T & keyof AggregateDiscountRule]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDiscountRule[P]>
      : GetScalarType<T[P], AggregateDiscountRule[P]>
  }




  export type DiscountRuleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DiscountRuleWhereInput
    orderBy?: DiscountRuleOrderByWithAggregationInput | DiscountRuleOrderByWithAggregationInput[]
    by: DiscountRuleScalarFieldEnum[] | DiscountRuleScalarFieldEnum
    having?: DiscountRuleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DiscountRuleCountAggregateInputType | true
    _avg?: DiscountRuleAvgAggregateInputType
    _sum?: DiscountRuleSumAggregateInputType
    _min?: DiscountRuleMinAggregateInputType
    _max?: DiscountRuleMaxAggregateInputType
  }

  export type DiscountRuleGroupByOutputType = {
    id: string
    name: string
    type: $Enums.DiscountType
    value: Decimal
    isPercentage: boolean
    isActive: boolean
    description: string | null
    minAmount: Decimal | null
    maxDiscount: Decimal | null
    createdAt: Date
    updatedAt: Date
    _count: DiscountRuleCountAggregateOutputType | null
    _avg: DiscountRuleAvgAggregateOutputType | null
    _sum: DiscountRuleSumAggregateOutputType | null
    _min: DiscountRuleMinAggregateOutputType | null
    _max: DiscountRuleMaxAggregateOutputType | null
  }

  type GetDiscountRuleGroupByPayload<T extends DiscountRuleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DiscountRuleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DiscountRuleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DiscountRuleGroupByOutputType[P]>
            : GetScalarType<T[P], DiscountRuleGroupByOutputType[P]>
        }
      >
    >


  export type DiscountRuleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    value?: boolean
    isPercentage?: boolean
    isActive?: boolean
    description?: boolean
    minAmount?: boolean
    maxDiscount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    customerDiscounts?: boolean | DiscountRule$customerDiscountsArgs<ExtArgs>
    saleDiscounts?: boolean | DiscountRule$saleDiscountsArgs<ExtArgs>
    _count?: boolean | DiscountRuleCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["discountRule"]>

  export type DiscountRuleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    value?: boolean
    isPercentage?: boolean
    isActive?: boolean
    description?: boolean
    minAmount?: boolean
    maxDiscount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["discountRule"]>

  export type DiscountRuleSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    value?: boolean
    isPercentage?: boolean
    isActive?: boolean
    description?: boolean
    minAmount?: boolean
    maxDiscount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["discountRule"]>

  export type DiscountRuleSelectScalar = {
    id?: boolean
    name?: boolean
    type?: boolean
    value?: boolean
    isPercentage?: boolean
    isActive?: boolean
    description?: boolean
    minAmount?: boolean
    maxDiscount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DiscountRuleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "type" | "value" | "isPercentage" | "isActive" | "description" | "minAmount" | "maxDiscount" | "createdAt" | "updatedAt", ExtArgs["result"]["discountRule"]>
  export type DiscountRuleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customerDiscounts?: boolean | DiscountRule$customerDiscountsArgs<ExtArgs>
    saleDiscounts?: boolean | DiscountRule$saleDiscountsArgs<ExtArgs>
    _count?: boolean | DiscountRuleCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type DiscountRuleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type DiscountRuleIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $DiscountRulePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DiscountRule"
    objects: {
      customerDiscounts: Prisma.$CustomerDiscountPayload<ExtArgs>[]
      saleDiscounts: Prisma.$SaleDiscountPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      type: $Enums.DiscountType
      value: Prisma.Decimal
      isPercentage: boolean
      isActive: boolean
      description: string | null
      minAmount: Prisma.Decimal | null
      maxDiscount: Prisma.Decimal | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["discountRule"]>
    composites: {}
  }

  type DiscountRuleGetPayload<S extends boolean | null | undefined | DiscountRuleDefaultArgs> = $Result.GetResult<Prisma.$DiscountRulePayload, S>

  type DiscountRuleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DiscountRuleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DiscountRuleCountAggregateInputType | true
    }

  export interface DiscountRuleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DiscountRule'], meta: { name: 'DiscountRule' } }
    /**
     * Find zero or one DiscountRule that matches the filter.
     * @param {DiscountRuleFindUniqueArgs} args - Arguments to find a DiscountRule
     * @example
     * // Get one DiscountRule
     * const discountRule = await prisma.discountRule.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DiscountRuleFindUniqueArgs>(args: SelectSubset<T, DiscountRuleFindUniqueArgs<ExtArgs>>): Prisma__DiscountRuleClient<$Result.GetResult<Prisma.$DiscountRulePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DiscountRule that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DiscountRuleFindUniqueOrThrowArgs} args - Arguments to find a DiscountRule
     * @example
     * // Get one DiscountRule
     * const discountRule = await prisma.discountRule.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DiscountRuleFindUniqueOrThrowArgs>(args: SelectSubset<T, DiscountRuleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DiscountRuleClient<$Result.GetResult<Prisma.$DiscountRulePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DiscountRule that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiscountRuleFindFirstArgs} args - Arguments to find a DiscountRule
     * @example
     * // Get one DiscountRule
     * const discountRule = await prisma.discountRule.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DiscountRuleFindFirstArgs>(args?: SelectSubset<T, DiscountRuleFindFirstArgs<ExtArgs>>): Prisma__DiscountRuleClient<$Result.GetResult<Prisma.$DiscountRulePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DiscountRule that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiscountRuleFindFirstOrThrowArgs} args - Arguments to find a DiscountRule
     * @example
     * // Get one DiscountRule
     * const discountRule = await prisma.discountRule.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DiscountRuleFindFirstOrThrowArgs>(args?: SelectSubset<T, DiscountRuleFindFirstOrThrowArgs<ExtArgs>>): Prisma__DiscountRuleClient<$Result.GetResult<Prisma.$DiscountRulePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DiscountRules that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiscountRuleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DiscountRules
     * const discountRules = await prisma.discountRule.findMany()
     * 
     * // Get first 10 DiscountRules
     * const discountRules = await prisma.discountRule.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const discountRuleWithIdOnly = await prisma.discountRule.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DiscountRuleFindManyArgs>(args?: SelectSubset<T, DiscountRuleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DiscountRulePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DiscountRule.
     * @param {DiscountRuleCreateArgs} args - Arguments to create a DiscountRule.
     * @example
     * // Create one DiscountRule
     * const DiscountRule = await prisma.discountRule.create({
     *   data: {
     *     // ... data to create a DiscountRule
     *   }
     * })
     * 
     */
    create<T extends DiscountRuleCreateArgs>(args: SelectSubset<T, DiscountRuleCreateArgs<ExtArgs>>): Prisma__DiscountRuleClient<$Result.GetResult<Prisma.$DiscountRulePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DiscountRules.
     * @param {DiscountRuleCreateManyArgs} args - Arguments to create many DiscountRules.
     * @example
     * // Create many DiscountRules
     * const discountRule = await prisma.discountRule.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DiscountRuleCreateManyArgs>(args?: SelectSubset<T, DiscountRuleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DiscountRules and returns the data saved in the database.
     * @param {DiscountRuleCreateManyAndReturnArgs} args - Arguments to create many DiscountRules.
     * @example
     * // Create many DiscountRules
     * const discountRule = await prisma.discountRule.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DiscountRules and only return the `id`
     * const discountRuleWithIdOnly = await prisma.discountRule.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DiscountRuleCreateManyAndReturnArgs>(args?: SelectSubset<T, DiscountRuleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DiscountRulePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a DiscountRule.
     * @param {DiscountRuleDeleteArgs} args - Arguments to delete one DiscountRule.
     * @example
     * // Delete one DiscountRule
     * const DiscountRule = await prisma.discountRule.delete({
     *   where: {
     *     // ... filter to delete one DiscountRule
     *   }
     * })
     * 
     */
    delete<T extends DiscountRuleDeleteArgs>(args: SelectSubset<T, DiscountRuleDeleteArgs<ExtArgs>>): Prisma__DiscountRuleClient<$Result.GetResult<Prisma.$DiscountRulePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DiscountRule.
     * @param {DiscountRuleUpdateArgs} args - Arguments to update one DiscountRule.
     * @example
     * // Update one DiscountRule
     * const discountRule = await prisma.discountRule.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DiscountRuleUpdateArgs>(args: SelectSubset<T, DiscountRuleUpdateArgs<ExtArgs>>): Prisma__DiscountRuleClient<$Result.GetResult<Prisma.$DiscountRulePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DiscountRules.
     * @param {DiscountRuleDeleteManyArgs} args - Arguments to filter DiscountRules to delete.
     * @example
     * // Delete a few DiscountRules
     * const { count } = await prisma.discountRule.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DiscountRuleDeleteManyArgs>(args?: SelectSubset<T, DiscountRuleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DiscountRules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiscountRuleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DiscountRules
     * const discountRule = await prisma.discountRule.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DiscountRuleUpdateManyArgs>(args: SelectSubset<T, DiscountRuleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DiscountRules and returns the data updated in the database.
     * @param {DiscountRuleUpdateManyAndReturnArgs} args - Arguments to update many DiscountRules.
     * @example
     * // Update many DiscountRules
     * const discountRule = await prisma.discountRule.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DiscountRules and only return the `id`
     * const discountRuleWithIdOnly = await prisma.discountRule.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DiscountRuleUpdateManyAndReturnArgs>(args: SelectSubset<T, DiscountRuleUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DiscountRulePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one DiscountRule.
     * @param {DiscountRuleUpsertArgs} args - Arguments to update or create a DiscountRule.
     * @example
     * // Update or create a DiscountRule
     * const discountRule = await prisma.discountRule.upsert({
     *   create: {
     *     // ... data to create a DiscountRule
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DiscountRule we want to update
     *   }
     * })
     */
    upsert<T extends DiscountRuleUpsertArgs>(args: SelectSubset<T, DiscountRuleUpsertArgs<ExtArgs>>): Prisma__DiscountRuleClient<$Result.GetResult<Prisma.$DiscountRulePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DiscountRules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiscountRuleCountArgs} args - Arguments to filter DiscountRules to count.
     * @example
     * // Count the number of DiscountRules
     * const count = await prisma.discountRule.count({
     *   where: {
     *     // ... the filter for the DiscountRules we want to count
     *   }
     * })
    **/
    count<T extends DiscountRuleCountArgs>(
      args?: Subset<T, DiscountRuleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DiscountRuleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DiscountRule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiscountRuleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DiscountRuleAggregateArgs>(args: Subset<T, DiscountRuleAggregateArgs>): Prisma.PrismaPromise<GetDiscountRuleAggregateType<T>>

    /**
     * Group by DiscountRule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiscountRuleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DiscountRuleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DiscountRuleGroupByArgs['orderBy'] }
        : { orderBy?: DiscountRuleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DiscountRuleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDiscountRuleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DiscountRule model
   */
  readonly fields: DiscountRuleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DiscountRule.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DiscountRuleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    customerDiscounts<T extends DiscountRule$customerDiscountsArgs<ExtArgs> = {}>(args?: Subset<T, DiscountRule$customerDiscountsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerDiscountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    saleDiscounts<T extends DiscountRule$saleDiscountsArgs<ExtArgs> = {}>(args?: Subset<T, DiscountRule$saleDiscountsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SaleDiscountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DiscountRule model
   */
  interface DiscountRuleFieldRefs {
    readonly id: FieldRef<"DiscountRule", 'String'>
    readonly name: FieldRef<"DiscountRule", 'String'>
    readonly type: FieldRef<"DiscountRule", 'DiscountType'>
    readonly value: FieldRef<"DiscountRule", 'Decimal'>
    readonly isPercentage: FieldRef<"DiscountRule", 'Boolean'>
    readonly isActive: FieldRef<"DiscountRule", 'Boolean'>
    readonly description: FieldRef<"DiscountRule", 'String'>
    readonly minAmount: FieldRef<"DiscountRule", 'Decimal'>
    readonly maxDiscount: FieldRef<"DiscountRule", 'Decimal'>
    readonly createdAt: FieldRef<"DiscountRule", 'DateTime'>
    readonly updatedAt: FieldRef<"DiscountRule", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DiscountRule findUnique
   */
  export type DiscountRuleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DiscountRule
     */
    select?: DiscountRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DiscountRule
     */
    omit?: DiscountRuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiscountRuleInclude<ExtArgs> | null
    /**
     * Filter, which DiscountRule to fetch.
     */
    where: DiscountRuleWhereUniqueInput
  }

  /**
   * DiscountRule findUniqueOrThrow
   */
  export type DiscountRuleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DiscountRule
     */
    select?: DiscountRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DiscountRule
     */
    omit?: DiscountRuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiscountRuleInclude<ExtArgs> | null
    /**
     * Filter, which DiscountRule to fetch.
     */
    where: DiscountRuleWhereUniqueInput
  }

  /**
   * DiscountRule findFirst
   */
  export type DiscountRuleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DiscountRule
     */
    select?: DiscountRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DiscountRule
     */
    omit?: DiscountRuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiscountRuleInclude<ExtArgs> | null
    /**
     * Filter, which DiscountRule to fetch.
     */
    where?: DiscountRuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DiscountRules to fetch.
     */
    orderBy?: DiscountRuleOrderByWithRelationInput | DiscountRuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DiscountRules.
     */
    cursor?: DiscountRuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DiscountRules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DiscountRules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DiscountRules.
     */
    distinct?: DiscountRuleScalarFieldEnum | DiscountRuleScalarFieldEnum[]
  }

  /**
   * DiscountRule findFirstOrThrow
   */
  export type DiscountRuleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DiscountRule
     */
    select?: DiscountRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DiscountRule
     */
    omit?: DiscountRuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiscountRuleInclude<ExtArgs> | null
    /**
     * Filter, which DiscountRule to fetch.
     */
    where?: DiscountRuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DiscountRules to fetch.
     */
    orderBy?: DiscountRuleOrderByWithRelationInput | DiscountRuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DiscountRules.
     */
    cursor?: DiscountRuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DiscountRules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DiscountRules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DiscountRules.
     */
    distinct?: DiscountRuleScalarFieldEnum | DiscountRuleScalarFieldEnum[]
  }

  /**
   * DiscountRule findMany
   */
  export type DiscountRuleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DiscountRule
     */
    select?: DiscountRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DiscountRule
     */
    omit?: DiscountRuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiscountRuleInclude<ExtArgs> | null
    /**
     * Filter, which DiscountRules to fetch.
     */
    where?: DiscountRuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DiscountRules to fetch.
     */
    orderBy?: DiscountRuleOrderByWithRelationInput | DiscountRuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DiscountRules.
     */
    cursor?: DiscountRuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DiscountRules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DiscountRules.
     */
    skip?: number
    distinct?: DiscountRuleScalarFieldEnum | DiscountRuleScalarFieldEnum[]
  }

  /**
   * DiscountRule create
   */
  export type DiscountRuleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DiscountRule
     */
    select?: DiscountRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DiscountRule
     */
    omit?: DiscountRuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiscountRuleInclude<ExtArgs> | null
    /**
     * The data needed to create a DiscountRule.
     */
    data: XOR<DiscountRuleCreateInput, DiscountRuleUncheckedCreateInput>
  }

  /**
   * DiscountRule createMany
   */
  export type DiscountRuleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DiscountRules.
     */
    data: DiscountRuleCreateManyInput | DiscountRuleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DiscountRule createManyAndReturn
   */
  export type DiscountRuleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DiscountRule
     */
    select?: DiscountRuleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DiscountRule
     */
    omit?: DiscountRuleOmit<ExtArgs> | null
    /**
     * The data used to create many DiscountRules.
     */
    data: DiscountRuleCreateManyInput | DiscountRuleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DiscountRule update
   */
  export type DiscountRuleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DiscountRule
     */
    select?: DiscountRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DiscountRule
     */
    omit?: DiscountRuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiscountRuleInclude<ExtArgs> | null
    /**
     * The data needed to update a DiscountRule.
     */
    data: XOR<DiscountRuleUpdateInput, DiscountRuleUncheckedUpdateInput>
    /**
     * Choose, which DiscountRule to update.
     */
    where: DiscountRuleWhereUniqueInput
  }

  /**
   * DiscountRule updateMany
   */
  export type DiscountRuleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DiscountRules.
     */
    data: XOR<DiscountRuleUpdateManyMutationInput, DiscountRuleUncheckedUpdateManyInput>
    /**
     * Filter which DiscountRules to update
     */
    where?: DiscountRuleWhereInput
    /**
     * Limit how many DiscountRules to update.
     */
    limit?: number
  }

  /**
   * DiscountRule updateManyAndReturn
   */
  export type DiscountRuleUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DiscountRule
     */
    select?: DiscountRuleSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DiscountRule
     */
    omit?: DiscountRuleOmit<ExtArgs> | null
    /**
     * The data used to update DiscountRules.
     */
    data: XOR<DiscountRuleUpdateManyMutationInput, DiscountRuleUncheckedUpdateManyInput>
    /**
     * Filter which DiscountRules to update
     */
    where?: DiscountRuleWhereInput
    /**
     * Limit how many DiscountRules to update.
     */
    limit?: number
  }

  /**
   * DiscountRule upsert
   */
  export type DiscountRuleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DiscountRule
     */
    select?: DiscountRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DiscountRule
     */
    omit?: DiscountRuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiscountRuleInclude<ExtArgs> | null
    /**
     * The filter to search for the DiscountRule to update in case it exists.
     */
    where: DiscountRuleWhereUniqueInput
    /**
     * In case the DiscountRule found by the `where` argument doesn't exist, create a new DiscountRule with this data.
     */
    create: XOR<DiscountRuleCreateInput, DiscountRuleUncheckedCreateInput>
    /**
     * In case the DiscountRule was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DiscountRuleUpdateInput, DiscountRuleUncheckedUpdateInput>
  }

  /**
   * DiscountRule delete
   */
  export type DiscountRuleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DiscountRule
     */
    select?: DiscountRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DiscountRule
     */
    omit?: DiscountRuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiscountRuleInclude<ExtArgs> | null
    /**
     * Filter which DiscountRule to delete.
     */
    where: DiscountRuleWhereUniqueInput
  }

  /**
   * DiscountRule deleteMany
   */
  export type DiscountRuleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DiscountRules to delete
     */
    where?: DiscountRuleWhereInput
    /**
     * Limit how many DiscountRules to delete.
     */
    limit?: number
  }

  /**
   * DiscountRule.customerDiscounts
   */
  export type DiscountRule$customerDiscountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerDiscount
     */
    select?: CustomerDiscountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerDiscount
     */
    omit?: CustomerDiscountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerDiscountInclude<ExtArgs> | null
    where?: CustomerDiscountWhereInput
    orderBy?: CustomerDiscountOrderByWithRelationInput | CustomerDiscountOrderByWithRelationInput[]
    cursor?: CustomerDiscountWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CustomerDiscountScalarFieldEnum | CustomerDiscountScalarFieldEnum[]
  }

  /**
   * DiscountRule.saleDiscounts
   */
  export type DiscountRule$saleDiscountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleDiscount
     */
    select?: SaleDiscountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SaleDiscount
     */
    omit?: SaleDiscountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleDiscountInclude<ExtArgs> | null
    where?: SaleDiscountWhereInput
    orderBy?: SaleDiscountOrderByWithRelationInput | SaleDiscountOrderByWithRelationInput[]
    cursor?: SaleDiscountWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SaleDiscountScalarFieldEnum | SaleDiscountScalarFieldEnum[]
  }

  /**
   * DiscountRule without action
   */
  export type DiscountRuleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DiscountRule
     */
    select?: DiscountRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DiscountRule
     */
    omit?: DiscountRuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiscountRuleInclude<ExtArgs> | null
  }


  /**
   * Model SaleDiscount
   */

  export type AggregateSaleDiscount = {
    _count: SaleDiscountCountAggregateOutputType | null
    _avg: SaleDiscountAvgAggregateOutputType | null
    _sum: SaleDiscountSumAggregateOutputType | null
    _min: SaleDiscountMinAggregateOutputType | null
    _max: SaleDiscountMaxAggregateOutputType | null
  }

  export type SaleDiscountAvgAggregateOutputType = {
    discountAmount: Decimal | null
  }

  export type SaleDiscountSumAggregateOutputType = {
    discountAmount: Decimal | null
  }

  export type SaleDiscountMinAggregateOutputType = {
    id: string | null
    saleId: string | null
    discountRuleId: string | null
    discountAmount: Decimal | null
    createdAt: Date | null
  }

  export type SaleDiscountMaxAggregateOutputType = {
    id: string | null
    saleId: string | null
    discountRuleId: string | null
    discountAmount: Decimal | null
    createdAt: Date | null
  }

  export type SaleDiscountCountAggregateOutputType = {
    id: number
    saleId: number
    discountRuleId: number
    discountAmount: number
    createdAt: number
    _all: number
  }


  export type SaleDiscountAvgAggregateInputType = {
    discountAmount?: true
  }

  export type SaleDiscountSumAggregateInputType = {
    discountAmount?: true
  }

  export type SaleDiscountMinAggregateInputType = {
    id?: true
    saleId?: true
    discountRuleId?: true
    discountAmount?: true
    createdAt?: true
  }

  export type SaleDiscountMaxAggregateInputType = {
    id?: true
    saleId?: true
    discountRuleId?: true
    discountAmount?: true
    createdAt?: true
  }

  export type SaleDiscountCountAggregateInputType = {
    id?: true
    saleId?: true
    discountRuleId?: true
    discountAmount?: true
    createdAt?: true
    _all?: true
  }

  export type SaleDiscountAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SaleDiscount to aggregate.
     */
    where?: SaleDiscountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SaleDiscounts to fetch.
     */
    orderBy?: SaleDiscountOrderByWithRelationInput | SaleDiscountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SaleDiscountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SaleDiscounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SaleDiscounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SaleDiscounts
    **/
    _count?: true | SaleDiscountCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SaleDiscountAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SaleDiscountSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SaleDiscountMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SaleDiscountMaxAggregateInputType
  }

  export type GetSaleDiscountAggregateType<T extends SaleDiscountAggregateArgs> = {
        [P in keyof T & keyof AggregateSaleDiscount]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSaleDiscount[P]>
      : GetScalarType<T[P], AggregateSaleDiscount[P]>
  }




  export type SaleDiscountGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SaleDiscountWhereInput
    orderBy?: SaleDiscountOrderByWithAggregationInput | SaleDiscountOrderByWithAggregationInput[]
    by: SaleDiscountScalarFieldEnum[] | SaleDiscountScalarFieldEnum
    having?: SaleDiscountScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SaleDiscountCountAggregateInputType | true
    _avg?: SaleDiscountAvgAggregateInputType
    _sum?: SaleDiscountSumAggregateInputType
    _min?: SaleDiscountMinAggregateInputType
    _max?: SaleDiscountMaxAggregateInputType
  }

  export type SaleDiscountGroupByOutputType = {
    id: string
    saleId: string
    discountRuleId: string
    discountAmount: Decimal
    createdAt: Date
    _count: SaleDiscountCountAggregateOutputType | null
    _avg: SaleDiscountAvgAggregateOutputType | null
    _sum: SaleDiscountSumAggregateOutputType | null
    _min: SaleDiscountMinAggregateOutputType | null
    _max: SaleDiscountMaxAggregateOutputType | null
  }

  type GetSaleDiscountGroupByPayload<T extends SaleDiscountGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SaleDiscountGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SaleDiscountGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SaleDiscountGroupByOutputType[P]>
            : GetScalarType<T[P], SaleDiscountGroupByOutputType[P]>
        }
      >
    >


  export type SaleDiscountSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    saleId?: boolean
    discountRuleId?: boolean
    discountAmount?: boolean
    createdAt?: boolean
    discountRule?: boolean | DiscountRuleDefaultArgs<ExtArgs>
    sale?: boolean | SaleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["saleDiscount"]>

  export type SaleDiscountSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    saleId?: boolean
    discountRuleId?: boolean
    discountAmount?: boolean
    createdAt?: boolean
    discountRule?: boolean | DiscountRuleDefaultArgs<ExtArgs>
    sale?: boolean | SaleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["saleDiscount"]>

  export type SaleDiscountSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    saleId?: boolean
    discountRuleId?: boolean
    discountAmount?: boolean
    createdAt?: boolean
    discountRule?: boolean | DiscountRuleDefaultArgs<ExtArgs>
    sale?: boolean | SaleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["saleDiscount"]>

  export type SaleDiscountSelectScalar = {
    id?: boolean
    saleId?: boolean
    discountRuleId?: boolean
    discountAmount?: boolean
    createdAt?: boolean
  }

  export type SaleDiscountOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "saleId" | "discountRuleId" | "discountAmount" | "createdAt", ExtArgs["result"]["saleDiscount"]>
  export type SaleDiscountInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    discountRule?: boolean | DiscountRuleDefaultArgs<ExtArgs>
    sale?: boolean | SaleDefaultArgs<ExtArgs>
  }
  export type SaleDiscountIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    discountRule?: boolean | DiscountRuleDefaultArgs<ExtArgs>
    sale?: boolean | SaleDefaultArgs<ExtArgs>
  }
  export type SaleDiscountIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    discountRule?: boolean | DiscountRuleDefaultArgs<ExtArgs>
    sale?: boolean | SaleDefaultArgs<ExtArgs>
  }

  export type $SaleDiscountPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SaleDiscount"
    objects: {
      discountRule: Prisma.$DiscountRulePayload<ExtArgs>
      sale: Prisma.$SalePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      saleId: string
      discountRuleId: string
      discountAmount: Prisma.Decimal
      createdAt: Date
    }, ExtArgs["result"]["saleDiscount"]>
    composites: {}
  }

  type SaleDiscountGetPayload<S extends boolean | null | undefined | SaleDiscountDefaultArgs> = $Result.GetResult<Prisma.$SaleDiscountPayload, S>

  type SaleDiscountCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SaleDiscountFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SaleDiscountCountAggregateInputType | true
    }

  export interface SaleDiscountDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SaleDiscount'], meta: { name: 'SaleDiscount' } }
    /**
     * Find zero or one SaleDiscount that matches the filter.
     * @param {SaleDiscountFindUniqueArgs} args - Arguments to find a SaleDiscount
     * @example
     * // Get one SaleDiscount
     * const saleDiscount = await prisma.saleDiscount.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SaleDiscountFindUniqueArgs>(args: SelectSubset<T, SaleDiscountFindUniqueArgs<ExtArgs>>): Prisma__SaleDiscountClient<$Result.GetResult<Prisma.$SaleDiscountPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SaleDiscount that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SaleDiscountFindUniqueOrThrowArgs} args - Arguments to find a SaleDiscount
     * @example
     * // Get one SaleDiscount
     * const saleDiscount = await prisma.saleDiscount.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SaleDiscountFindUniqueOrThrowArgs>(args: SelectSubset<T, SaleDiscountFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SaleDiscountClient<$Result.GetResult<Prisma.$SaleDiscountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SaleDiscount that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleDiscountFindFirstArgs} args - Arguments to find a SaleDiscount
     * @example
     * // Get one SaleDiscount
     * const saleDiscount = await prisma.saleDiscount.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SaleDiscountFindFirstArgs>(args?: SelectSubset<T, SaleDiscountFindFirstArgs<ExtArgs>>): Prisma__SaleDiscountClient<$Result.GetResult<Prisma.$SaleDiscountPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SaleDiscount that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleDiscountFindFirstOrThrowArgs} args - Arguments to find a SaleDiscount
     * @example
     * // Get one SaleDiscount
     * const saleDiscount = await prisma.saleDiscount.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SaleDiscountFindFirstOrThrowArgs>(args?: SelectSubset<T, SaleDiscountFindFirstOrThrowArgs<ExtArgs>>): Prisma__SaleDiscountClient<$Result.GetResult<Prisma.$SaleDiscountPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SaleDiscounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleDiscountFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SaleDiscounts
     * const saleDiscounts = await prisma.saleDiscount.findMany()
     * 
     * // Get first 10 SaleDiscounts
     * const saleDiscounts = await prisma.saleDiscount.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const saleDiscountWithIdOnly = await prisma.saleDiscount.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SaleDiscountFindManyArgs>(args?: SelectSubset<T, SaleDiscountFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SaleDiscountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SaleDiscount.
     * @param {SaleDiscountCreateArgs} args - Arguments to create a SaleDiscount.
     * @example
     * // Create one SaleDiscount
     * const SaleDiscount = await prisma.saleDiscount.create({
     *   data: {
     *     // ... data to create a SaleDiscount
     *   }
     * })
     * 
     */
    create<T extends SaleDiscountCreateArgs>(args: SelectSubset<T, SaleDiscountCreateArgs<ExtArgs>>): Prisma__SaleDiscountClient<$Result.GetResult<Prisma.$SaleDiscountPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SaleDiscounts.
     * @param {SaleDiscountCreateManyArgs} args - Arguments to create many SaleDiscounts.
     * @example
     * // Create many SaleDiscounts
     * const saleDiscount = await prisma.saleDiscount.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SaleDiscountCreateManyArgs>(args?: SelectSubset<T, SaleDiscountCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SaleDiscounts and returns the data saved in the database.
     * @param {SaleDiscountCreateManyAndReturnArgs} args - Arguments to create many SaleDiscounts.
     * @example
     * // Create many SaleDiscounts
     * const saleDiscount = await prisma.saleDiscount.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SaleDiscounts and only return the `id`
     * const saleDiscountWithIdOnly = await prisma.saleDiscount.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SaleDiscountCreateManyAndReturnArgs>(args?: SelectSubset<T, SaleDiscountCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SaleDiscountPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SaleDiscount.
     * @param {SaleDiscountDeleteArgs} args - Arguments to delete one SaleDiscount.
     * @example
     * // Delete one SaleDiscount
     * const SaleDiscount = await prisma.saleDiscount.delete({
     *   where: {
     *     // ... filter to delete one SaleDiscount
     *   }
     * })
     * 
     */
    delete<T extends SaleDiscountDeleteArgs>(args: SelectSubset<T, SaleDiscountDeleteArgs<ExtArgs>>): Prisma__SaleDiscountClient<$Result.GetResult<Prisma.$SaleDiscountPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SaleDiscount.
     * @param {SaleDiscountUpdateArgs} args - Arguments to update one SaleDiscount.
     * @example
     * // Update one SaleDiscount
     * const saleDiscount = await prisma.saleDiscount.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SaleDiscountUpdateArgs>(args: SelectSubset<T, SaleDiscountUpdateArgs<ExtArgs>>): Prisma__SaleDiscountClient<$Result.GetResult<Prisma.$SaleDiscountPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SaleDiscounts.
     * @param {SaleDiscountDeleteManyArgs} args - Arguments to filter SaleDiscounts to delete.
     * @example
     * // Delete a few SaleDiscounts
     * const { count } = await prisma.saleDiscount.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SaleDiscountDeleteManyArgs>(args?: SelectSubset<T, SaleDiscountDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SaleDiscounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleDiscountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SaleDiscounts
     * const saleDiscount = await prisma.saleDiscount.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SaleDiscountUpdateManyArgs>(args: SelectSubset<T, SaleDiscountUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SaleDiscounts and returns the data updated in the database.
     * @param {SaleDiscountUpdateManyAndReturnArgs} args - Arguments to update many SaleDiscounts.
     * @example
     * // Update many SaleDiscounts
     * const saleDiscount = await prisma.saleDiscount.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SaleDiscounts and only return the `id`
     * const saleDiscountWithIdOnly = await prisma.saleDiscount.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SaleDiscountUpdateManyAndReturnArgs>(args: SelectSubset<T, SaleDiscountUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SaleDiscountPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SaleDiscount.
     * @param {SaleDiscountUpsertArgs} args - Arguments to update or create a SaleDiscount.
     * @example
     * // Update or create a SaleDiscount
     * const saleDiscount = await prisma.saleDiscount.upsert({
     *   create: {
     *     // ... data to create a SaleDiscount
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SaleDiscount we want to update
     *   }
     * })
     */
    upsert<T extends SaleDiscountUpsertArgs>(args: SelectSubset<T, SaleDiscountUpsertArgs<ExtArgs>>): Prisma__SaleDiscountClient<$Result.GetResult<Prisma.$SaleDiscountPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SaleDiscounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleDiscountCountArgs} args - Arguments to filter SaleDiscounts to count.
     * @example
     * // Count the number of SaleDiscounts
     * const count = await prisma.saleDiscount.count({
     *   where: {
     *     // ... the filter for the SaleDiscounts we want to count
     *   }
     * })
    **/
    count<T extends SaleDiscountCountArgs>(
      args?: Subset<T, SaleDiscountCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SaleDiscountCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SaleDiscount.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleDiscountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SaleDiscountAggregateArgs>(args: Subset<T, SaleDiscountAggregateArgs>): Prisma.PrismaPromise<GetSaleDiscountAggregateType<T>>

    /**
     * Group by SaleDiscount.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleDiscountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SaleDiscountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SaleDiscountGroupByArgs['orderBy'] }
        : { orderBy?: SaleDiscountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SaleDiscountGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSaleDiscountGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SaleDiscount model
   */
  readonly fields: SaleDiscountFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SaleDiscount.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SaleDiscountClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    discountRule<T extends DiscountRuleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DiscountRuleDefaultArgs<ExtArgs>>): Prisma__DiscountRuleClient<$Result.GetResult<Prisma.$DiscountRulePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    sale<T extends SaleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SaleDefaultArgs<ExtArgs>>): Prisma__SaleClient<$Result.GetResult<Prisma.$SalePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SaleDiscount model
   */
  interface SaleDiscountFieldRefs {
    readonly id: FieldRef<"SaleDiscount", 'String'>
    readonly saleId: FieldRef<"SaleDiscount", 'String'>
    readonly discountRuleId: FieldRef<"SaleDiscount", 'String'>
    readonly discountAmount: FieldRef<"SaleDiscount", 'Decimal'>
    readonly createdAt: FieldRef<"SaleDiscount", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SaleDiscount findUnique
   */
  export type SaleDiscountFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleDiscount
     */
    select?: SaleDiscountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SaleDiscount
     */
    omit?: SaleDiscountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleDiscountInclude<ExtArgs> | null
    /**
     * Filter, which SaleDiscount to fetch.
     */
    where: SaleDiscountWhereUniqueInput
  }

  /**
   * SaleDiscount findUniqueOrThrow
   */
  export type SaleDiscountFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleDiscount
     */
    select?: SaleDiscountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SaleDiscount
     */
    omit?: SaleDiscountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleDiscountInclude<ExtArgs> | null
    /**
     * Filter, which SaleDiscount to fetch.
     */
    where: SaleDiscountWhereUniqueInput
  }

  /**
   * SaleDiscount findFirst
   */
  export type SaleDiscountFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleDiscount
     */
    select?: SaleDiscountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SaleDiscount
     */
    omit?: SaleDiscountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleDiscountInclude<ExtArgs> | null
    /**
     * Filter, which SaleDiscount to fetch.
     */
    where?: SaleDiscountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SaleDiscounts to fetch.
     */
    orderBy?: SaleDiscountOrderByWithRelationInput | SaleDiscountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SaleDiscounts.
     */
    cursor?: SaleDiscountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SaleDiscounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SaleDiscounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SaleDiscounts.
     */
    distinct?: SaleDiscountScalarFieldEnum | SaleDiscountScalarFieldEnum[]
  }

  /**
   * SaleDiscount findFirstOrThrow
   */
  export type SaleDiscountFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleDiscount
     */
    select?: SaleDiscountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SaleDiscount
     */
    omit?: SaleDiscountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleDiscountInclude<ExtArgs> | null
    /**
     * Filter, which SaleDiscount to fetch.
     */
    where?: SaleDiscountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SaleDiscounts to fetch.
     */
    orderBy?: SaleDiscountOrderByWithRelationInput | SaleDiscountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SaleDiscounts.
     */
    cursor?: SaleDiscountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SaleDiscounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SaleDiscounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SaleDiscounts.
     */
    distinct?: SaleDiscountScalarFieldEnum | SaleDiscountScalarFieldEnum[]
  }

  /**
   * SaleDiscount findMany
   */
  export type SaleDiscountFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleDiscount
     */
    select?: SaleDiscountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SaleDiscount
     */
    omit?: SaleDiscountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleDiscountInclude<ExtArgs> | null
    /**
     * Filter, which SaleDiscounts to fetch.
     */
    where?: SaleDiscountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SaleDiscounts to fetch.
     */
    orderBy?: SaleDiscountOrderByWithRelationInput | SaleDiscountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SaleDiscounts.
     */
    cursor?: SaleDiscountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SaleDiscounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SaleDiscounts.
     */
    skip?: number
    distinct?: SaleDiscountScalarFieldEnum | SaleDiscountScalarFieldEnum[]
  }

  /**
   * SaleDiscount create
   */
  export type SaleDiscountCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleDiscount
     */
    select?: SaleDiscountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SaleDiscount
     */
    omit?: SaleDiscountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleDiscountInclude<ExtArgs> | null
    /**
     * The data needed to create a SaleDiscount.
     */
    data: XOR<SaleDiscountCreateInput, SaleDiscountUncheckedCreateInput>
  }

  /**
   * SaleDiscount createMany
   */
  export type SaleDiscountCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SaleDiscounts.
     */
    data: SaleDiscountCreateManyInput | SaleDiscountCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SaleDiscount createManyAndReturn
   */
  export type SaleDiscountCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleDiscount
     */
    select?: SaleDiscountSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SaleDiscount
     */
    omit?: SaleDiscountOmit<ExtArgs> | null
    /**
     * The data used to create many SaleDiscounts.
     */
    data: SaleDiscountCreateManyInput | SaleDiscountCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleDiscountIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SaleDiscount update
   */
  export type SaleDiscountUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleDiscount
     */
    select?: SaleDiscountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SaleDiscount
     */
    omit?: SaleDiscountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleDiscountInclude<ExtArgs> | null
    /**
     * The data needed to update a SaleDiscount.
     */
    data: XOR<SaleDiscountUpdateInput, SaleDiscountUncheckedUpdateInput>
    /**
     * Choose, which SaleDiscount to update.
     */
    where: SaleDiscountWhereUniqueInput
  }

  /**
   * SaleDiscount updateMany
   */
  export type SaleDiscountUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SaleDiscounts.
     */
    data: XOR<SaleDiscountUpdateManyMutationInput, SaleDiscountUncheckedUpdateManyInput>
    /**
     * Filter which SaleDiscounts to update
     */
    where?: SaleDiscountWhereInput
    /**
     * Limit how many SaleDiscounts to update.
     */
    limit?: number
  }

  /**
   * SaleDiscount updateManyAndReturn
   */
  export type SaleDiscountUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleDiscount
     */
    select?: SaleDiscountSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SaleDiscount
     */
    omit?: SaleDiscountOmit<ExtArgs> | null
    /**
     * The data used to update SaleDiscounts.
     */
    data: XOR<SaleDiscountUpdateManyMutationInput, SaleDiscountUncheckedUpdateManyInput>
    /**
     * Filter which SaleDiscounts to update
     */
    where?: SaleDiscountWhereInput
    /**
     * Limit how many SaleDiscounts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleDiscountIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SaleDiscount upsert
   */
  export type SaleDiscountUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleDiscount
     */
    select?: SaleDiscountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SaleDiscount
     */
    omit?: SaleDiscountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleDiscountInclude<ExtArgs> | null
    /**
     * The filter to search for the SaleDiscount to update in case it exists.
     */
    where: SaleDiscountWhereUniqueInput
    /**
     * In case the SaleDiscount found by the `where` argument doesn't exist, create a new SaleDiscount with this data.
     */
    create: XOR<SaleDiscountCreateInput, SaleDiscountUncheckedCreateInput>
    /**
     * In case the SaleDiscount was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SaleDiscountUpdateInput, SaleDiscountUncheckedUpdateInput>
  }

  /**
   * SaleDiscount delete
   */
  export type SaleDiscountDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleDiscount
     */
    select?: SaleDiscountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SaleDiscount
     */
    omit?: SaleDiscountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleDiscountInclude<ExtArgs> | null
    /**
     * Filter which SaleDiscount to delete.
     */
    where: SaleDiscountWhereUniqueInput
  }

  /**
   * SaleDiscount deleteMany
   */
  export type SaleDiscountDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SaleDiscounts to delete
     */
    where?: SaleDiscountWhereInput
    /**
     * Limit how many SaleDiscounts to delete.
     */
    limit?: number
  }

  /**
   * SaleDiscount without action
   */
  export type SaleDiscountDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleDiscount
     */
    select?: SaleDiscountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SaleDiscount
     */
    omit?: SaleDiscountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleDiscountInclude<ExtArgs> | null
  }


  /**
   * Model CustomerDiscount
   */

  export type AggregateCustomerDiscount = {
    _count: CustomerDiscountCountAggregateOutputType | null
    _avg: CustomerDiscountAvgAggregateOutputType | null
    _sum: CustomerDiscountSumAggregateOutputType | null
    _min: CustomerDiscountMinAggregateOutputType | null
    _max: CustomerDiscountMaxAggregateOutputType | null
  }

  export type CustomerDiscountAvgAggregateOutputType = {
    discountAmount: Decimal | null
  }

  export type CustomerDiscountSumAggregateOutputType = {
    discountAmount: Decimal | null
  }

  export type CustomerDiscountMinAggregateOutputType = {
    id: string | null
    customerId: string | null
    discountRuleId: string | null
    usedAt: Date | null
    discountAmount: Decimal | null
  }

  export type CustomerDiscountMaxAggregateOutputType = {
    id: string | null
    customerId: string | null
    discountRuleId: string | null
    usedAt: Date | null
    discountAmount: Decimal | null
  }

  export type CustomerDiscountCountAggregateOutputType = {
    id: number
    customerId: number
    discountRuleId: number
    usedAt: number
    discountAmount: number
    _all: number
  }


  export type CustomerDiscountAvgAggregateInputType = {
    discountAmount?: true
  }

  export type CustomerDiscountSumAggregateInputType = {
    discountAmount?: true
  }

  export type CustomerDiscountMinAggregateInputType = {
    id?: true
    customerId?: true
    discountRuleId?: true
    usedAt?: true
    discountAmount?: true
  }

  export type CustomerDiscountMaxAggregateInputType = {
    id?: true
    customerId?: true
    discountRuleId?: true
    usedAt?: true
    discountAmount?: true
  }

  export type CustomerDiscountCountAggregateInputType = {
    id?: true
    customerId?: true
    discountRuleId?: true
    usedAt?: true
    discountAmount?: true
    _all?: true
  }

  export type CustomerDiscountAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CustomerDiscount to aggregate.
     */
    where?: CustomerDiscountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerDiscounts to fetch.
     */
    orderBy?: CustomerDiscountOrderByWithRelationInput | CustomerDiscountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CustomerDiscountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerDiscounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerDiscounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CustomerDiscounts
    **/
    _count?: true | CustomerDiscountCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CustomerDiscountAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CustomerDiscountSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CustomerDiscountMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CustomerDiscountMaxAggregateInputType
  }

  export type GetCustomerDiscountAggregateType<T extends CustomerDiscountAggregateArgs> = {
        [P in keyof T & keyof AggregateCustomerDiscount]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCustomerDiscount[P]>
      : GetScalarType<T[P], AggregateCustomerDiscount[P]>
  }




  export type CustomerDiscountGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomerDiscountWhereInput
    orderBy?: CustomerDiscountOrderByWithAggregationInput | CustomerDiscountOrderByWithAggregationInput[]
    by: CustomerDiscountScalarFieldEnum[] | CustomerDiscountScalarFieldEnum
    having?: CustomerDiscountScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CustomerDiscountCountAggregateInputType | true
    _avg?: CustomerDiscountAvgAggregateInputType
    _sum?: CustomerDiscountSumAggregateInputType
    _min?: CustomerDiscountMinAggregateInputType
    _max?: CustomerDiscountMaxAggregateInputType
  }

  export type CustomerDiscountGroupByOutputType = {
    id: string
    customerId: string
    discountRuleId: string
    usedAt: Date
    discountAmount: Decimal
    _count: CustomerDiscountCountAggregateOutputType | null
    _avg: CustomerDiscountAvgAggregateOutputType | null
    _sum: CustomerDiscountSumAggregateOutputType | null
    _min: CustomerDiscountMinAggregateOutputType | null
    _max: CustomerDiscountMaxAggregateOutputType | null
  }

  type GetCustomerDiscountGroupByPayload<T extends CustomerDiscountGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CustomerDiscountGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CustomerDiscountGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CustomerDiscountGroupByOutputType[P]>
            : GetScalarType<T[P], CustomerDiscountGroupByOutputType[P]>
        }
      >
    >


  export type CustomerDiscountSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    customerId?: boolean
    discountRuleId?: boolean
    usedAt?: boolean
    discountAmount?: boolean
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    discountRule?: boolean | DiscountRuleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customerDiscount"]>

  export type CustomerDiscountSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    customerId?: boolean
    discountRuleId?: boolean
    usedAt?: boolean
    discountAmount?: boolean
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    discountRule?: boolean | DiscountRuleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customerDiscount"]>

  export type CustomerDiscountSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    customerId?: boolean
    discountRuleId?: boolean
    usedAt?: boolean
    discountAmount?: boolean
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    discountRule?: boolean | DiscountRuleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customerDiscount"]>

  export type CustomerDiscountSelectScalar = {
    id?: boolean
    customerId?: boolean
    discountRuleId?: boolean
    usedAt?: boolean
    discountAmount?: boolean
  }

  export type CustomerDiscountOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "customerId" | "discountRuleId" | "usedAt" | "discountAmount", ExtArgs["result"]["customerDiscount"]>
  export type CustomerDiscountInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    discountRule?: boolean | DiscountRuleDefaultArgs<ExtArgs>
  }
  export type CustomerDiscountIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    discountRule?: boolean | DiscountRuleDefaultArgs<ExtArgs>
  }
  export type CustomerDiscountIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    discountRule?: boolean | DiscountRuleDefaultArgs<ExtArgs>
  }

  export type $CustomerDiscountPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CustomerDiscount"
    objects: {
      customer: Prisma.$CustomerPayload<ExtArgs>
      discountRule: Prisma.$DiscountRulePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      customerId: string
      discountRuleId: string
      usedAt: Date
      discountAmount: Prisma.Decimal
    }, ExtArgs["result"]["customerDiscount"]>
    composites: {}
  }

  type CustomerDiscountGetPayload<S extends boolean | null | undefined | CustomerDiscountDefaultArgs> = $Result.GetResult<Prisma.$CustomerDiscountPayload, S>

  type CustomerDiscountCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CustomerDiscountFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CustomerDiscountCountAggregateInputType | true
    }

  export interface CustomerDiscountDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CustomerDiscount'], meta: { name: 'CustomerDiscount' } }
    /**
     * Find zero or one CustomerDiscount that matches the filter.
     * @param {CustomerDiscountFindUniqueArgs} args - Arguments to find a CustomerDiscount
     * @example
     * // Get one CustomerDiscount
     * const customerDiscount = await prisma.customerDiscount.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CustomerDiscountFindUniqueArgs>(args: SelectSubset<T, CustomerDiscountFindUniqueArgs<ExtArgs>>): Prisma__CustomerDiscountClient<$Result.GetResult<Prisma.$CustomerDiscountPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CustomerDiscount that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CustomerDiscountFindUniqueOrThrowArgs} args - Arguments to find a CustomerDiscount
     * @example
     * // Get one CustomerDiscount
     * const customerDiscount = await prisma.customerDiscount.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CustomerDiscountFindUniqueOrThrowArgs>(args: SelectSubset<T, CustomerDiscountFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CustomerDiscountClient<$Result.GetResult<Prisma.$CustomerDiscountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CustomerDiscount that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerDiscountFindFirstArgs} args - Arguments to find a CustomerDiscount
     * @example
     * // Get one CustomerDiscount
     * const customerDiscount = await prisma.customerDiscount.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CustomerDiscountFindFirstArgs>(args?: SelectSubset<T, CustomerDiscountFindFirstArgs<ExtArgs>>): Prisma__CustomerDiscountClient<$Result.GetResult<Prisma.$CustomerDiscountPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CustomerDiscount that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerDiscountFindFirstOrThrowArgs} args - Arguments to find a CustomerDiscount
     * @example
     * // Get one CustomerDiscount
     * const customerDiscount = await prisma.customerDiscount.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CustomerDiscountFindFirstOrThrowArgs>(args?: SelectSubset<T, CustomerDiscountFindFirstOrThrowArgs<ExtArgs>>): Prisma__CustomerDiscountClient<$Result.GetResult<Prisma.$CustomerDiscountPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CustomerDiscounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerDiscountFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CustomerDiscounts
     * const customerDiscounts = await prisma.customerDiscount.findMany()
     * 
     * // Get first 10 CustomerDiscounts
     * const customerDiscounts = await prisma.customerDiscount.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const customerDiscountWithIdOnly = await prisma.customerDiscount.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CustomerDiscountFindManyArgs>(args?: SelectSubset<T, CustomerDiscountFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerDiscountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CustomerDiscount.
     * @param {CustomerDiscountCreateArgs} args - Arguments to create a CustomerDiscount.
     * @example
     * // Create one CustomerDiscount
     * const CustomerDiscount = await prisma.customerDiscount.create({
     *   data: {
     *     // ... data to create a CustomerDiscount
     *   }
     * })
     * 
     */
    create<T extends CustomerDiscountCreateArgs>(args: SelectSubset<T, CustomerDiscountCreateArgs<ExtArgs>>): Prisma__CustomerDiscountClient<$Result.GetResult<Prisma.$CustomerDiscountPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CustomerDiscounts.
     * @param {CustomerDiscountCreateManyArgs} args - Arguments to create many CustomerDiscounts.
     * @example
     * // Create many CustomerDiscounts
     * const customerDiscount = await prisma.customerDiscount.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CustomerDiscountCreateManyArgs>(args?: SelectSubset<T, CustomerDiscountCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CustomerDiscounts and returns the data saved in the database.
     * @param {CustomerDiscountCreateManyAndReturnArgs} args - Arguments to create many CustomerDiscounts.
     * @example
     * // Create many CustomerDiscounts
     * const customerDiscount = await prisma.customerDiscount.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CustomerDiscounts and only return the `id`
     * const customerDiscountWithIdOnly = await prisma.customerDiscount.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CustomerDiscountCreateManyAndReturnArgs>(args?: SelectSubset<T, CustomerDiscountCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerDiscountPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CustomerDiscount.
     * @param {CustomerDiscountDeleteArgs} args - Arguments to delete one CustomerDiscount.
     * @example
     * // Delete one CustomerDiscount
     * const CustomerDiscount = await prisma.customerDiscount.delete({
     *   where: {
     *     // ... filter to delete one CustomerDiscount
     *   }
     * })
     * 
     */
    delete<T extends CustomerDiscountDeleteArgs>(args: SelectSubset<T, CustomerDiscountDeleteArgs<ExtArgs>>): Prisma__CustomerDiscountClient<$Result.GetResult<Prisma.$CustomerDiscountPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CustomerDiscount.
     * @param {CustomerDiscountUpdateArgs} args - Arguments to update one CustomerDiscount.
     * @example
     * // Update one CustomerDiscount
     * const customerDiscount = await prisma.customerDiscount.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CustomerDiscountUpdateArgs>(args: SelectSubset<T, CustomerDiscountUpdateArgs<ExtArgs>>): Prisma__CustomerDiscountClient<$Result.GetResult<Prisma.$CustomerDiscountPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CustomerDiscounts.
     * @param {CustomerDiscountDeleteManyArgs} args - Arguments to filter CustomerDiscounts to delete.
     * @example
     * // Delete a few CustomerDiscounts
     * const { count } = await prisma.customerDiscount.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CustomerDiscountDeleteManyArgs>(args?: SelectSubset<T, CustomerDiscountDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CustomerDiscounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerDiscountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CustomerDiscounts
     * const customerDiscount = await prisma.customerDiscount.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CustomerDiscountUpdateManyArgs>(args: SelectSubset<T, CustomerDiscountUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CustomerDiscounts and returns the data updated in the database.
     * @param {CustomerDiscountUpdateManyAndReturnArgs} args - Arguments to update many CustomerDiscounts.
     * @example
     * // Update many CustomerDiscounts
     * const customerDiscount = await prisma.customerDiscount.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CustomerDiscounts and only return the `id`
     * const customerDiscountWithIdOnly = await prisma.customerDiscount.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CustomerDiscountUpdateManyAndReturnArgs>(args: SelectSubset<T, CustomerDiscountUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerDiscountPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CustomerDiscount.
     * @param {CustomerDiscountUpsertArgs} args - Arguments to update or create a CustomerDiscount.
     * @example
     * // Update or create a CustomerDiscount
     * const customerDiscount = await prisma.customerDiscount.upsert({
     *   create: {
     *     // ... data to create a CustomerDiscount
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CustomerDiscount we want to update
     *   }
     * })
     */
    upsert<T extends CustomerDiscountUpsertArgs>(args: SelectSubset<T, CustomerDiscountUpsertArgs<ExtArgs>>): Prisma__CustomerDiscountClient<$Result.GetResult<Prisma.$CustomerDiscountPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CustomerDiscounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerDiscountCountArgs} args - Arguments to filter CustomerDiscounts to count.
     * @example
     * // Count the number of CustomerDiscounts
     * const count = await prisma.customerDiscount.count({
     *   where: {
     *     // ... the filter for the CustomerDiscounts we want to count
     *   }
     * })
    **/
    count<T extends CustomerDiscountCountArgs>(
      args?: Subset<T, CustomerDiscountCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CustomerDiscountCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CustomerDiscount.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerDiscountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CustomerDiscountAggregateArgs>(args: Subset<T, CustomerDiscountAggregateArgs>): Prisma.PrismaPromise<GetCustomerDiscountAggregateType<T>>

    /**
     * Group by CustomerDiscount.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerDiscountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CustomerDiscountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CustomerDiscountGroupByArgs['orderBy'] }
        : { orderBy?: CustomerDiscountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CustomerDiscountGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCustomerDiscountGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CustomerDiscount model
   */
  readonly fields: CustomerDiscountFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CustomerDiscount.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CustomerDiscountClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    customer<T extends CustomerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CustomerDefaultArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    discountRule<T extends DiscountRuleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DiscountRuleDefaultArgs<ExtArgs>>): Prisma__DiscountRuleClient<$Result.GetResult<Prisma.$DiscountRulePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CustomerDiscount model
   */
  interface CustomerDiscountFieldRefs {
    readonly id: FieldRef<"CustomerDiscount", 'String'>
    readonly customerId: FieldRef<"CustomerDiscount", 'String'>
    readonly discountRuleId: FieldRef<"CustomerDiscount", 'String'>
    readonly usedAt: FieldRef<"CustomerDiscount", 'DateTime'>
    readonly discountAmount: FieldRef<"CustomerDiscount", 'Decimal'>
  }
    

  // Custom InputTypes
  /**
   * CustomerDiscount findUnique
   */
  export type CustomerDiscountFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerDiscount
     */
    select?: CustomerDiscountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerDiscount
     */
    omit?: CustomerDiscountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerDiscountInclude<ExtArgs> | null
    /**
     * Filter, which CustomerDiscount to fetch.
     */
    where: CustomerDiscountWhereUniqueInput
  }

  /**
   * CustomerDiscount findUniqueOrThrow
   */
  export type CustomerDiscountFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerDiscount
     */
    select?: CustomerDiscountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerDiscount
     */
    omit?: CustomerDiscountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerDiscountInclude<ExtArgs> | null
    /**
     * Filter, which CustomerDiscount to fetch.
     */
    where: CustomerDiscountWhereUniqueInput
  }

  /**
   * CustomerDiscount findFirst
   */
  export type CustomerDiscountFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerDiscount
     */
    select?: CustomerDiscountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerDiscount
     */
    omit?: CustomerDiscountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerDiscountInclude<ExtArgs> | null
    /**
     * Filter, which CustomerDiscount to fetch.
     */
    where?: CustomerDiscountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerDiscounts to fetch.
     */
    orderBy?: CustomerDiscountOrderByWithRelationInput | CustomerDiscountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CustomerDiscounts.
     */
    cursor?: CustomerDiscountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerDiscounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerDiscounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CustomerDiscounts.
     */
    distinct?: CustomerDiscountScalarFieldEnum | CustomerDiscountScalarFieldEnum[]
  }

  /**
   * CustomerDiscount findFirstOrThrow
   */
  export type CustomerDiscountFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerDiscount
     */
    select?: CustomerDiscountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerDiscount
     */
    omit?: CustomerDiscountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerDiscountInclude<ExtArgs> | null
    /**
     * Filter, which CustomerDiscount to fetch.
     */
    where?: CustomerDiscountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerDiscounts to fetch.
     */
    orderBy?: CustomerDiscountOrderByWithRelationInput | CustomerDiscountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CustomerDiscounts.
     */
    cursor?: CustomerDiscountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerDiscounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerDiscounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CustomerDiscounts.
     */
    distinct?: CustomerDiscountScalarFieldEnum | CustomerDiscountScalarFieldEnum[]
  }

  /**
   * CustomerDiscount findMany
   */
  export type CustomerDiscountFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerDiscount
     */
    select?: CustomerDiscountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerDiscount
     */
    omit?: CustomerDiscountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerDiscountInclude<ExtArgs> | null
    /**
     * Filter, which CustomerDiscounts to fetch.
     */
    where?: CustomerDiscountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerDiscounts to fetch.
     */
    orderBy?: CustomerDiscountOrderByWithRelationInput | CustomerDiscountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CustomerDiscounts.
     */
    cursor?: CustomerDiscountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerDiscounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerDiscounts.
     */
    skip?: number
    distinct?: CustomerDiscountScalarFieldEnum | CustomerDiscountScalarFieldEnum[]
  }

  /**
   * CustomerDiscount create
   */
  export type CustomerDiscountCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerDiscount
     */
    select?: CustomerDiscountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerDiscount
     */
    omit?: CustomerDiscountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerDiscountInclude<ExtArgs> | null
    /**
     * The data needed to create a CustomerDiscount.
     */
    data: XOR<CustomerDiscountCreateInput, CustomerDiscountUncheckedCreateInput>
  }

  /**
   * CustomerDiscount createMany
   */
  export type CustomerDiscountCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CustomerDiscounts.
     */
    data: CustomerDiscountCreateManyInput | CustomerDiscountCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CustomerDiscount createManyAndReturn
   */
  export type CustomerDiscountCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerDiscount
     */
    select?: CustomerDiscountSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerDiscount
     */
    omit?: CustomerDiscountOmit<ExtArgs> | null
    /**
     * The data used to create many CustomerDiscounts.
     */
    data: CustomerDiscountCreateManyInput | CustomerDiscountCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerDiscountIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CustomerDiscount update
   */
  export type CustomerDiscountUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerDiscount
     */
    select?: CustomerDiscountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerDiscount
     */
    omit?: CustomerDiscountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerDiscountInclude<ExtArgs> | null
    /**
     * The data needed to update a CustomerDiscount.
     */
    data: XOR<CustomerDiscountUpdateInput, CustomerDiscountUncheckedUpdateInput>
    /**
     * Choose, which CustomerDiscount to update.
     */
    where: CustomerDiscountWhereUniqueInput
  }

  /**
   * CustomerDiscount updateMany
   */
  export type CustomerDiscountUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CustomerDiscounts.
     */
    data: XOR<CustomerDiscountUpdateManyMutationInput, CustomerDiscountUncheckedUpdateManyInput>
    /**
     * Filter which CustomerDiscounts to update
     */
    where?: CustomerDiscountWhereInput
    /**
     * Limit how many CustomerDiscounts to update.
     */
    limit?: number
  }

  /**
   * CustomerDiscount updateManyAndReturn
   */
  export type CustomerDiscountUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerDiscount
     */
    select?: CustomerDiscountSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerDiscount
     */
    omit?: CustomerDiscountOmit<ExtArgs> | null
    /**
     * The data used to update CustomerDiscounts.
     */
    data: XOR<CustomerDiscountUpdateManyMutationInput, CustomerDiscountUncheckedUpdateManyInput>
    /**
     * Filter which CustomerDiscounts to update
     */
    where?: CustomerDiscountWhereInput
    /**
     * Limit how many CustomerDiscounts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerDiscountIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CustomerDiscount upsert
   */
  export type CustomerDiscountUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerDiscount
     */
    select?: CustomerDiscountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerDiscount
     */
    omit?: CustomerDiscountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerDiscountInclude<ExtArgs> | null
    /**
     * The filter to search for the CustomerDiscount to update in case it exists.
     */
    where: CustomerDiscountWhereUniqueInput
    /**
     * In case the CustomerDiscount found by the `where` argument doesn't exist, create a new CustomerDiscount with this data.
     */
    create: XOR<CustomerDiscountCreateInput, CustomerDiscountUncheckedCreateInput>
    /**
     * In case the CustomerDiscount was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CustomerDiscountUpdateInput, CustomerDiscountUncheckedUpdateInput>
  }

  /**
   * CustomerDiscount delete
   */
  export type CustomerDiscountDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerDiscount
     */
    select?: CustomerDiscountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerDiscount
     */
    omit?: CustomerDiscountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerDiscountInclude<ExtArgs> | null
    /**
     * Filter which CustomerDiscount to delete.
     */
    where: CustomerDiscountWhereUniqueInput
  }

  /**
   * CustomerDiscount deleteMany
   */
  export type CustomerDiscountDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CustomerDiscounts to delete
     */
    where?: CustomerDiscountWhereInput
    /**
     * Limit how many CustomerDiscounts to delete.
     */
    limit?: number
  }

  /**
   * CustomerDiscount without action
   */
  export type CustomerDiscountDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerDiscount
     */
    select?: CustomerDiscountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerDiscount
     */
    omit?: CustomerDiscountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerDiscountInclude<ExtArgs> | null
  }


  /**
   * Model SalePayment
   */

  export type AggregateSalePayment = {
    _count: SalePaymentCountAggregateOutputType | null
    _avg: SalePaymentAvgAggregateOutputType | null
    _sum: SalePaymentSumAggregateOutputType | null
    _min: SalePaymentMinAggregateOutputType | null
    _max: SalePaymentMaxAggregateOutputType | null
  }

  export type SalePaymentAvgAggregateOutputType = {
    amount: Decimal | null
  }

  export type SalePaymentSumAggregateOutputType = {
    amount: Decimal | null
  }

  export type SalePaymentMinAggregateOutputType = {
    id: string | null
    saleId: string | null
    paymentMethod: $Enums.PaymentMethod | null
    amount: Decimal | null
    createdAt: Date | null
  }

  export type SalePaymentMaxAggregateOutputType = {
    id: string | null
    saleId: string | null
    paymentMethod: $Enums.PaymentMethod | null
    amount: Decimal | null
    createdAt: Date | null
  }

  export type SalePaymentCountAggregateOutputType = {
    id: number
    saleId: number
    paymentMethod: number
    amount: number
    createdAt: number
    _all: number
  }


  export type SalePaymentAvgAggregateInputType = {
    amount?: true
  }

  export type SalePaymentSumAggregateInputType = {
    amount?: true
  }

  export type SalePaymentMinAggregateInputType = {
    id?: true
    saleId?: true
    paymentMethod?: true
    amount?: true
    createdAt?: true
  }

  export type SalePaymentMaxAggregateInputType = {
    id?: true
    saleId?: true
    paymentMethod?: true
    amount?: true
    createdAt?: true
  }

  export type SalePaymentCountAggregateInputType = {
    id?: true
    saleId?: true
    paymentMethod?: true
    amount?: true
    createdAt?: true
    _all?: true
  }

  export type SalePaymentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SalePayment to aggregate.
     */
    where?: SalePaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SalePayments to fetch.
     */
    orderBy?: SalePaymentOrderByWithRelationInput | SalePaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SalePaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SalePayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SalePayments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SalePayments
    **/
    _count?: true | SalePaymentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SalePaymentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SalePaymentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SalePaymentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SalePaymentMaxAggregateInputType
  }

  export type GetSalePaymentAggregateType<T extends SalePaymentAggregateArgs> = {
        [P in keyof T & keyof AggregateSalePayment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSalePayment[P]>
      : GetScalarType<T[P], AggregateSalePayment[P]>
  }




  export type SalePaymentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SalePaymentWhereInput
    orderBy?: SalePaymentOrderByWithAggregationInput | SalePaymentOrderByWithAggregationInput[]
    by: SalePaymentScalarFieldEnum[] | SalePaymentScalarFieldEnum
    having?: SalePaymentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SalePaymentCountAggregateInputType | true
    _avg?: SalePaymentAvgAggregateInputType
    _sum?: SalePaymentSumAggregateInputType
    _min?: SalePaymentMinAggregateInputType
    _max?: SalePaymentMaxAggregateInputType
  }

  export type SalePaymentGroupByOutputType = {
    id: string
    saleId: string
    paymentMethod: $Enums.PaymentMethod
    amount: Decimal
    createdAt: Date
    _count: SalePaymentCountAggregateOutputType | null
    _avg: SalePaymentAvgAggregateOutputType | null
    _sum: SalePaymentSumAggregateOutputType | null
    _min: SalePaymentMinAggregateOutputType | null
    _max: SalePaymentMaxAggregateOutputType | null
  }

  type GetSalePaymentGroupByPayload<T extends SalePaymentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SalePaymentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SalePaymentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SalePaymentGroupByOutputType[P]>
            : GetScalarType<T[P], SalePaymentGroupByOutputType[P]>
        }
      >
    >


  export type SalePaymentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    saleId?: boolean
    paymentMethod?: boolean
    amount?: boolean
    createdAt?: boolean
    sale?: boolean | SaleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["salePayment"]>

  export type SalePaymentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    saleId?: boolean
    paymentMethod?: boolean
    amount?: boolean
    createdAt?: boolean
    sale?: boolean | SaleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["salePayment"]>

  export type SalePaymentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    saleId?: boolean
    paymentMethod?: boolean
    amount?: boolean
    createdAt?: boolean
    sale?: boolean | SaleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["salePayment"]>

  export type SalePaymentSelectScalar = {
    id?: boolean
    saleId?: boolean
    paymentMethod?: boolean
    amount?: boolean
    createdAt?: boolean
  }

  export type SalePaymentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "saleId" | "paymentMethod" | "amount" | "createdAt", ExtArgs["result"]["salePayment"]>
  export type SalePaymentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sale?: boolean | SaleDefaultArgs<ExtArgs>
  }
  export type SalePaymentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sale?: boolean | SaleDefaultArgs<ExtArgs>
  }
  export type SalePaymentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sale?: boolean | SaleDefaultArgs<ExtArgs>
  }

  export type $SalePaymentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SalePayment"
    objects: {
      sale: Prisma.$SalePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      saleId: string
      paymentMethod: $Enums.PaymentMethod
      amount: Prisma.Decimal
      createdAt: Date
    }, ExtArgs["result"]["salePayment"]>
    composites: {}
  }

  type SalePaymentGetPayload<S extends boolean | null | undefined | SalePaymentDefaultArgs> = $Result.GetResult<Prisma.$SalePaymentPayload, S>

  type SalePaymentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SalePaymentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SalePaymentCountAggregateInputType | true
    }

  export interface SalePaymentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SalePayment'], meta: { name: 'SalePayment' } }
    /**
     * Find zero or one SalePayment that matches the filter.
     * @param {SalePaymentFindUniqueArgs} args - Arguments to find a SalePayment
     * @example
     * // Get one SalePayment
     * const salePayment = await prisma.salePayment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SalePaymentFindUniqueArgs>(args: SelectSubset<T, SalePaymentFindUniqueArgs<ExtArgs>>): Prisma__SalePaymentClient<$Result.GetResult<Prisma.$SalePaymentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SalePayment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SalePaymentFindUniqueOrThrowArgs} args - Arguments to find a SalePayment
     * @example
     * // Get one SalePayment
     * const salePayment = await prisma.salePayment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SalePaymentFindUniqueOrThrowArgs>(args: SelectSubset<T, SalePaymentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SalePaymentClient<$Result.GetResult<Prisma.$SalePaymentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SalePayment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalePaymentFindFirstArgs} args - Arguments to find a SalePayment
     * @example
     * // Get one SalePayment
     * const salePayment = await prisma.salePayment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SalePaymentFindFirstArgs>(args?: SelectSubset<T, SalePaymentFindFirstArgs<ExtArgs>>): Prisma__SalePaymentClient<$Result.GetResult<Prisma.$SalePaymentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SalePayment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalePaymentFindFirstOrThrowArgs} args - Arguments to find a SalePayment
     * @example
     * // Get one SalePayment
     * const salePayment = await prisma.salePayment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SalePaymentFindFirstOrThrowArgs>(args?: SelectSubset<T, SalePaymentFindFirstOrThrowArgs<ExtArgs>>): Prisma__SalePaymentClient<$Result.GetResult<Prisma.$SalePaymentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SalePayments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalePaymentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SalePayments
     * const salePayments = await prisma.salePayment.findMany()
     * 
     * // Get first 10 SalePayments
     * const salePayments = await prisma.salePayment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const salePaymentWithIdOnly = await prisma.salePayment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SalePaymentFindManyArgs>(args?: SelectSubset<T, SalePaymentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalePaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SalePayment.
     * @param {SalePaymentCreateArgs} args - Arguments to create a SalePayment.
     * @example
     * // Create one SalePayment
     * const SalePayment = await prisma.salePayment.create({
     *   data: {
     *     // ... data to create a SalePayment
     *   }
     * })
     * 
     */
    create<T extends SalePaymentCreateArgs>(args: SelectSubset<T, SalePaymentCreateArgs<ExtArgs>>): Prisma__SalePaymentClient<$Result.GetResult<Prisma.$SalePaymentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SalePayments.
     * @param {SalePaymentCreateManyArgs} args - Arguments to create many SalePayments.
     * @example
     * // Create many SalePayments
     * const salePayment = await prisma.salePayment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SalePaymentCreateManyArgs>(args?: SelectSubset<T, SalePaymentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SalePayments and returns the data saved in the database.
     * @param {SalePaymentCreateManyAndReturnArgs} args - Arguments to create many SalePayments.
     * @example
     * // Create many SalePayments
     * const salePayment = await prisma.salePayment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SalePayments and only return the `id`
     * const salePaymentWithIdOnly = await prisma.salePayment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SalePaymentCreateManyAndReturnArgs>(args?: SelectSubset<T, SalePaymentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalePaymentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SalePayment.
     * @param {SalePaymentDeleteArgs} args - Arguments to delete one SalePayment.
     * @example
     * // Delete one SalePayment
     * const SalePayment = await prisma.salePayment.delete({
     *   where: {
     *     // ... filter to delete one SalePayment
     *   }
     * })
     * 
     */
    delete<T extends SalePaymentDeleteArgs>(args: SelectSubset<T, SalePaymentDeleteArgs<ExtArgs>>): Prisma__SalePaymentClient<$Result.GetResult<Prisma.$SalePaymentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SalePayment.
     * @param {SalePaymentUpdateArgs} args - Arguments to update one SalePayment.
     * @example
     * // Update one SalePayment
     * const salePayment = await prisma.salePayment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SalePaymentUpdateArgs>(args: SelectSubset<T, SalePaymentUpdateArgs<ExtArgs>>): Prisma__SalePaymentClient<$Result.GetResult<Prisma.$SalePaymentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SalePayments.
     * @param {SalePaymentDeleteManyArgs} args - Arguments to filter SalePayments to delete.
     * @example
     * // Delete a few SalePayments
     * const { count } = await prisma.salePayment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SalePaymentDeleteManyArgs>(args?: SelectSubset<T, SalePaymentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SalePayments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalePaymentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SalePayments
     * const salePayment = await prisma.salePayment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SalePaymentUpdateManyArgs>(args: SelectSubset<T, SalePaymentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SalePayments and returns the data updated in the database.
     * @param {SalePaymentUpdateManyAndReturnArgs} args - Arguments to update many SalePayments.
     * @example
     * // Update many SalePayments
     * const salePayment = await prisma.salePayment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SalePayments and only return the `id`
     * const salePaymentWithIdOnly = await prisma.salePayment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SalePaymentUpdateManyAndReturnArgs>(args: SelectSubset<T, SalePaymentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalePaymentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SalePayment.
     * @param {SalePaymentUpsertArgs} args - Arguments to update or create a SalePayment.
     * @example
     * // Update or create a SalePayment
     * const salePayment = await prisma.salePayment.upsert({
     *   create: {
     *     // ... data to create a SalePayment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SalePayment we want to update
     *   }
     * })
     */
    upsert<T extends SalePaymentUpsertArgs>(args: SelectSubset<T, SalePaymentUpsertArgs<ExtArgs>>): Prisma__SalePaymentClient<$Result.GetResult<Prisma.$SalePaymentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SalePayments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalePaymentCountArgs} args - Arguments to filter SalePayments to count.
     * @example
     * // Count the number of SalePayments
     * const count = await prisma.salePayment.count({
     *   where: {
     *     // ... the filter for the SalePayments we want to count
     *   }
     * })
    **/
    count<T extends SalePaymentCountArgs>(
      args?: Subset<T, SalePaymentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SalePaymentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SalePayment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalePaymentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SalePaymentAggregateArgs>(args: Subset<T, SalePaymentAggregateArgs>): Prisma.PrismaPromise<GetSalePaymentAggregateType<T>>

    /**
     * Group by SalePayment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalePaymentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SalePaymentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SalePaymentGroupByArgs['orderBy'] }
        : { orderBy?: SalePaymentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SalePaymentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSalePaymentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SalePayment model
   */
  readonly fields: SalePaymentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SalePayment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SalePaymentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    sale<T extends SaleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SaleDefaultArgs<ExtArgs>>): Prisma__SaleClient<$Result.GetResult<Prisma.$SalePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SalePayment model
   */
  interface SalePaymentFieldRefs {
    readonly id: FieldRef<"SalePayment", 'String'>
    readonly saleId: FieldRef<"SalePayment", 'String'>
    readonly paymentMethod: FieldRef<"SalePayment", 'PaymentMethod'>
    readonly amount: FieldRef<"SalePayment", 'Decimal'>
    readonly createdAt: FieldRef<"SalePayment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SalePayment findUnique
   */
  export type SalePaymentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalePayment
     */
    select?: SalePaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalePayment
     */
    omit?: SalePaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalePaymentInclude<ExtArgs> | null
    /**
     * Filter, which SalePayment to fetch.
     */
    where: SalePaymentWhereUniqueInput
  }

  /**
   * SalePayment findUniqueOrThrow
   */
  export type SalePaymentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalePayment
     */
    select?: SalePaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalePayment
     */
    omit?: SalePaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalePaymentInclude<ExtArgs> | null
    /**
     * Filter, which SalePayment to fetch.
     */
    where: SalePaymentWhereUniqueInput
  }

  /**
   * SalePayment findFirst
   */
  export type SalePaymentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalePayment
     */
    select?: SalePaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalePayment
     */
    omit?: SalePaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalePaymentInclude<ExtArgs> | null
    /**
     * Filter, which SalePayment to fetch.
     */
    where?: SalePaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SalePayments to fetch.
     */
    orderBy?: SalePaymentOrderByWithRelationInput | SalePaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SalePayments.
     */
    cursor?: SalePaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SalePayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SalePayments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SalePayments.
     */
    distinct?: SalePaymentScalarFieldEnum | SalePaymentScalarFieldEnum[]
  }

  /**
   * SalePayment findFirstOrThrow
   */
  export type SalePaymentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalePayment
     */
    select?: SalePaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalePayment
     */
    omit?: SalePaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalePaymentInclude<ExtArgs> | null
    /**
     * Filter, which SalePayment to fetch.
     */
    where?: SalePaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SalePayments to fetch.
     */
    orderBy?: SalePaymentOrderByWithRelationInput | SalePaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SalePayments.
     */
    cursor?: SalePaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SalePayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SalePayments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SalePayments.
     */
    distinct?: SalePaymentScalarFieldEnum | SalePaymentScalarFieldEnum[]
  }

  /**
   * SalePayment findMany
   */
  export type SalePaymentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalePayment
     */
    select?: SalePaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalePayment
     */
    omit?: SalePaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalePaymentInclude<ExtArgs> | null
    /**
     * Filter, which SalePayments to fetch.
     */
    where?: SalePaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SalePayments to fetch.
     */
    orderBy?: SalePaymentOrderByWithRelationInput | SalePaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SalePayments.
     */
    cursor?: SalePaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SalePayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SalePayments.
     */
    skip?: number
    distinct?: SalePaymentScalarFieldEnum | SalePaymentScalarFieldEnum[]
  }

  /**
   * SalePayment create
   */
  export type SalePaymentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalePayment
     */
    select?: SalePaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalePayment
     */
    omit?: SalePaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalePaymentInclude<ExtArgs> | null
    /**
     * The data needed to create a SalePayment.
     */
    data: XOR<SalePaymentCreateInput, SalePaymentUncheckedCreateInput>
  }

  /**
   * SalePayment createMany
   */
  export type SalePaymentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SalePayments.
     */
    data: SalePaymentCreateManyInput | SalePaymentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SalePayment createManyAndReturn
   */
  export type SalePaymentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalePayment
     */
    select?: SalePaymentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SalePayment
     */
    omit?: SalePaymentOmit<ExtArgs> | null
    /**
     * The data used to create many SalePayments.
     */
    data: SalePaymentCreateManyInput | SalePaymentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalePaymentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SalePayment update
   */
  export type SalePaymentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalePayment
     */
    select?: SalePaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalePayment
     */
    omit?: SalePaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalePaymentInclude<ExtArgs> | null
    /**
     * The data needed to update a SalePayment.
     */
    data: XOR<SalePaymentUpdateInput, SalePaymentUncheckedUpdateInput>
    /**
     * Choose, which SalePayment to update.
     */
    where: SalePaymentWhereUniqueInput
  }

  /**
   * SalePayment updateMany
   */
  export type SalePaymentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SalePayments.
     */
    data: XOR<SalePaymentUpdateManyMutationInput, SalePaymentUncheckedUpdateManyInput>
    /**
     * Filter which SalePayments to update
     */
    where?: SalePaymentWhereInput
    /**
     * Limit how many SalePayments to update.
     */
    limit?: number
  }

  /**
   * SalePayment updateManyAndReturn
   */
  export type SalePaymentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalePayment
     */
    select?: SalePaymentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SalePayment
     */
    omit?: SalePaymentOmit<ExtArgs> | null
    /**
     * The data used to update SalePayments.
     */
    data: XOR<SalePaymentUpdateManyMutationInput, SalePaymentUncheckedUpdateManyInput>
    /**
     * Filter which SalePayments to update
     */
    where?: SalePaymentWhereInput
    /**
     * Limit how many SalePayments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalePaymentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SalePayment upsert
   */
  export type SalePaymentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalePayment
     */
    select?: SalePaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalePayment
     */
    omit?: SalePaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalePaymentInclude<ExtArgs> | null
    /**
     * The filter to search for the SalePayment to update in case it exists.
     */
    where: SalePaymentWhereUniqueInput
    /**
     * In case the SalePayment found by the `where` argument doesn't exist, create a new SalePayment with this data.
     */
    create: XOR<SalePaymentCreateInput, SalePaymentUncheckedCreateInput>
    /**
     * In case the SalePayment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SalePaymentUpdateInput, SalePaymentUncheckedUpdateInput>
  }

  /**
   * SalePayment delete
   */
  export type SalePaymentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalePayment
     */
    select?: SalePaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalePayment
     */
    omit?: SalePaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalePaymentInclude<ExtArgs> | null
    /**
     * Filter which SalePayment to delete.
     */
    where: SalePaymentWhereUniqueInput
  }

  /**
   * SalePayment deleteMany
   */
  export type SalePaymentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SalePayments to delete
     */
    where?: SalePaymentWhereInput
    /**
     * Limit how many SalePayments to delete.
     */
    limit?: number
  }

  /**
   * SalePayment without action
   */
  export type SalePaymentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalePayment
     */
    select?: SalePaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalePayment
     */
    omit?: SalePaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalePaymentInclude<ExtArgs> | null
  }


  /**
   * Model Product
   */

  export type AggregateProduct = {
    _count: ProductCountAggregateOutputType | null
    _avg: ProductAvgAggregateOutputType | null
    _sum: ProductSumAggregateOutputType | null
    _min: ProductMinAggregateOutputType | null
    _max: ProductMaxAggregateOutputType | null
  }

  export type ProductAvgAggregateOutputType = {
    price: Decimal | null
    quantity: number | null
  }

  export type ProductSumAggregateOutputType = {
    price: Decimal | null
    quantity: number | null
  }

  export type ProductMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    price: Decimal | null
    quantity: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    price: Decimal | null
    quantity: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductCountAggregateOutputType = {
    id: number
    name: number
    description: number
    price: number
    quantity: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProductAvgAggregateInputType = {
    price?: true
    quantity?: true
  }

  export type ProductSumAggregateInputType = {
    price?: true
    quantity?: true
  }

  export type ProductMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    price?: true
    quantity?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    price?: true
    quantity?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    price?: true
    quantity?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProductAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Product to aggregate.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Products
    **/
    _count?: true | ProductCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductMaxAggregateInputType
  }

  export type GetProductAggregateType<T extends ProductAggregateArgs> = {
        [P in keyof T & keyof AggregateProduct]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProduct[P]>
      : GetScalarType<T[P], AggregateProduct[P]>
  }




  export type ProductGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductWhereInput
    orderBy?: ProductOrderByWithAggregationInput | ProductOrderByWithAggregationInput[]
    by: ProductScalarFieldEnum[] | ProductScalarFieldEnum
    having?: ProductScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductCountAggregateInputType | true
    _avg?: ProductAvgAggregateInputType
    _sum?: ProductSumAggregateInputType
    _min?: ProductMinAggregateInputType
    _max?: ProductMaxAggregateInputType
  }

  export type ProductGroupByOutputType = {
    id: string
    name: string
    description: string | null
    price: Decimal
    quantity: number
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: ProductCountAggregateOutputType | null
    _avg: ProductAvgAggregateOutputType | null
    _sum: ProductSumAggregateOutputType | null
    _min: ProductMinAggregateOutputType | null
    _max: ProductMaxAggregateOutputType | null
  }

  type GetProductGroupByPayload<T extends ProductGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductGroupByOutputType[P]>
            : GetScalarType<T[P], ProductGroupByOutputType[P]>
        }
      >
    >


  export type ProductSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    price?: boolean
    quantity?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    saleProducts?: boolean | Product$saleProductsArgs<ExtArgs>
    _count?: boolean | ProductCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["product"]>

  export type ProductSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    price?: boolean
    quantity?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["product"]>

  export type ProductSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    price?: boolean
    quantity?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["product"]>

  export type ProductSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    price?: boolean
    quantity?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ProductOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "price" | "quantity" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["product"]>
  export type ProductInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    saleProducts?: boolean | Product$saleProductsArgs<ExtArgs>
    _count?: boolean | ProductCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProductIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type ProductIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ProductPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Product"
    objects: {
      saleProducts: Prisma.$SaleProductPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      price: Prisma.Decimal
      quantity: number
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["product"]>
    composites: {}
  }

  type ProductGetPayload<S extends boolean | null | undefined | ProductDefaultArgs> = $Result.GetResult<Prisma.$ProductPayload, S>

  type ProductCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProductFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProductCountAggregateInputType | true
    }

  export interface ProductDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Product'], meta: { name: 'Product' } }
    /**
     * Find zero or one Product that matches the filter.
     * @param {ProductFindUniqueArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductFindUniqueArgs>(args: SelectSubset<T, ProductFindUniqueArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Product that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProductFindUniqueOrThrowArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductFindUniqueOrThrowArgs>(args: SelectSubset<T, ProductFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Product that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindFirstArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductFindFirstArgs>(args?: SelectSubset<T, ProductFindFirstArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Product that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindFirstOrThrowArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductFindFirstOrThrowArgs>(args?: SelectSubset<T, ProductFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Products that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Products
     * const products = await prisma.product.findMany()
     * 
     * // Get first 10 Products
     * const products = await prisma.product.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productWithIdOnly = await prisma.product.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProductFindManyArgs>(args?: SelectSubset<T, ProductFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Product.
     * @param {ProductCreateArgs} args - Arguments to create a Product.
     * @example
     * // Create one Product
     * const Product = await prisma.product.create({
     *   data: {
     *     // ... data to create a Product
     *   }
     * })
     * 
     */
    create<T extends ProductCreateArgs>(args: SelectSubset<T, ProductCreateArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Products.
     * @param {ProductCreateManyArgs} args - Arguments to create many Products.
     * @example
     * // Create many Products
     * const product = await prisma.product.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProductCreateManyArgs>(args?: SelectSubset<T, ProductCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Products and returns the data saved in the database.
     * @param {ProductCreateManyAndReturnArgs} args - Arguments to create many Products.
     * @example
     * // Create many Products
     * const product = await prisma.product.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Products and only return the `id`
     * const productWithIdOnly = await prisma.product.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProductCreateManyAndReturnArgs>(args?: SelectSubset<T, ProductCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Product.
     * @param {ProductDeleteArgs} args - Arguments to delete one Product.
     * @example
     * // Delete one Product
     * const Product = await prisma.product.delete({
     *   where: {
     *     // ... filter to delete one Product
     *   }
     * })
     * 
     */
    delete<T extends ProductDeleteArgs>(args: SelectSubset<T, ProductDeleteArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Product.
     * @param {ProductUpdateArgs} args - Arguments to update one Product.
     * @example
     * // Update one Product
     * const product = await prisma.product.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProductUpdateArgs>(args: SelectSubset<T, ProductUpdateArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Products.
     * @param {ProductDeleteManyArgs} args - Arguments to filter Products to delete.
     * @example
     * // Delete a few Products
     * const { count } = await prisma.product.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProductDeleteManyArgs>(args?: SelectSubset<T, ProductDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Products
     * const product = await prisma.product.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProductUpdateManyArgs>(args: SelectSubset<T, ProductUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Products and returns the data updated in the database.
     * @param {ProductUpdateManyAndReturnArgs} args - Arguments to update many Products.
     * @example
     * // Update many Products
     * const product = await prisma.product.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Products and only return the `id`
     * const productWithIdOnly = await prisma.product.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProductUpdateManyAndReturnArgs>(args: SelectSubset<T, ProductUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Product.
     * @param {ProductUpsertArgs} args - Arguments to update or create a Product.
     * @example
     * // Update or create a Product
     * const product = await prisma.product.upsert({
     *   create: {
     *     // ... data to create a Product
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Product we want to update
     *   }
     * })
     */
    upsert<T extends ProductUpsertArgs>(args: SelectSubset<T, ProductUpsertArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCountArgs} args - Arguments to filter Products to count.
     * @example
     * // Count the number of Products
     * const count = await prisma.product.count({
     *   where: {
     *     // ... the filter for the Products we want to count
     *   }
     * })
    **/
    count<T extends ProductCountArgs>(
      args?: Subset<T, ProductCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductAggregateArgs>(args: Subset<T, ProductAggregateArgs>): Prisma.PrismaPromise<GetProductAggregateType<T>>

    /**
     * Group by Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductGroupByArgs['orderBy'] }
        : { orderBy?: ProductGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Product model
   */
  readonly fields: ProductFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Product.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    saleProducts<T extends Product$saleProductsArgs<ExtArgs> = {}>(args?: Subset<T, Product$saleProductsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SaleProductPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Product model
   */
  interface ProductFieldRefs {
    readonly id: FieldRef<"Product", 'String'>
    readonly name: FieldRef<"Product", 'String'>
    readonly description: FieldRef<"Product", 'String'>
    readonly price: FieldRef<"Product", 'Decimal'>
    readonly quantity: FieldRef<"Product", 'Int'>
    readonly isActive: FieldRef<"Product", 'Boolean'>
    readonly createdAt: FieldRef<"Product", 'DateTime'>
    readonly updatedAt: FieldRef<"Product", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Product findUnique
   */
  export type ProductFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product findUniqueOrThrow
   */
  export type ProductFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product findFirst
   */
  export type ProductFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Products.
     */
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product findFirstOrThrow
   */
  export type ProductFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Products.
     */
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product findMany
   */
  export type ProductFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Products to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product create
   */
  export type ProductCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The data needed to create a Product.
     */
    data: XOR<ProductCreateInput, ProductUncheckedCreateInput>
  }

  /**
   * Product createMany
   */
  export type ProductCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Products.
     */
    data: ProductCreateManyInput | ProductCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Product createManyAndReturn
   */
  export type ProductCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * The data used to create many Products.
     */
    data: ProductCreateManyInput | ProductCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Product update
   */
  export type ProductUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The data needed to update a Product.
     */
    data: XOR<ProductUpdateInput, ProductUncheckedUpdateInput>
    /**
     * Choose, which Product to update.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product updateMany
   */
  export type ProductUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Products.
     */
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyInput>
    /**
     * Filter which Products to update
     */
    where?: ProductWhereInput
    /**
     * Limit how many Products to update.
     */
    limit?: number
  }

  /**
   * Product updateManyAndReturn
   */
  export type ProductUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * The data used to update Products.
     */
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyInput>
    /**
     * Filter which Products to update
     */
    where?: ProductWhereInput
    /**
     * Limit how many Products to update.
     */
    limit?: number
  }

  /**
   * Product upsert
   */
  export type ProductUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The filter to search for the Product to update in case it exists.
     */
    where: ProductWhereUniqueInput
    /**
     * In case the Product found by the `where` argument doesn't exist, create a new Product with this data.
     */
    create: XOR<ProductCreateInput, ProductUncheckedCreateInput>
    /**
     * In case the Product was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductUpdateInput, ProductUncheckedUpdateInput>
  }

  /**
   * Product delete
   */
  export type ProductDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter which Product to delete.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product deleteMany
   */
  export type ProductDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Products to delete
     */
    where?: ProductWhereInput
    /**
     * Limit how many Products to delete.
     */
    limit?: number
  }

  /**
   * Product.saleProducts
   */
  export type Product$saleProductsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleProduct
     */
    select?: SaleProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SaleProduct
     */
    omit?: SaleProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleProductInclude<ExtArgs> | null
    where?: SaleProductWhereInput
    orderBy?: SaleProductOrderByWithRelationInput | SaleProductOrderByWithRelationInput[]
    cursor?: SaleProductWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SaleProductScalarFieldEnum | SaleProductScalarFieldEnum[]
  }

  /**
   * Product without action
   */
  export type ProductDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
  }


  /**
   * Model SaleProduct
   */

  export type AggregateSaleProduct = {
    _count: SaleProductCountAggregateOutputType | null
    _avg: SaleProductAvgAggregateOutputType | null
    _sum: SaleProductSumAggregateOutputType | null
    _min: SaleProductMinAggregateOutputType | null
    _max: SaleProductMaxAggregateOutputType | null
  }

  export type SaleProductAvgAggregateOutputType = {
    quantity: number | null
    unitPrice: Decimal | null
    totalPrice: Decimal | null
  }

  export type SaleProductSumAggregateOutputType = {
    quantity: number | null
    unitPrice: Decimal | null
    totalPrice: Decimal | null
  }

  export type SaleProductMinAggregateOutputType = {
    id: string | null
    saleId: string | null
    productId: string | null
    quantity: number | null
    unitPrice: Decimal | null
    totalPrice: Decimal | null
    createdAt: Date | null
  }

  export type SaleProductMaxAggregateOutputType = {
    id: string | null
    saleId: string | null
    productId: string | null
    quantity: number | null
    unitPrice: Decimal | null
    totalPrice: Decimal | null
    createdAt: Date | null
  }

  export type SaleProductCountAggregateOutputType = {
    id: number
    saleId: number
    productId: number
    quantity: number
    unitPrice: number
    totalPrice: number
    createdAt: number
    _all: number
  }


  export type SaleProductAvgAggregateInputType = {
    quantity?: true
    unitPrice?: true
    totalPrice?: true
  }

  export type SaleProductSumAggregateInputType = {
    quantity?: true
    unitPrice?: true
    totalPrice?: true
  }

  export type SaleProductMinAggregateInputType = {
    id?: true
    saleId?: true
    productId?: true
    quantity?: true
    unitPrice?: true
    totalPrice?: true
    createdAt?: true
  }

  export type SaleProductMaxAggregateInputType = {
    id?: true
    saleId?: true
    productId?: true
    quantity?: true
    unitPrice?: true
    totalPrice?: true
    createdAt?: true
  }

  export type SaleProductCountAggregateInputType = {
    id?: true
    saleId?: true
    productId?: true
    quantity?: true
    unitPrice?: true
    totalPrice?: true
    createdAt?: true
    _all?: true
  }

  export type SaleProductAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SaleProduct to aggregate.
     */
    where?: SaleProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SaleProducts to fetch.
     */
    orderBy?: SaleProductOrderByWithRelationInput | SaleProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SaleProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SaleProducts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SaleProducts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SaleProducts
    **/
    _count?: true | SaleProductCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SaleProductAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SaleProductSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SaleProductMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SaleProductMaxAggregateInputType
  }

  export type GetSaleProductAggregateType<T extends SaleProductAggregateArgs> = {
        [P in keyof T & keyof AggregateSaleProduct]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSaleProduct[P]>
      : GetScalarType<T[P], AggregateSaleProduct[P]>
  }




  export type SaleProductGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SaleProductWhereInput
    orderBy?: SaleProductOrderByWithAggregationInput | SaleProductOrderByWithAggregationInput[]
    by: SaleProductScalarFieldEnum[] | SaleProductScalarFieldEnum
    having?: SaleProductScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SaleProductCountAggregateInputType | true
    _avg?: SaleProductAvgAggregateInputType
    _sum?: SaleProductSumAggregateInputType
    _min?: SaleProductMinAggregateInputType
    _max?: SaleProductMaxAggregateInputType
  }

  export type SaleProductGroupByOutputType = {
    id: string
    saleId: string
    productId: string
    quantity: number
    unitPrice: Decimal
    totalPrice: Decimal
    createdAt: Date
    _count: SaleProductCountAggregateOutputType | null
    _avg: SaleProductAvgAggregateOutputType | null
    _sum: SaleProductSumAggregateOutputType | null
    _min: SaleProductMinAggregateOutputType | null
    _max: SaleProductMaxAggregateOutputType | null
  }

  type GetSaleProductGroupByPayload<T extends SaleProductGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SaleProductGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SaleProductGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SaleProductGroupByOutputType[P]>
            : GetScalarType<T[P], SaleProductGroupByOutputType[P]>
        }
      >
    >


  export type SaleProductSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    saleId?: boolean
    productId?: boolean
    quantity?: boolean
    unitPrice?: boolean
    totalPrice?: boolean
    createdAt?: boolean
    sale?: boolean | SaleDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["saleProduct"]>

  export type SaleProductSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    saleId?: boolean
    productId?: boolean
    quantity?: boolean
    unitPrice?: boolean
    totalPrice?: boolean
    createdAt?: boolean
    sale?: boolean | SaleDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["saleProduct"]>

  export type SaleProductSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    saleId?: boolean
    productId?: boolean
    quantity?: boolean
    unitPrice?: boolean
    totalPrice?: boolean
    createdAt?: boolean
    sale?: boolean | SaleDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["saleProduct"]>

  export type SaleProductSelectScalar = {
    id?: boolean
    saleId?: boolean
    productId?: boolean
    quantity?: boolean
    unitPrice?: boolean
    totalPrice?: boolean
    createdAt?: boolean
  }

  export type SaleProductOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "saleId" | "productId" | "quantity" | "unitPrice" | "totalPrice" | "createdAt", ExtArgs["result"]["saleProduct"]>
  export type SaleProductInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sale?: boolean | SaleDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }
  export type SaleProductIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sale?: boolean | SaleDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }
  export type SaleProductIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sale?: boolean | SaleDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }

  export type $SaleProductPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SaleProduct"
    objects: {
      sale: Prisma.$SalePayload<ExtArgs>
      product: Prisma.$ProductPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      saleId: string
      productId: string
      quantity: number
      unitPrice: Prisma.Decimal
      totalPrice: Prisma.Decimal
      createdAt: Date
    }, ExtArgs["result"]["saleProduct"]>
    composites: {}
  }

  type SaleProductGetPayload<S extends boolean | null | undefined | SaleProductDefaultArgs> = $Result.GetResult<Prisma.$SaleProductPayload, S>

  type SaleProductCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SaleProductFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SaleProductCountAggregateInputType | true
    }

  export interface SaleProductDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SaleProduct'], meta: { name: 'SaleProduct' } }
    /**
     * Find zero or one SaleProduct that matches the filter.
     * @param {SaleProductFindUniqueArgs} args - Arguments to find a SaleProduct
     * @example
     * // Get one SaleProduct
     * const saleProduct = await prisma.saleProduct.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SaleProductFindUniqueArgs>(args: SelectSubset<T, SaleProductFindUniqueArgs<ExtArgs>>): Prisma__SaleProductClient<$Result.GetResult<Prisma.$SaleProductPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SaleProduct that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SaleProductFindUniqueOrThrowArgs} args - Arguments to find a SaleProduct
     * @example
     * // Get one SaleProduct
     * const saleProduct = await prisma.saleProduct.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SaleProductFindUniqueOrThrowArgs>(args: SelectSubset<T, SaleProductFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SaleProductClient<$Result.GetResult<Prisma.$SaleProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SaleProduct that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleProductFindFirstArgs} args - Arguments to find a SaleProduct
     * @example
     * // Get one SaleProduct
     * const saleProduct = await prisma.saleProduct.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SaleProductFindFirstArgs>(args?: SelectSubset<T, SaleProductFindFirstArgs<ExtArgs>>): Prisma__SaleProductClient<$Result.GetResult<Prisma.$SaleProductPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SaleProduct that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleProductFindFirstOrThrowArgs} args - Arguments to find a SaleProduct
     * @example
     * // Get one SaleProduct
     * const saleProduct = await prisma.saleProduct.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SaleProductFindFirstOrThrowArgs>(args?: SelectSubset<T, SaleProductFindFirstOrThrowArgs<ExtArgs>>): Prisma__SaleProductClient<$Result.GetResult<Prisma.$SaleProductPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SaleProducts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleProductFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SaleProducts
     * const saleProducts = await prisma.saleProduct.findMany()
     * 
     * // Get first 10 SaleProducts
     * const saleProducts = await prisma.saleProduct.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const saleProductWithIdOnly = await prisma.saleProduct.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SaleProductFindManyArgs>(args?: SelectSubset<T, SaleProductFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SaleProductPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SaleProduct.
     * @param {SaleProductCreateArgs} args - Arguments to create a SaleProduct.
     * @example
     * // Create one SaleProduct
     * const SaleProduct = await prisma.saleProduct.create({
     *   data: {
     *     // ... data to create a SaleProduct
     *   }
     * })
     * 
     */
    create<T extends SaleProductCreateArgs>(args: SelectSubset<T, SaleProductCreateArgs<ExtArgs>>): Prisma__SaleProductClient<$Result.GetResult<Prisma.$SaleProductPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SaleProducts.
     * @param {SaleProductCreateManyArgs} args - Arguments to create many SaleProducts.
     * @example
     * // Create many SaleProducts
     * const saleProduct = await prisma.saleProduct.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SaleProductCreateManyArgs>(args?: SelectSubset<T, SaleProductCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SaleProducts and returns the data saved in the database.
     * @param {SaleProductCreateManyAndReturnArgs} args - Arguments to create many SaleProducts.
     * @example
     * // Create many SaleProducts
     * const saleProduct = await prisma.saleProduct.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SaleProducts and only return the `id`
     * const saleProductWithIdOnly = await prisma.saleProduct.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SaleProductCreateManyAndReturnArgs>(args?: SelectSubset<T, SaleProductCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SaleProductPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SaleProduct.
     * @param {SaleProductDeleteArgs} args - Arguments to delete one SaleProduct.
     * @example
     * // Delete one SaleProduct
     * const SaleProduct = await prisma.saleProduct.delete({
     *   where: {
     *     // ... filter to delete one SaleProduct
     *   }
     * })
     * 
     */
    delete<T extends SaleProductDeleteArgs>(args: SelectSubset<T, SaleProductDeleteArgs<ExtArgs>>): Prisma__SaleProductClient<$Result.GetResult<Prisma.$SaleProductPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SaleProduct.
     * @param {SaleProductUpdateArgs} args - Arguments to update one SaleProduct.
     * @example
     * // Update one SaleProduct
     * const saleProduct = await prisma.saleProduct.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SaleProductUpdateArgs>(args: SelectSubset<T, SaleProductUpdateArgs<ExtArgs>>): Prisma__SaleProductClient<$Result.GetResult<Prisma.$SaleProductPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SaleProducts.
     * @param {SaleProductDeleteManyArgs} args - Arguments to filter SaleProducts to delete.
     * @example
     * // Delete a few SaleProducts
     * const { count } = await prisma.saleProduct.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SaleProductDeleteManyArgs>(args?: SelectSubset<T, SaleProductDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SaleProducts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleProductUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SaleProducts
     * const saleProduct = await prisma.saleProduct.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SaleProductUpdateManyArgs>(args: SelectSubset<T, SaleProductUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SaleProducts and returns the data updated in the database.
     * @param {SaleProductUpdateManyAndReturnArgs} args - Arguments to update many SaleProducts.
     * @example
     * // Update many SaleProducts
     * const saleProduct = await prisma.saleProduct.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SaleProducts and only return the `id`
     * const saleProductWithIdOnly = await prisma.saleProduct.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SaleProductUpdateManyAndReturnArgs>(args: SelectSubset<T, SaleProductUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SaleProductPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SaleProduct.
     * @param {SaleProductUpsertArgs} args - Arguments to update or create a SaleProduct.
     * @example
     * // Update or create a SaleProduct
     * const saleProduct = await prisma.saleProduct.upsert({
     *   create: {
     *     // ... data to create a SaleProduct
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SaleProduct we want to update
     *   }
     * })
     */
    upsert<T extends SaleProductUpsertArgs>(args: SelectSubset<T, SaleProductUpsertArgs<ExtArgs>>): Prisma__SaleProductClient<$Result.GetResult<Prisma.$SaleProductPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SaleProducts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleProductCountArgs} args - Arguments to filter SaleProducts to count.
     * @example
     * // Count the number of SaleProducts
     * const count = await prisma.saleProduct.count({
     *   where: {
     *     // ... the filter for the SaleProducts we want to count
     *   }
     * })
    **/
    count<T extends SaleProductCountArgs>(
      args?: Subset<T, SaleProductCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SaleProductCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SaleProduct.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleProductAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SaleProductAggregateArgs>(args: Subset<T, SaleProductAggregateArgs>): Prisma.PrismaPromise<GetSaleProductAggregateType<T>>

    /**
     * Group by SaleProduct.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleProductGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SaleProductGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SaleProductGroupByArgs['orderBy'] }
        : { orderBy?: SaleProductGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SaleProductGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSaleProductGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SaleProduct model
   */
  readonly fields: SaleProductFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SaleProduct.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SaleProductClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    sale<T extends SaleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SaleDefaultArgs<ExtArgs>>): Prisma__SaleClient<$Result.GetResult<Prisma.$SalePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SaleProduct model
   */
  interface SaleProductFieldRefs {
    readonly id: FieldRef<"SaleProduct", 'String'>
    readonly saleId: FieldRef<"SaleProduct", 'String'>
    readonly productId: FieldRef<"SaleProduct", 'String'>
    readonly quantity: FieldRef<"SaleProduct", 'Int'>
    readonly unitPrice: FieldRef<"SaleProduct", 'Decimal'>
    readonly totalPrice: FieldRef<"SaleProduct", 'Decimal'>
    readonly createdAt: FieldRef<"SaleProduct", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SaleProduct findUnique
   */
  export type SaleProductFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleProduct
     */
    select?: SaleProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SaleProduct
     */
    omit?: SaleProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleProductInclude<ExtArgs> | null
    /**
     * Filter, which SaleProduct to fetch.
     */
    where: SaleProductWhereUniqueInput
  }

  /**
   * SaleProduct findUniqueOrThrow
   */
  export type SaleProductFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleProduct
     */
    select?: SaleProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SaleProduct
     */
    omit?: SaleProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleProductInclude<ExtArgs> | null
    /**
     * Filter, which SaleProduct to fetch.
     */
    where: SaleProductWhereUniqueInput
  }

  /**
   * SaleProduct findFirst
   */
  export type SaleProductFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleProduct
     */
    select?: SaleProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SaleProduct
     */
    omit?: SaleProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleProductInclude<ExtArgs> | null
    /**
     * Filter, which SaleProduct to fetch.
     */
    where?: SaleProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SaleProducts to fetch.
     */
    orderBy?: SaleProductOrderByWithRelationInput | SaleProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SaleProducts.
     */
    cursor?: SaleProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SaleProducts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SaleProducts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SaleProducts.
     */
    distinct?: SaleProductScalarFieldEnum | SaleProductScalarFieldEnum[]
  }

  /**
   * SaleProduct findFirstOrThrow
   */
  export type SaleProductFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleProduct
     */
    select?: SaleProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SaleProduct
     */
    omit?: SaleProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleProductInclude<ExtArgs> | null
    /**
     * Filter, which SaleProduct to fetch.
     */
    where?: SaleProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SaleProducts to fetch.
     */
    orderBy?: SaleProductOrderByWithRelationInput | SaleProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SaleProducts.
     */
    cursor?: SaleProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SaleProducts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SaleProducts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SaleProducts.
     */
    distinct?: SaleProductScalarFieldEnum | SaleProductScalarFieldEnum[]
  }

  /**
   * SaleProduct findMany
   */
  export type SaleProductFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleProduct
     */
    select?: SaleProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SaleProduct
     */
    omit?: SaleProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleProductInclude<ExtArgs> | null
    /**
     * Filter, which SaleProducts to fetch.
     */
    where?: SaleProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SaleProducts to fetch.
     */
    orderBy?: SaleProductOrderByWithRelationInput | SaleProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SaleProducts.
     */
    cursor?: SaleProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SaleProducts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SaleProducts.
     */
    skip?: number
    distinct?: SaleProductScalarFieldEnum | SaleProductScalarFieldEnum[]
  }

  /**
   * SaleProduct create
   */
  export type SaleProductCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleProduct
     */
    select?: SaleProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SaleProduct
     */
    omit?: SaleProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleProductInclude<ExtArgs> | null
    /**
     * The data needed to create a SaleProduct.
     */
    data: XOR<SaleProductCreateInput, SaleProductUncheckedCreateInput>
  }

  /**
   * SaleProduct createMany
   */
  export type SaleProductCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SaleProducts.
     */
    data: SaleProductCreateManyInput | SaleProductCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SaleProduct createManyAndReturn
   */
  export type SaleProductCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleProduct
     */
    select?: SaleProductSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SaleProduct
     */
    omit?: SaleProductOmit<ExtArgs> | null
    /**
     * The data used to create many SaleProducts.
     */
    data: SaleProductCreateManyInput | SaleProductCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleProductIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SaleProduct update
   */
  export type SaleProductUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleProduct
     */
    select?: SaleProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SaleProduct
     */
    omit?: SaleProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleProductInclude<ExtArgs> | null
    /**
     * The data needed to update a SaleProduct.
     */
    data: XOR<SaleProductUpdateInput, SaleProductUncheckedUpdateInput>
    /**
     * Choose, which SaleProduct to update.
     */
    where: SaleProductWhereUniqueInput
  }

  /**
   * SaleProduct updateMany
   */
  export type SaleProductUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SaleProducts.
     */
    data: XOR<SaleProductUpdateManyMutationInput, SaleProductUncheckedUpdateManyInput>
    /**
     * Filter which SaleProducts to update
     */
    where?: SaleProductWhereInput
    /**
     * Limit how many SaleProducts to update.
     */
    limit?: number
  }

  /**
   * SaleProduct updateManyAndReturn
   */
  export type SaleProductUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleProduct
     */
    select?: SaleProductSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SaleProduct
     */
    omit?: SaleProductOmit<ExtArgs> | null
    /**
     * The data used to update SaleProducts.
     */
    data: XOR<SaleProductUpdateManyMutationInput, SaleProductUncheckedUpdateManyInput>
    /**
     * Filter which SaleProducts to update
     */
    where?: SaleProductWhereInput
    /**
     * Limit how many SaleProducts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleProductIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SaleProduct upsert
   */
  export type SaleProductUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleProduct
     */
    select?: SaleProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SaleProduct
     */
    omit?: SaleProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleProductInclude<ExtArgs> | null
    /**
     * The filter to search for the SaleProduct to update in case it exists.
     */
    where: SaleProductWhereUniqueInput
    /**
     * In case the SaleProduct found by the `where` argument doesn't exist, create a new SaleProduct with this data.
     */
    create: XOR<SaleProductCreateInput, SaleProductUncheckedCreateInput>
    /**
     * In case the SaleProduct was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SaleProductUpdateInput, SaleProductUncheckedUpdateInput>
  }

  /**
   * SaleProduct delete
   */
  export type SaleProductDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleProduct
     */
    select?: SaleProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SaleProduct
     */
    omit?: SaleProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleProductInclude<ExtArgs> | null
    /**
     * Filter which SaleProduct to delete.
     */
    where: SaleProductWhereUniqueInput
  }

  /**
   * SaleProduct deleteMany
   */
  export type SaleProductDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SaleProducts to delete
     */
    where?: SaleProductWhereInput
    /**
     * Limit how many SaleProducts to delete.
     */
    limit?: number
  }

  /**
   * SaleProduct without action
   */
  export type SaleProductDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleProduct
     */
    select?: SaleProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SaleProduct
     */
    omit?: SaleProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleProductInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    password: 'password',
    role: 'role',
    phone: 'phone',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    profilePicture: 'profilePicture'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const CustomerScalarFieldEnum: {
    id: 'id',
    fullName: 'fullName',
    gender: 'gender',
    location: 'location',
    district: 'district',
    province: 'province',
    phone: 'phone',
    email: 'email',
    birthDay: 'birthDay',
    birthMonth: 'birthMonth',
    birthYear: 'birthYear',
    loyaltyPoints: 'loyaltyPoints',
    totalSpent: 'totalSpent',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    isActive: 'isActive',
    additionalLocation: 'additionalLocation',
    isDependent: 'isDependent',
    lastSale: 'lastSale',
    parentId: 'parentId',
    saleCount: 'saleCount',
    sector: 'sector'
  };

  export type CustomerScalarFieldEnum = (typeof CustomerScalarFieldEnum)[keyof typeof CustomerScalarFieldEnum]


  export const ServiceScalarFieldEnum: {
    id: 'id',
    name: 'name',
    category: 'category',
    description: 'description',
    singlePrice: 'singlePrice',
    combinedPrice: 'combinedPrice',
    childPrice: 'childPrice',
    childCombinedPrice: 'childCombinedPrice',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ServiceScalarFieldEnum = (typeof ServiceScalarFieldEnum)[keyof typeof ServiceScalarFieldEnum]


  export const SaleScalarFieldEnum: {
    id: 'id',
    customerId: 'customerId',
    saleDate: 'saleDate',
    totalAmount: 'totalAmount',
    discountAmount: 'discountAmount',
    finalAmount: 'finalAmount',
    loyaltyPointsEarned: 'loyaltyPointsEarned',
    notes: 'notes',
    isCompleted: 'isCompleted',
    createdById: 'createdById',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    birthMonthDiscount: 'birthMonthDiscount',
    ownShampooDiscount: 'ownShampooDiscount',
    paymentMethod: 'paymentMethod'
  };

  export type SaleScalarFieldEnum = (typeof SaleScalarFieldEnum)[keyof typeof SaleScalarFieldEnum]


  export const SaleServiceScalarFieldEnum: {
    id: 'id',
    saleId: 'saleId',
    serviceId: 'serviceId',
    quantity: 'quantity',
    unitPrice: 'unitPrice',
    totalPrice: 'totalPrice',
    isChild: 'isChild',
    isCombined: 'isCombined',
    addShampoo: 'addShampoo',
    createdAt: 'createdAt'
  };

  export type SaleServiceScalarFieldEnum = (typeof SaleServiceScalarFieldEnum)[keyof typeof SaleServiceScalarFieldEnum]


  export const SaleStaffScalarFieldEnum: {
    id: 'id',
    saleId: 'saleId',
    staffId: 'staffId',
    customName: 'customName',
    serviceId: 'serviceId',
    createdAt: 'createdAt'
  };

  export type SaleStaffScalarFieldEnum = (typeof SaleStaffScalarFieldEnum)[keyof typeof SaleStaffScalarFieldEnum]


  export const DiscountRuleScalarFieldEnum: {
    id: 'id',
    name: 'name',
    type: 'type',
    value: 'value',
    isPercentage: 'isPercentage',
    isActive: 'isActive',
    description: 'description',
    minAmount: 'minAmount',
    maxDiscount: 'maxDiscount',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DiscountRuleScalarFieldEnum = (typeof DiscountRuleScalarFieldEnum)[keyof typeof DiscountRuleScalarFieldEnum]


  export const SaleDiscountScalarFieldEnum: {
    id: 'id',
    saleId: 'saleId',
    discountRuleId: 'discountRuleId',
    discountAmount: 'discountAmount',
    createdAt: 'createdAt'
  };

  export type SaleDiscountScalarFieldEnum = (typeof SaleDiscountScalarFieldEnum)[keyof typeof SaleDiscountScalarFieldEnum]


  export const CustomerDiscountScalarFieldEnum: {
    id: 'id',
    customerId: 'customerId',
    discountRuleId: 'discountRuleId',
    usedAt: 'usedAt',
    discountAmount: 'discountAmount'
  };

  export type CustomerDiscountScalarFieldEnum = (typeof CustomerDiscountScalarFieldEnum)[keyof typeof CustomerDiscountScalarFieldEnum]


  export const SalePaymentScalarFieldEnum: {
    id: 'id',
    saleId: 'saleId',
    paymentMethod: 'paymentMethod',
    amount: 'amount',
    createdAt: 'createdAt'
  };

  export type SalePaymentScalarFieldEnum = (typeof SalePaymentScalarFieldEnum)[keyof typeof SalePaymentScalarFieldEnum]


  export const ProductScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    price: 'price',
    quantity: 'quantity',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProductScalarFieldEnum = (typeof ProductScalarFieldEnum)[keyof typeof ProductScalarFieldEnum]


  export const SaleProductScalarFieldEnum: {
    id: 'id',
    saleId: 'saleId',
    productId: 'productId',
    quantity: 'quantity',
    unitPrice: 'unitPrice',
    totalPrice: 'totalPrice',
    createdAt: 'createdAt'
  };

  export type SaleProductScalarFieldEnum = (typeof SaleProductScalarFieldEnum)[keyof typeof SaleProductScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Role'
   */
  export type EnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role'>
    


  /**
   * Reference to a field of type 'Role[]'
   */
  export type ListEnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Gender'
   */
  export type EnumGenderFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Gender'>
    


  /**
   * Reference to a field of type 'Gender[]'
   */
  export type ListEnumGenderFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Gender[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    


  /**
   * Reference to a field of type 'ServiceCategory'
   */
  export type EnumServiceCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ServiceCategory'>
    


  /**
   * Reference to a field of type 'ServiceCategory[]'
   */
  export type ListEnumServiceCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ServiceCategory[]'>
    


  /**
   * Reference to a field of type 'PaymentMethod'
   */
  export type EnumPaymentMethodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentMethod'>
    


  /**
   * Reference to a field of type 'PaymentMethod[]'
   */
  export type ListEnumPaymentMethodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentMethod[]'>
    


  /**
   * Reference to a field of type 'DiscountType'
   */
  export type EnumDiscountTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DiscountType'>
    


  /**
   * Reference to a field of type 'DiscountType[]'
   */
  export type ListEnumDiscountTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DiscountType[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    name?: StringFilter<"User"> | string
    email?: StringNullableFilter<"User"> | string | null
    password?: StringFilter<"User"> | string
    role?: EnumRoleFilter<"User"> | $Enums.Role
    phone?: StringFilter<"User"> | string
    isActive?: BoolFilter<"User"> | boolean
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    profilePicture?: StringNullableFilter<"User"> | string | null
    staffSales?: SaleStaffListRelationFilter
    sales?: SaleListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrderInput | SortOrder
    password?: SortOrder
    role?: SortOrder
    phone?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    profilePicture?: SortOrderInput | SortOrder
    staffSales?: SaleStaffOrderByRelationAggregateInput
    sales?: SaleOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    phone?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    name?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    role?: EnumRoleFilter<"User"> | $Enums.Role
    isActive?: BoolFilter<"User"> | boolean
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    profilePicture?: StringNullableFilter<"User"> | string | null
    staffSales?: SaleStaffListRelationFilter
    sales?: SaleListRelationFilter
  }, "id" | "email" | "phone">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrderInput | SortOrder
    password?: SortOrder
    role?: SortOrder
    phone?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    profilePicture?: SortOrderInput | SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    name?: StringWithAggregatesFilter<"User"> | string
    email?: StringNullableWithAggregatesFilter<"User"> | string | null
    password?: StringWithAggregatesFilter<"User"> | string
    role?: EnumRoleWithAggregatesFilter<"User"> | $Enums.Role
    phone?: StringWithAggregatesFilter<"User"> | string
    isActive?: BoolWithAggregatesFilter<"User"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    profilePicture?: StringNullableWithAggregatesFilter<"User"> | string | null
  }

  export type CustomerWhereInput = {
    AND?: CustomerWhereInput | CustomerWhereInput[]
    OR?: CustomerWhereInput[]
    NOT?: CustomerWhereInput | CustomerWhereInput[]
    id?: StringFilter<"Customer"> | string
    fullName?: StringFilter<"Customer"> | string
    gender?: EnumGenderFilter<"Customer"> | $Enums.Gender
    location?: StringFilter<"Customer"> | string
    district?: StringFilter<"Customer"> | string
    province?: StringFilter<"Customer"> | string
    phone?: StringNullableFilter<"Customer"> | string | null
    email?: StringNullableFilter<"Customer"> | string | null
    birthDay?: IntFilter<"Customer"> | number
    birthMonth?: IntFilter<"Customer"> | number
    birthYear?: IntNullableFilter<"Customer"> | number | null
    loyaltyPoints?: IntFilter<"Customer"> | number
    totalSpent?: DecimalFilter<"Customer"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"Customer"> | Date | string
    updatedAt?: DateTimeFilter<"Customer"> | Date | string
    isActive?: BoolFilter<"Customer"> | boolean
    additionalLocation?: StringNullableFilter<"Customer"> | string | null
    isDependent?: BoolFilter<"Customer"> | boolean
    lastSale?: DateTimeNullableFilter<"Customer"> | Date | string | null
    parentId?: StringNullableFilter<"Customer"> | string | null
    saleCount?: IntFilter<"Customer"> | number
    sector?: StringNullableFilter<"Customer"> | string | null
    discounts?: CustomerDiscountListRelationFilter
    parent?: XOR<CustomerNullableScalarRelationFilter, CustomerWhereInput> | null
    dependents?: CustomerListRelationFilter
    sales?: SaleListRelationFilter
  }

  export type CustomerOrderByWithRelationInput = {
    id?: SortOrder
    fullName?: SortOrder
    gender?: SortOrder
    location?: SortOrder
    district?: SortOrder
    province?: SortOrder
    phone?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    birthDay?: SortOrder
    birthMonth?: SortOrder
    birthYear?: SortOrderInput | SortOrder
    loyaltyPoints?: SortOrder
    totalSpent?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isActive?: SortOrder
    additionalLocation?: SortOrderInput | SortOrder
    isDependent?: SortOrder
    lastSale?: SortOrderInput | SortOrder
    parentId?: SortOrderInput | SortOrder
    saleCount?: SortOrder
    sector?: SortOrderInput | SortOrder
    discounts?: CustomerDiscountOrderByRelationAggregateInput
    parent?: CustomerOrderByWithRelationInput
    dependents?: CustomerOrderByRelationAggregateInput
    sales?: SaleOrderByRelationAggregateInput
  }

  export type CustomerWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CustomerWhereInput | CustomerWhereInput[]
    OR?: CustomerWhereInput[]
    NOT?: CustomerWhereInput | CustomerWhereInput[]
    fullName?: StringFilter<"Customer"> | string
    gender?: EnumGenderFilter<"Customer"> | $Enums.Gender
    location?: StringFilter<"Customer"> | string
    district?: StringFilter<"Customer"> | string
    province?: StringFilter<"Customer"> | string
    phone?: StringNullableFilter<"Customer"> | string | null
    email?: StringNullableFilter<"Customer"> | string | null
    birthDay?: IntFilter<"Customer"> | number
    birthMonth?: IntFilter<"Customer"> | number
    birthYear?: IntNullableFilter<"Customer"> | number | null
    loyaltyPoints?: IntFilter<"Customer"> | number
    totalSpent?: DecimalFilter<"Customer"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"Customer"> | Date | string
    updatedAt?: DateTimeFilter<"Customer"> | Date | string
    isActive?: BoolFilter<"Customer"> | boolean
    additionalLocation?: StringNullableFilter<"Customer"> | string | null
    isDependent?: BoolFilter<"Customer"> | boolean
    lastSale?: DateTimeNullableFilter<"Customer"> | Date | string | null
    parentId?: StringNullableFilter<"Customer"> | string | null
    saleCount?: IntFilter<"Customer"> | number
    sector?: StringNullableFilter<"Customer"> | string | null
    discounts?: CustomerDiscountListRelationFilter
    parent?: XOR<CustomerNullableScalarRelationFilter, CustomerWhereInput> | null
    dependents?: CustomerListRelationFilter
    sales?: SaleListRelationFilter
  }, "id">

  export type CustomerOrderByWithAggregationInput = {
    id?: SortOrder
    fullName?: SortOrder
    gender?: SortOrder
    location?: SortOrder
    district?: SortOrder
    province?: SortOrder
    phone?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    birthDay?: SortOrder
    birthMonth?: SortOrder
    birthYear?: SortOrderInput | SortOrder
    loyaltyPoints?: SortOrder
    totalSpent?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isActive?: SortOrder
    additionalLocation?: SortOrderInput | SortOrder
    isDependent?: SortOrder
    lastSale?: SortOrderInput | SortOrder
    parentId?: SortOrderInput | SortOrder
    saleCount?: SortOrder
    sector?: SortOrderInput | SortOrder
    _count?: CustomerCountOrderByAggregateInput
    _avg?: CustomerAvgOrderByAggregateInput
    _max?: CustomerMaxOrderByAggregateInput
    _min?: CustomerMinOrderByAggregateInput
    _sum?: CustomerSumOrderByAggregateInput
  }

  export type CustomerScalarWhereWithAggregatesInput = {
    AND?: CustomerScalarWhereWithAggregatesInput | CustomerScalarWhereWithAggregatesInput[]
    OR?: CustomerScalarWhereWithAggregatesInput[]
    NOT?: CustomerScalarWhereWithAggregatesInput | CustomerScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Customer"> | string
    fullName?: StringWithAggregatesFilter<"Customer"> | string
    gender?: EnumGenderWithAggregatesFilter<"Customer"> | $Enums.Gender
    location?: StringWithAggregatesFilter<"Customer"> | string
    district?: StringWithAggregatesFilter<"Customer"> | string
    province?: StringWithAggregatesFilter<"Customer"> | string
    phone?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    email?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    birthDay?: IntWithAggregatesFilter<"Customer"> | number
    birthMonth?: IntWithAggregatesFilter<"Customer"> | number
    birthYear?: IntNullableWithAggregatesFilter<"Customer"> | number | null
    loyaltyPoints?: IntWithAggregatesFilter<"Customer"> | number
    totalSpent?: DecimalWithAggregatesFilter<"Customer"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeWithAggregatesFilter<"Customer"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Customer"> | Date | string
    isActive?: BoolWithAggregatesFilter<"Customer"> | boolean
    additionalLocation?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    isDependent?: BoolWithAggregatesFilter<"Customer"> | boolean
    lastSale?: DateTimeNullableWithAggregatesFilter<"Customer"> | Date | string | null
    parentId?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    saleCount?: IntWithAggregatesFilter<"Customer"> | number
    sector?: StringNullableWithAggregatesFilter<"Customer"> | string | null
  }

  export type ServiceWhereInput = {
    AND?: ServiceWhereInput | ServiceWhereInput[]
    OR?: ServiceWhereInput[]
    NOT?: ServiceWhereInput | ServiceWhereInput[]
    id?: StringFilter<"Service"> | string
    name?: StringFilter<"Service"> | string
    category?: EnumServiceCategoryFilter<"Service"> | $Enums.ServiceCategory
    description?: StringNullableFilter<"Service"> | string | null
    singlePrice?: DecimalFilter<"Service"> | Decimal | DecimalJsLike | number | string
    combinedPrice?: DecimalNullableFilter<"Service"> | Decimal | DecimalJsLike | number | string | null
    childPrice?: DecimalNullableFilter<"Service"> | Decimal | DecimalJsLike | number | string | null
    childCombinedPrice?: DecimalNullableFilter<"Service"> | Decimal | DecimalJsLike | number | string | null
    isActive?: BoolFilter<"Service"> | boolean
    createdAt?: DateTimeFilter<"Service"> | Date | string
    updatedAt?: DateTimeFilter<"Service"> | Date | string
    saleServices?: SaleServiceListRelationFilter
  }

  export type ServiceOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    category?: SortOrder
    description?: SortOrderInput | SortOrder
    singlePrice?: SortOrder
    combinedPrice?: SortOrderInput | SortOrder
    childPrice?: SortOrderInput | SortOrder
    childCombinedPrice?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    saleServices?: SaleServiceOrderByRelationAggregateInput
  }

  export type ServiceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: ServiceWhereInput | ServiceWhereInput[]
    OR?: ServiceWhereInput[]
    NOT?: ServiceWhereInput | ServiceWhereInput[]
    category?: EnumServiceCategoryFilter<"Service"> | $Enums.ServiceCategory
    description?: StringNullableFilter<"Service"> | string | null
    singlePrice?: DecimalFilter<"Service"> | Decimal | DecimalJsLike | number | string
    combinedPrice?: DecimalNullableFilter<"Service"> | Decimal | DecimalJsLike | number | string | null
    childPrice?: DecimalNullableFilter<"Service"> | Decimal | DecimalJsLike | number | string | null
    childCombinedPrice?: DecimalNullableFilter<"Service"> | Decimal | DecimalJsLike | number | string | null
    isActive?: BoolFilter<"Service"> | boolean
    createdAt?: DateTimeFilter<"Service"> | Date | string
    updatedAt?: DateTimeFilter<"Service"> | Date | string
    saleServices?: SaleServiceListRelationFilter
  }, "id" | "name">

  export type ServiceOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    category?: SortOrder
    description?: SortOrderInput | SortOrder
    singlePrice?: SortOrder
    combinedPrice?: SortOrderInput | SortOrder
    childPrice?: SortOrderInput | SortOrder
    childCombinedPrice?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ServiceCountOrderByAggregateInput
    _avg?: ServiceAvgOrderByAggregateInput
    _max?: ServiceMaxOrderByAggregateInput
    _min?: ServiceMinOrderByAggregateInput
    _sum?: ServiceSumOrderByAggregateInput
  }

  export type ServiceScalarWhereWithAggregatesInput = {
    AND?: ServiceScalarWhereWithAggregatesInput | ServiceScalarWhereWithAggregatesInput[]
    OR?: ServiceScalarWhereWithAggregatesInput[]
    NOT?: ServiceScalarWhereWithAggregatesInput | ServiceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Service"> | string
    name?: StringWithAggregatesFilter<"Service"> | string
    category?: EnumServiceCategoryWithAggregatesFilter<"Service"> | $Enums.ServiceCategory
    description?: StringNullableWithAggregatesFilter<"Service"> | string | null
    singlePrice?: DecimalWithAggregatesFilter<"Service"> | Decimal | DecimalJsLike | number | string
    combinedPrice?: DecimalNullableWithAggregatesFilter<"Service"> | Decimal | DecimalJsLike | number | string | null
    childPrice?: DecimalNullableWithAggregatesFilter<"Service"> | Decimal | DecimalJsLike | number | string | null
    childCombinedPrice?: DecimalNullableWithAggregatesFilter<"Service"> | Decimal | DecimalJsLike | number | string | null
    isActive?: BoolWithAggregatesFilter<"Service"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Service"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Service"> | Date | string
  }

  export type SaleWhereInput = {
    AND?: SaleWhereInput | SaleWhereInput[]
    OR?: SaleWhereInput[]
    NOT?: SaleWhereInput | SaleWhereInput[]
    id?: StringFilter<"Sale"> | string
    customerId?: StringFilter<"Sale"> | string
    saleDate?: DateTimeFilter<"Sale"> | Date | string
    totalAmount?: DecimalFilter<"Sale"> | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFilter<"Sale"> | Decimal | DecimalJsLike | number | string
    finalAmount?: DecimalFilter<"Sale"> | Decimal | DecimalJsLike | number | string
    loyaltyPointsEarned?: IntFilter<"Sale"> | number
    notes?: StringNullableFilter<"Sale"> | string | null
    isCompleted?: BoolFilter<"Sale"> | boolean
    createdById?: StringFilter<"Sale"> | string
    createdAt?: DateTimeFilter<"Sale"> | Date | string
    updatedAt?: DateTimeFilter<"Sale"> | Date | string
    birthMonthDiscount?: BoolFilter<"Sale"> | boolean
    ownShampooDiscount?: BoolFilter<"Sale"> | boolean
    paymentMethod?: EnumPaymentMethodFilter<"Sale"> | $Enums.PaymentMethod
    discounts?: SaleDiscountListRelationFilter
    services?: SaleServiceListRelationFilter
    products?: SaleProductListRelationFilter
    staff?: SaleStaffListRelationFilter
    payments?: SalePaymentListRelationFilter
    createdBy?: XOR<UserScalarRelationFilter, UserWhereInput>
    customer?: XOR<CustomerScalarRelationFilter, CustomerWhereInput>
  }

  export type SaleOrderByWithRelationInput = {
    id?: SortOrder
    customerId?: SortOrder
    saleDate?: SortOrder
    totalAmount?: SortOrder
    discountAmount?: SortOrder
    finalAmount?: SortOrder
    loyaltyPointsEarned?: SortOrder
    notes?: SortOrderInput | SortOrder
    isCompleted?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    birthMonthDiscount?: SortOrder
    ownShampooDiscount?: SortOrder
    paymentMethod?: SortOrder
    discounts?: SaleDiscountOrderByRelationAggregateInput
    services?: SaleServiceOrderByRelationAggregateInput
    products?: SaleProductOrderByRelationAggregateInput
    staff?: SaleStaffOrderByRelationAggregateInput
    payments?: SalePaymentOrderByRelationAggregateInput
    createdBy?: UserOrderByWithRelationInput
    customer?: CustomerOrderByWithRelationInput
  }

  export type SaleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SaleWhereInput | SaleWhereInput[]
    OR?: SaleWhereInput[]
    NOT?: SaleWhereInput | SaleWhereInput[]
    customerId?: StringFilter<"Sale"> | string
    saleDate?: DateTimeFilter<"Sale"> | Date | string
    totalAmount?: DecimalFilter<"Sale"> | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFilter<"Sale"> | Decimal | DecimalJsLike | number | string
    finalAmount?: DecimalFilter<"Sale"> | Decimal | DecimalJsLike | number | string
    loyaltyPointsEarned?: IntFilter<"Sale"> | number
    notes?: StringNullableFilter<"Sale"> | string | null
    isCompleted?: BoolFilter<"Sale"> | boolean
    createdById?: StringFilter<"Sale"> | string
    createdAt?: DateTimeFilter<"Sale"> | Date | string
    updatedAt?: DateTimeFilter<"Sale"> | Date | string
    birthMonthDiscount?: BoolFilter<"Sale"> | boolean
    ownShampooDiscount?: BoolFilter<"Sale"> | boolean
    paymentMethod?: EnumPaymentMethodFilter<"Sale"> | $Enums.PaymentMethod
    discounts?: SaleDiscountListRelationFilter
    services?: SaleServiceListRelationFilter
    products?: SaleProductListRelationFilter
    staff?: SaleStaffListRelationFilter
    payments?: SalePaymentListRelationFilter
    createdBy?: XOR<UserScalarRelationFilter, UserWhereInput>
    customer?: XOR<CustomerScalarRelationFilter, CustomerWhereInput>
  }, "id">

  export type SaleOrderByWithAggregationInput = {
    id?: SortOrder
    customerId?: SortOrder
    saleDate?: SortOrder
    totalAmount?: SortOrder
    discountAmount?: SortOrder
    finalAmount?: SortOrder
    loyaltyPointsEarned?: SortOrder
    notes?: SortOrderInput | SortOrder
    isCompleted?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    birthMonthDiscount?: SortOrder
    ownShampooDiscount?: SortOrder
    paymentMethod?: SortOrder
    _count?: SaleCountOrderByAggregateInput
    _avg?: SaleAvgOrderByAggregateInput
    _max?: SaleMaxOrderByAggregateInput
    _min?: SaleMinOrderByAggregateInput
    _sum?: SaleSumOrderByAggregateInput
  }

  export type SaleScalarWhereWithAggregatesInput = {
    AND?: SaleScalarWhereWithAggregatesInput | SaleScalarWhereWithAggregatesInput[]
    OR?: SaleScalarWhereWithAggregatesInput[]
    NOT?: SaleScalarWhereWithAggregatesInput | SaleScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Sale"> | string
    customerId?: StringWithAggregatesFilter<"Sale"> | string
    saleDate?: DateTimeWithAggregatesFilter<"Sale"> | Date | string
    totalAmount?: DecimalWithAggregatesFilter<"Sale"> | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalWithAggregatesFilter<"Sale"> | Decimal | DecimalJsLike | number | string
    finalAmount?: DecimalWithAggregatesFilter<"Sale"> | Decimal | DecimalJsLike | number | string
    loyaltyPointsEarned?: IntWithAggregatesFilter<"Sale"> | number
    notes?: StringNullableWithAggregatesFilter<"Sale"> | string | null
    isCompleted?: BoolWithAggregatesFilter<"Sale"> | boolean
    createdById?: StringWithAggregatesFilter<"Sale"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Sale"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Sale"> | Date | string
    birthMonthDiscount?: BoolWithAggregatesFilter<"Sale"> | boolean
    ownShampooDiscount?: BoolWithAggregatesFilter<"Sale"> | boolean
    paymentMethod?: EnumPaymentMethodWithAggregatesFilter<"Sale"> | $Enums.PaymentMethod
  }

  export type SaleServiceWhereInput = {
    AND?: SaleServiceWhereInput | SaleServiceWhereInput[]
    OR?: SaleServiceWhereInput[]
    NOT?: SaleServiceWhereInput | SaleServiceWhereInput[]
    id?: StringFilter<"SaleService"> | string
    saleId?: StringFilter<"SaleService"> | string
    serviceId?: StringFilter<"SaleService"> | string
    quantity?: IntFilter<"SaleService"> | number
    unitPrice?: DecimalFilter<"SaleService"> | Decimal | DecimalJsLike | number | string
    totalPrice?: DecimalFilter<"SaleService"> | Decimal | DecimalJsLike | number | string
    isChild?: BoolFilter<"SaleService"> | boolean
    isCombined?: BoolFilter<"SaleService"> | boolean
    addShampoo?: BoolFilter<"SaleService"> | boolean
    createdAt?: DateTimeFilter<"SaleService"> | Date | string
    sale?: XOR<SaleScalarRelationFilter, SaleWhereInput>
    service?: XOR<ServiceScalarRelationFilter, ServiceWhereInput>
  }

  export type SaleServiceOrderByWithRelationInput = {
    id?: SortOrder
    saleId?: SortOrder
    serviceId?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    totalPrice?: SortOrder
    isChild?: SortOrder
    isCombined?: SortOrder
    addShampoo?: SortOrder
    createdAt?: SortOrder
    sale?: SaleOrderByWithRelationInput
    service?: ServiceOrderByWithRelationInput
  }

  export type SaleServiceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SaleServiceWhereInput | SaleServiceWhereInput[]
    OR?: SaleServiceWhereInput[]
    NOT?: SaleServiceWhereInput | SaleServiceWhereInput[]
    saleId?: StringFilter<"SaleService"> | string
    serviceId?: StringFilter<"SaleService"> | string
    quantity?: IntFilter<"SaleService"> | number
    unitPrice?: DecimalFilter<"SaleService"> | Decimal | DecimalJsLike | number | string
    totalPrice?: DecimalFilter<"SaleService"> | Decimal | DecimalJsLike | number | string
    isChild?: BoolFilter<"SaleService"> | boolean
    isCombined?: BoolFilter<"SaleService"> | boolean
    addShampoo?: BoolFilter<"SaleService"> | boolean
    createdAt?: DateTimeFilter<"SaleService"> | Date | string
    sale?: XOR<SaleScalarRelationFilter, SaleWhereInput>
    service?: XOR<ServiceScalarRelationFilter, ServiceWhereInput>
  }, "id">

  export type SaleServiceOrderByWithAggregationInput = {
    id?: SortOrder
    saleId?: SortOrder
    serviceId?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    totalPrice?: SortOrder
    isChild?: SortOrder
    isCombined?: SortOrder
    addShampoo?: SortOrder
    createdAt?: SortOrder
    _count?: SaleServiceCountOrderByAggregateInput
    _avg?: SaleServiceAvgOrderByAggregateInput
    _max?: SaleServiceMaxOrderByAggregateInput
    _min?: SaleServiceMinOrderByAggregateInput
    _sum?: SaleServiceSumOrderByAggregateInput
  }

  export type SaleServiceScalarWhereWithAggregatesInput = {
    AND?: SaleServiceScalarWhereWithAggregatesInput | SaleServiceScalarWhereWithAggregatesInput[]
    OR?: SaleServiceScalarWhereWithAggregatesInput[]
    NOT?: SaleServiceScalarWhereWithAggregatesInput | SaleServiceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SaleService"> | string
    saleId?: StringWithAggregatesFilter<"SaleService"> | string
    serviceId?: StringWithAggregatesFilter<"SaleService"> | string
    quantity?: IntWithAggregatesFilter<"SaleService"> | number
    unitPrice?: DecimalWithAggregatesFilter<"SaleService"> | Decimal | DecimalJsLike | number | string
    totalPrice?: DecimalWithAggregatesFilter<"SaleService"> | Decimal | DecimalJsLike | number | string
    isChild?: BoolWithAggregatesFilter<"SaleService"> | boolean
    isCombined?: BoolWithAggregatesFilter<"SaleService"> | boolean
    addShampoo?: BoolWithAggregatesFilter<"SaleService"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"SaleService"> | Date | string
  }

  export type SaleStaffWhereInput = {
    AND?: SaleStaffWhereInput | SaleStaffWhereInput[]
    OR?: SaleStaffWhereInput[]
    NOT?: SaleStaffWhereInput | SaleStaffWhereInput[]
    id?: StringFilter<"SaleStaff"> | string
    saleId?: StringFilter<"SaleStaff"> | string
    staffId?: StringNullableFilter<"SaleStaff"> | string | null
    customName?: StringNullableFilter<"SaleStaff"> | string | null
    serviceId?: StringNullableFilter<"SaleStaff"> | string | null
    createdAt?: DateTimeFilter<"SaleStaff"> | Date | string
    sale?: XOR<SaleScalarRelationFilter, SaleWhereInput>
    staff?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type SaleStaffOrderByWithRelationInput = {
    id?: SortOrder
    saleId?: SortOrder
    staffId?: SortOrderInput | SortOrder
    customName?: SortOrderInput | SortOrder
    serviceId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    sale?: SaleOrderByWithRelationInput
    staff?: UserOrderByWithRelationInput
  }

  export type SaleStaffWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SaleStaffWhereInput | SaleStaffWhereInput[]
    OR?: SaleStaffWhereInput[]
    NOT?: SaleStaffWhereInput | SaleStaffWhereInput[]
    saleId?: StringFilter<"SaleStaff"> | string
    staffId?: StringNullableFilter<"SaleStaff"> | string | null
    customName?: StringNullableFilter<"SaleStaff"> | string | null
    serviceId?: StringNullableFilter<"SaleStaff"> | string | null
    createdAt?: DateTimeFilter<"SaleStaff"> | Date | string
    sale?: XOR<SaleScalarRelationFilter, SaleWhereInput>
    staff?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id">

  export type SaleStaffOrderByWithAggregationInput = {
    id?: SortOrder
    saleId?: SortOrder
    staffId?: SortOrderInput | SortOrder
    customName?: SortOrderInput | SortOrder
    serviceId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: SaleStaffCountOrderByAggregateInput
    _max?: SaleStaffMaxOrderByAggregateInput
    _min?: SaleStaffMinOrderByAggregateInput
  }

  export type SaleStaffScalarWhereWithAggregatesInput = {
    AND?: SaleStaffScalarWhereWithAggregatesInput | SaleStaffScalarWhereWithAggregatesInput[]
    OR?: SaleStaffScalarWhereWithAggregatesInput[]
    NOT?: SaleStaffScalarWhereWithAggregatesInput | SaleStaffScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SaleStaff"> | string
    saleId?: StringWithAggregatesFilter<"SaleStaff"> | string
    staffId?: StringNullableWithAggregatesFilter<"SaleStaff"> | string | null
    customName?: StringNullableWithAggregatesFilter<"SaleStaff"> | string | null
    serviceId?: StringNullableWithAggregatesFilter<"SaleStaff"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"SaleStaff"> | Date | string
  }

  export type DiscountRuleWhereInput = {
    AND?: DiscountRuleWhereInput | DiscountRuleWhereInput[]
    OR?: DiscountRuleWhereInput[]
    NOT?: DiscountRuleWhereInput | DiscountRuleWhereInput[]
    id?: StringFilter<"DiscountRule"> | string
    name?: StringFilter<"DiscountRule"> | string
    type?: EnumDiscountTypeFilter<"DiscountRule"> | $Enums.DiscountType
    value?: DecimalFilter<"DiscountRule"> | Decimal | DecimalJsLike | number | string
    isPercentage?: BoolFilter<"DiscountRule"> | boolean
    isActive?: BoolFilter<"DiscountRule"> | boolean
    description?: StringNullableFilter<"DiscountRule"> | string | null
    minAmount?: DecimalNullableFilter<"DiscountRule"> | Decimal | DecimalJsLike | number | string | null
    maxDiscount?: DecimalNullableFilter<"DiscountRule"> | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFilter<"DiscountRule"> | Date | string
    updatedAt?: DateTimeFilter<"DiscountRule"> | Date | string
    customerDiscounts?: CustomerDiscountListRelationFilter
    saleDiscounts?: SaleDiscountListRelationFilter
  }

  export type DiscountRuleOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    value?: SortOrder
    isPercentage?: SortOrder
    isActive?: SortOrder
    description?: SortOrderInput | SortOrder
    minAmount?: SortOrderInput | SortOrder
    maxDiscount?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    customerDiscounts?: CustomerDiscountOrderByRelationAggregateInput
    saleDiscounts?: SaleDiscountOrderByRelationAggregateInput
  }

  export type DiscountRuleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: DiscountRuleWhereInput | DiscountRuleWhereInput[]
    OR?: DiscountRuleWhereInput[]
    NOT?: DiscountRuleWhereInput | DiscountRuleWhereInput[]
    type?: EnumDiscountTypeFilter<"DiscountRule"> | $Enums.DiscountType
    value?: DecimalFilter<"DiscountRule"> | Decimal | DecimalJsLike | number | string
    isPercentage?: BoolFilter<"DiscountRule"> | boolean
    isActive?: BoolFilter<"DiscountRule"> | boolean
    description?: StringNullableFilter<"DiscountRule"> | string | null
    minAmount?: DecimalNullableFilter<"DiscountRule"> | Decimal | DecimalJsLike | number | string | null
    maxDiscount?: DecimalNullableFilter<"DiscountRule"> | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFilter<"DiscountRule"> | Date | string
    updatedAt?: DateTimeFilter<"DiscountRule"> | Date | string
    customerDiscounts?: CustomerDiscountListRelationFilter
    saleDiscounts?: SaleDiscountListRelationFilter
  }, "id" | "name">

  export type DiscountRuleOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    value?: SortOrder
    isPercentage?: SortOrder
    isActive?: SortOrder
    description?: SortOrderInput | SortOrder
    minAmount?: SortOrderInput | SortOrder
    maxDiscount?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DiscountRuleCountOrderByAggregateInput
    _avg?: DiscountRuleAvgOrderByAggregateInput
    _max?: DiscountRuleMaxOrderByAggregateInput
    _min?: DiscountRuleMinOrderByAggregateInput
    _sum?: DiscountRuleSumOrderByAggregateInput
  }

  export type DiscountRuleScalarWhereWithAggregatesInput = {
    AND?: DiscountRuleScalarWhereWithAggregatesInput | DiscountRuleScalarWhereWithAggregatesInput[]
    OR?: DiscountRuleScalarWhereWithAggregatesInput[]
    NOT?: DiscountRuleScalarWhereWithAggregatesInput | DiscountRuleScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DiscountRule"> | string
    name?: StringWithAggregatesFilter<"DiscountRule"> | string
    type?: EnumDiscountTypeWithAggregatesFilter<"DiscountRule"> | $Enums.DiscountType
    value?: DecimalWithAggregatesFilter<"DiscountRule"> | Decimal | DecimalJsLike | number | string
    isPercentage?: BoolWithAggregatesFilter<"DiscountRule"> | boolean
    isActive?: BoolWithAggregatesFilter<"DiscountRule"> | boolean
    description?: StringNullableWithAggregatesFilter<"DiscountRule"> | string | null
    minAmount?: DecimalNullableWithAggregatesFilter<"DiscountRule"> | Decimal | DecimalJsLike | number | string | null
    maxDiscount?: DecimalNullableWithAggregatesFilter<"DiscountRule"> | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeWithAggregatesFilter<"DiscountRule"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"DiscountRule"> | Date | string
  }

  export type SaleDiscountWhereInput = {
    AND?: SaleDiscountWhereInput | SaleDiscountWhereInput[]
    OR?: SaleDiscountWhereInput[]
    NOT?: SaleDiscountWhereInput | SaleDiscountWhereInput[]
    id?: StringFilter<"SaleDiscount"> | string
    saleId?: StringFilter<"SaleDiscount"> | string
    discountRuleId?: StringFilter<"SaleDiscount"> | string
    discountAmount?: DecimalFilter<"SaleDiscount"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"SaleDiscount"> | Date | string
    discountRule?: XOR<DiscountRuleScalarRelationFilter, DiscountRuleWhereInput>
    sale?: XOR<SaleScalarRelationFilter, SaleWhereInput>
  }

  export type SaleDiscountOrderByWithRelationInput = {
    id?: SortOrder
    saleId?: SortOrder
    discountRuleId?: SortOrder
    discountAmount?: SortOrder
    createdAt?: SortOrder
    discountRule?: DiscountRuleOrderByWithRelationInput
    sale?: SaleOrderByWithRelationInput
  }

  export type SaleDiscountWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SaleDiscountWhereInput | SaleDiscountWhereInput[]
    OR?: SaleDiscountWhereInput[]
    NOT?: SaleDiscountWhereInput | SaleDiscountWhereInput[]
    saleId?: StringFilter<"SaleDiscount"> | string
    discountRuleId?: StringFilter<"SaleDiscount"> | string
    discountAmount?: DecimalFilter<"SaleDiscount"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"SaleDiscount"> | Date | string
    discountRule?: XOR<DiscountRuleScalarRelationFilter, DiscountRuleWhereInput>
    sale?: XOR<SaleScalarRelationFilter, SaleWhereInput>
  }, "id">

  export type SaleDiscountOrderByWithAggregationInput = {
    id?: SortOrder
    saleId?: SortOrder
    discountRuleId?: SortOrder
    discountAmount?: SortOrder
    createdAt?: SortOrder
    _count?: SaleDiscountCountOrderByAggregateInput
    _avg?: SaleDiscountAvgOrderByAggregateInput
    _max?: SaleDiscountMaxOrderByAggregateInput
    _min?: SaleDiscountMinOrderByAggregateInput
    _sum?: SaleDiscountSumOrderByAggregateInput
  }

  export type SaleDiscountScalarWhereWithAggregatesInput = {
    AND?: SaleDiscountScalarWhereWithAggregatesInput | SaleDiscountScalarWhereWithAggregatesInput[]
    OR?: SaleDiscountScalarWhereWithAggregatesInput[]
    NOT?: SaleDiscountScalarWhereWithAggregatesInput | SaleDiscountScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SaleDiscount"> | string
    saleId?: StringWithAggregatesFilter<"SaleDiscount"> | string
    discountRuleId?: StringWithAggregatesFilter<"SaleDiscount"> | string
    discountAmount?: DecimalWithAggregatesFilter<"SaleDiscount"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeWithAggregatesFilter<"SaleDiscount"> | Date | string
  }

  export type CustomerDiscountWhereInput = {
    AND?: CustomerDiscountWhereInput | CustomerDiscountWhereInput[]
    OR?: CustomerDiscountWhereInput[]
    NOT?: CustomerDiscountWhereInput | CustomerDiscountWhereInput[]
    id?: StringFilter<"CustomerDiscount"> | string
    customerId?: StringFilter<"CustomerDiscount"> | string
    discountRuleId?: StringFilter<"CustomerDiscount"> | string
    usedAt?: DateTimeFilter<"CustomerDiscount"> | Date | string
    discountAmount?: DecimalFilter<"CustomerDiscount"> | Decimal | DecimalJsLike | number | string
    customer?: XOR<CustomerScalarRelationFilter, CustomerWhereInput>
    discountRule?: XOR<DiscountRuleScalarRelationFilter, DiscountRuleWhereInput>
  }

  export type CustomerDiscountOrderByWithRelationInput = {
    id?: SortOrder
    customerId?: SortOrder
    discountRuleId?: SortOrder
    usedAt?: SortOrder
    discountAmount?: SortOrder
    customer?: CustomerOrderByWithRelationInput
    discountRule?: DiscountRuleOrderByWithRelationInput
  }

  export type CustomerDiscountWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CustomerDiscountWhereInput | CustomerDiscountWhereInput[]
    OR?: CustomerDiscountWhereInput[]
    NOT?: CustomerDiscountWhereInput | CustomerDiscountWhereInput[]
    customerId?: StringFilter<"CustomerDiscount"> | string
    discountRuleId?: StringFilter<"CustomerDiscount"> | string
    usedAt?: DateTimeFilter<"CustomerDiscount"> | Date | string
    discountAmount?: DecimalFilter<"CustomerDiscount"> | Decimal | DecimalJsLike | number | string
    customer?: XOR<CustomerScalarRelationFilter, CustomerWhereInput>
    discountRule?: XOR<DiscountRuleScalarRelationFilter, DiscountRuleWhereInput>
  }, "id">

  export type CustomerDiscountOrderByWithAggregationInput = {
    id?: SortOrder
    customerId?: SortOrder
    discountRuleId?: SortOrder
    usedAt?: SortOrder
    discountAmount?: SortOrder
    _count?: CustomerDiscountCountOrderByAggregateInput
    _avg?: CustomerDiscountAvgOrderByAggregateInput
    _max?: CustomerDiscountMaxOrderByAggregateInput
    _min?: CustomerDiscountMinOrderByAggregateInput
    _sum?: CustomerDiscountSumOrderByAggregateInput
  }

  export type CustomerDiscountScalarWhereWithAggregatesInput = {
    AND?: CustomerDiscountScalarWhereWithAggregatesInput | CustomerDiscountScalarWhereWithAggregatesInput[]
    OR?: CustomerDiscountScalarWhereWithAggregatesInput[]
    NOT?: CustomerDiscountScalarWhereWithAggregatesInput | CustomerDiscountScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CustomerDiscount"> | string
    customerId?: StringWithAggregatesFilter<"CustomerDiscount"> | string
    discountRuleId?: StringWithAggregatesFilter<"CustomerDiscount"> | string
    usedAt?: DateTimeWithAggregatesFilter<"CustomerDiscount"> | Date | string
    discountAmount?: DecimalWithAggregatesFilter<"CustomerDiscount"> | Decimal | DecimalJsLike | number | string
  }

  export type SalePaymentWhereInput = {
    AND?: SalePaymentWhereInput | SalePaymentWhereInput[]
    OR?: SalePaymentWhereInput[]
    NOT?: SalePaymentWhereInput | SalePaymentWhereInput[]
    id?: StringFilter<"SalePayment"> | string
    saleId?: StringFilter<"SalePayment"> | string
    paymentMethod?: EnumPaymentMethodFilter<"SalePayment"> | $Enums.PaymentMethod
    amount?: DecimalFilter<"SalePayment"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"SalePayment"> | Date | string
    sale?: XOR<SaleScalarRelationFilter, SaleWhereInput>
  }

  export type SalePaymentOrderByWithRelationInput = {
    id?: SortOrder
    saleId?: SortOrder
    paymentMethod?: SortOrder
    amount?: SortOrder
    createdAt?: SortOrder
    sale?: SaleOrderByWithRelationInput
  }

  export type SalePaymentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SalePaymentWhereInput | SalePaymentWhereInput[]
    OR?: SalePaymentWhereInput[]
    NOT?: SalePaymentWhereInput | SalePaymentWhereInput[]
    saleId?: StringFilter<"SalePayment"> | string
    paymentMethod?: EnumPaymentMethodFilter<"SalePayment"> | $Enums.PaymentMethod
    amount?: DecimalFilter<"SalePayment"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"SalePayment"> | Date | string
    sale?: XOR<SaleScalarRelationFilter, SaleWhereInput>
  }, "id">

  export type SalePaymentOrderByWithAggregationInput = {
    id?: SortOrder
    saleId?: SortOrder
    paymentMethod?: SortOrder
    amount?: SortOrder
    createdAt?: SortOrder
    _count?: SalePaymentCountOrderByAggregateInput
    _avg?: SalePaymentAvgOrderByAggregateInput
    _max?: SalePaymentMaxOrderByAggregateInput
    _min?: SalePaymentMinOrderByAggregateInput
    _sum?: SalePaymentSumOrderByAggregateInput
  }

  export type SalePaymentScalarWhereWithAggregatesInput = {
    AND?: SalePaymentScalarWhereWithAggregatesInput | SalePaymentScalarWhereWithAggregatesInput[]
    OR?: SalePaymentScalarWhereWithAggregatesInput[]
    NOT?: SalePaymentScalarWhereWithAggregatesInput | SalePaymentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SalePayment"> | string
    saleId?: StringWithAggregatesFilter<"SalePayment"> | string
    paymentMethod?: EnumPaymentMethodWithAggregatesFilter<"SalePayment"> | $Enums.PaymentMethod
    amount?: DecimalWithAggregatesFilter<"SalePayment"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeWithAggregatesFilter<"SalePayment"> | Date | string
  }

  export type ProductWhereInput = {
    AND?: ProductWhereInput | ProductWhereInput[]
    OR?: ProductWhereInput[]
    NOT?: ProductWhereInput | ProductWhereInput[]
    id?: StringFilter<"Product"> | string
    name?: StringFilter<"Product"> | string
    description?: StringNullableFilter<"Product"> | string | null
    price?: DecimalFilter<"Product"> | Decimal | DecimalJsLike | number | string
    quantity?: IntFilter<"Product"> | number
    isActive?: BoolFilter<"Product"> | boolean
    createdAt?: DateTimeFilter<"Product"> | Date | string
    updatedAt?: DateTimeFilter<"Product"> | Date | string
    saleProducts?: SaleProductListRelationFilter
  }

  export type ProductOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    price?: SortOrder
    quantity?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    saleProducts?: SaleProductOrderByRelationAggregateInput
  }

  export type ProductWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: ProductWhereInput | ProductWhereInput[]
    OR?: ProductWhereInput[]
    NOT?: ProductWhereInput | ProductWhereInput[]
    description?: StringNullableFilter<"Product"> | string | null
    price?: DecimalFilter<"Product"> | Decimal | DecimalJsLike | number | string
    quantity?: IntFilter<"Product"> | number
    isActive?: BoolFilter<"Product"> | boolean
    createdAt?: DateTimeFilter<"Product"> | Date | string
    updatedAt?: DateTimeFilter<"Product"> | Date | string
    saleProducts?: SaleProductListRelationFilter
  }, "id" | "name">

  export type ProductOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    price?: SortOrder
    quantity?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ProductCountOrderByAggregateInput
    _avg?: ProductAvgOrderByAggregateInput
    _max?: ProductMaxOrderByAggregateInput
    _min?: ProductMinOrderByAggregateInput
    _sum?: ProductSumOrderByAggregateInput
  }

  export type ProductScalarWhereWithAggregatesInput = {
    AND?: ProductScalarWhereWithAggregatesInput | ProductScalarWhereWithAggregatesInput[]
    OR?: ProductScalarWhereWithAggregatesInput[]
    NOT?: ProductScalarWhereWithAggregatesInput | ProductScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Product"> | string
    name?: StringWithAggregatesFilter<"Product"> | string
    description?: StringNullableWithAggregatesFilter<"Product"> | string | null
    price?: DecimalWithAggregatesFilter<"Product"> | Decimal | DecimalJsLike | number | string
    quantity?: IntWithAggregatesFilter<"Product"> | number
    isActive?: BoolWithAggregatesFilter<"Product"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Product"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Product"> | Date | string
  }

  export type SaleProductWhereInput = {
    AND?: SaleProductWhereInput | SaleProductWhereInput[]
    OR?: SaleProductWhereInput[]
    NOT?: SaleProductWhereInput | SaleProductWhereInput[]
    id?: StringFilter<"SaleProduct"> | string
    saleId?: StringFilter<"SaleProduct"> | string
    productId?: StringFilter<"SaleProduct"> | string
    quantity?: IntFilter<"SaleProduct"> | number
    unitPrice?: DecimalFilter<"SaleProduct"> | Decimal | DecimalJsLike | number | string
    totalPrice?: DecimalFilter<"SaleProduct"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"SaleProduct"> | Date | string
    sale?: XOR<SaleScalarRelationFilter, SaleWhereInput>
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
  }

  export type SaleProductOrderByWithRelationInput = {
    id?: SortOrder
    saleId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    totalPrice?: SortOrder
    createdAt?: SortOrder
    sale?: SaleOrderByWithRelationInput
    product?: ProductOrderByWithRelationInput
  }

  export type SaleProductWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SaleProductWhereInput | SaleProductWhereInput[]
    OR?: SaleProductWhereInput[]
    NOT?: SaleProductWhereInput | SaleProductWhereInput[]
    saleId?: StringFilter<"SaleProduct"> | string
    productId?: StringFilter<"SaleProduct"> | string
    quantity?: IntFilter<"SaleProduct"> | number
    unitPrice?: DecimalFilter<"SaleProduct"> | Decimal | DecimalJsLike | number | string
    totalPrice?: DecimalFilter<"SaleProduct"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"SaleProduct"> | Date | string
    sale?: XOR<SaleScalarRelationFilter, SaleWhereInput>
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
  }, "id">

  export type SaleProductOrderByWithAggregationInput = {
    id?: SortOrder
    saleId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    totalPrice?: SortOrder
    createdAt?: SortOrder
    _count?: SaleProductCountOrderByAggregateInput
    _avg?: SaleProductAvgOrderByAggregateInput
    _max?: SaleProductMaxOrderByAggregateInput
    _min?: SaleProductMinOrderByAggregateInput
    _sum?: SaleProductSumOrderByAggregateInput
  }

  export type SaleProductScalarWhereWithAggregatesInput = {
    AND?: SaleProductScalarWhereWithAggregatesInput | SaleProductScalarWhereWithAggregatesInput[]
    OR?: SaleProductScalarWhereWithAggregatesInput[]
    NOT?: SaleProductScalarWhereWithAggregatesInput | SaleProductScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SaleProduct"> | string
    saleId?: StringWithAggregatesFilter<"SaleProduct"> | string
    productId?: StringWithAggregatesFilter<"SaleProduct"> | string
    quantity?: IntWithAggregatesFilter<"SaleProduct"> | number
    unitPrice?: DecimalWithAggregatesFilter<"SaleProduct"> | Decimal | DecimalJsLike | number | string
    totalPrice?: DecimalWithAggregatesFilter<"SaleProduct"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeWithAggregatesFilter<"SaleProduct"> | Date | string
  }

  export type UserCreateInput = {
    id?: string
    name: string
    email?: string | null
    password: string
    role?: $Enums.Role
    phone: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    profilePicture?: string | null
    staffSales?: SaleStaffCreateNestedManyWithoutStaffInput
    sales?: SaleCreateNestedManyWithoutCreatedByInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    name: string
    email?: string | null
    password: string
    role?: $Enums.Role
    phone: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    profilePicture?: string | null
    staffSales?: SaleStaffUncheckedCreateNestedManyWithoutStaffInput
    sales?: SaleUncheckedCreateNestedManyWithoutCreatedByInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    phone?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    staffSales?: SaleStaffUpdateManyWithoutStaffNestedInput
    sales?: SaleUpdateManyWithoutCreatedByNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    phone?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    staffSales?: SaleStaffUncheckedUpdateManyWithoutStaffNestedInput
    sales?: SaleUncheckedUpdateManyWithoutCreatedByNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    name: string
    email?: string | null
    password: string
    role?: $Enums.Role
    phone: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    profilePicture?: string | null
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    phone?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    phone?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CustomerCreateInput = {
    id?: string
    fullName: string
    gender: $Enums.Gender
    location: string
    district: string
    province: string
    phone?: string | null
    email?: string | null
    birthDay: number
    birthMonth: number
    birthYear?: number | null
    loyaltyPoints?: number
    totalSpent?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    isActive?: boolean
    additionalLocation?: string | null
    isDependent?: boolean
    lastSale?: Date | string | null
    saleCount?: number
    sector?: string | null
    discounts?: CustomerDiscountCreateNestedManyWithoutCustomerInput
    parent?: CustomerCreateNestedOneWithoutDependentsInput
    dependents?: CustomerCreateNestedManyWithoutParentInput
    sales?: SaleCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateInput = {
    id?: string
    fullName: string
    gender: $Enums.Gender
    location: string
    district: string
    province: string
    phone?: string | null
    email?: string | null
    birthDay: number
    birthMonth: number
    birthYear?: number | null
    loyaltyPoints?: number
    totalSpent?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    isActive?: boolean
    additionalLocation?: string | null
    isDependent?: boolean
    lastSale?: Date | string | null
    parentId?: string | null
    saleCount?: number
    sector?: string | null
    discounts?: CustomerDiscountUncheckedCreateNestedManyWithoutCustomerInput
    dependents?: CustomerUncheckedCreateNestedManyWithoutParentInput
    sales?: SaleUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    location?: StringFieldUpdateOperationsInput | string
    district?: StringFieldUpdateOperationsInput | string
    province?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    birthDay?: IntFieldUpdateOperationsInput | number
    birthMonth?: IntFieldUpdateOperationsInput | number
    birthYear?: NullableIntFieldUpdateOperationsInput | number | null
    loyaltyPoints?: IntFieldUpdateOperationsInput | number
    totalSpent?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    additionalLocation?: NullableStringFieldUpdateOperationsInput | string | null
    isDependent?: BoolFieldUpdateOperationsInput | boolean
    lastSale?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    saleCount?: IntFieldUpdateOperationsInput | number
    sector?: NullableStringFieldUpdateOperationsInput | string | null
    discounts?: CustomerDiscountUpdateManyWithoutCustomerNestedInput
    parent?: CustomerUpdateOneWithoutDependentsNestedInput
    dependents?: CustomerUpdateManyWithoutParentNestedInput
    sales?: SaleUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    location?: StringFieldUpdateOperationsInput | string
    district?: StringFieldUpdateOperationsInput | string
    province?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    birthDay?: IntFieldUpdateOperationsInput | number
    birthMonth?: IntFieldUpdateOperationsInput | number
    birthYear?: NullableIntFieldUpdateOperationsInput | number | null
    loyaltyPoints?: IntFieldUpdateOperationsInput | number
    totalSpent?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    additionalLocation?: NullableStringFieldUpdateOperationsInput | string | null
    isDependent?: BoolFieldUpdateOperationsInput | boolean
    lastSale?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    saleCount?: IntFieldUpdateOperationsInput | number
    sector?: NullableStringFieldUpdateOperationsInput | string | null
    discounts?: CustomerDiscountUncheckedUpdateManyWithoutCustomerNestedInput
    dependents?: CustomerUncheckedUpdateManyWithoutParentNestedInput
    sales?: SaleUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerCreateManyInput = {
    id?: string
    fullName: string
    gender: $Enums.Gender
    location: string
    district: string
    province: string
    phone?: string | null
    email?: string | null
    birthDay: number
    birthMonth: number
    birthYear?: number | null
    loyaltyPoints?: number
    totalSpent?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    isActive?: boolean
    additionalLocation?: string | null
    isDependent?: boolean
    lastSale?: Date | string | null
    parentId?: string | null
    saleCount?: number
    sector?: string | null
  }

  export type CustomerUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    location?: StringFieldUpdateOperationsInput | string
    district?: StringFieldUpdateOperationsInput | string
    province?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    birthDay?: IntFieldUpdateOperationsInput | number
    birthMonth?: IntFieldUpdateOperationsInput | number
    birthYear?: NullableIntFieldUpdateOperationsInput | number | null
    loyaltyPoints?: IntFieldUpdateOperationsInput | number
    totalSpent?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    additionalLocation?: NullableStringFieldUpdateOperationsInput | string | null
    isDependent?: BoolFieldUpdateOperationsInput | boolean
    lastSale?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    saleCount?: IntFieldUpdateOperationsInput | number
    sector?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CustomerUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    location?: StringFieldUpdateOperationsInput | string
    district?: StringFieldUpdateOperationsInput | string
    province?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    birthDay?: IntFieldUpdateOperationsInput | number
    birthMonth?: IntFieldUpdateOperationsInput | number
    birthYear?: NullableIntFieldUpdateOperationsInput | number | null
    loyaltyPoints?: IntFieldUpdateOperationsInput | number
    totalSpent?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    additionalLocation?: NullableStringFieldUpdateOperationsInput | string | null
    isDependent?: BoolFieldUpdateOperationsInput | boolean
    lastSale?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    saleCount?: IntFieldUpdateOperationsInput | number
    sector?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ServiceCreateInput = {
    id?: string
    name: string
    category: $Enums.ServiceCategory
    description?: string | null
    singlePrice: Decimal | DecimalJsLike | number | string
    combinedPrice?: Decimal | DecimalJsLike | number | string | null
    childPrice?: Decimal | DecimalJsLike | number | string | null
    childCombinedPrice?: Decimal | DecimalJsLike | number | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    saleServices?: SaleServiceCreateNestedManyWithoutServiceInput
  }

  export type ServiceUncheckedCreateInput = {
    id?: string
    name: string
    category: $Enums.ServiceCategory
    description?: string | null
    singlePrice: Decimal | DecimalJsLike | number | string
    combinedPrice?: Decimal | DecimalJsLike | number | string | null
    childPrice?: Decimal | DecimalJsLike | number | string | null
    childCombinedPrice?: Decimal | DecimalJsLike | number | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    saleServices?: SaleServiceUncheckedCreateNestedManyWithoutServiceInput
  }

  export type ServiceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: EnumServiceCategoryFieldUpdateOperationsInput | $Enums.ServiceCategory
    description?: NullableStringFieldUpdateOperationsInput | string | null
    singlePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    combinedPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    childPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    childCombinedPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    saleServices?: SaleServiceUpdateManyWithoutServiceNestedInput
  }

  export type ServiceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: EnumServiceCategoryFieldUpdateOperationsInput | $Enums.ServiceCategory
    description?: NullableStringFieldUpdateOperationsInput | string | null
    singlePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    combinedPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    childPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    childCombinedPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    saleServices?: SaleServiceUncheckedUpdateManyWithoutServiceNestedInput
  }

  export type ServiceCreateManyInput = {
    id?: string
    name: string
    category: $Enums.ServiceCategory
    description?: string | null
    singlePrice: Decimal | DecimalJsLike | number | string
    combinedPrice?: Decimal | DecimalJsLike | number | string | null
    childPrice?: Decimal | DecimalJsLike | number | string | null
    childCombinedPrice?: Decimal | DecimalJsLike | number | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ServiceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: EnumServiceCategoryFieldUpdateOperationsInput | $Enums.ServiceCategory
    description?: NullableStringFieldUpdateOperationsInput | string | null
    singlePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    combinedPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    childPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    childCombinedPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: EnumServiceCategoryFieldUpdateOperationsInput | $Enums.ServiceCategory
    description?: NullableStringFieldUpdateOperationsInput | string | null
    singlePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    combinedPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    childPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    childCombinedPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SaleCreateInput = {
    id?: string
    saleDate?: Date | string
    totalAmount: Decimal | DecimalJsLike | number | string
    discountAmount?: Decimal | DecimalJsLike | number | string
    finalAmount: Decimal | DecimalJsLike | number | string
    loyaltyPointsEarned?: number
    notes?: string | null
    isCompleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    birthMonthDiscount?: boolean
    ownShampooDiscount?: boolean
    paymentMethod?: $Enums.PaymentMethod
    discounts?: SaleDiscountCreateNestedManyWithoutSaleInput
    services?: SaleServiceCreateNestedManyWithoutSaleInput
    products?: SaleProductCreateNestedManyWithoutSaleInput
    staff?: SaleStaffCreateNestedManyWithoutSaleInput
    payments?: SalePaymentCreateNestedManyWithoutSaleInput
    createdBy: UserCreateNestedOneWithoutSalesInput
    customer: CustomerCreateNestedOneWithoutSalesInput
  }

  export type SaleUncheckedCreateInput = {
    id?: string
    customerId: string
    saleDate?: Date | string
    totalAmount: Decimal | DecimalJsLike | number | string
    discountAmount?: Decimal | DecimalJsLike | number | string
    finalAmount: Decimal | DecimalJsLike | number | string
    loyaltyPointsEarned?: number
    notes?: string | null
    isCompleted?: boolean
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
    birthMonthDiscount?: boolean
    ownShampooDiscount?: boolean
    paymentMethod?: $Enums.PaymentMethod
    discounts?: SaleDiscountUncheckedCreateNestedManyWithoutSaleInput
    services?: SaleServiceUncheckedCreateNestedManyWithoutSaleInput
    products?: SaleProductUncheckedCreateNestedManyWithoutSaleInput
    staff?: SaleStaffUncheckedCreateNestedManyWithoutSaleInput
    payments?: SalePaymentUncheckedCreateNestedManyWithoutSaleInput
  }

  export type SaleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    saleDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    finalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    loyaltyPointsEarned?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    birthMonthDiscount?: BoolFieldUpdateOperationsInput | boolean
    ownShampooDiscount?: BoolFieldUpdateOperationsInput | boolean
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    discounts?: SaleDiscountUpdateManyWithoutSaleNestedInput
    services?: SaleServiceUpdateManyWithoutSaleNestedInput
    products?: SaleProductUpdateManyWithoutSaleNestedInput
    staff?: SaleStaffUpdateManyWithoutSaleNestedInput
    payments?: SalePaymentUpdateManyWithoutSaleNestedInput
    createdBy?: UserUpdateOneRequiredWithoutSalesNestedInput
    customer?: CustomerUpdateOneRequiredWithoutSalesNestedInput
  }

  export type SaleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    saleDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    finalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    loyaltyPointsEarned?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    birthMonthDiscount?: BoolFieldUpdateOperationsInput | boolean
    ownShampooDiscount?: BoolFieldUpdateOperationsInput | boolean
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    discounts?: SaleDiscountUncheckedUpdateManyWithoutSaleNestedInput
    services?: SaleServiceUncheckedUpdateManyWithoutSaleNestedInput
    products?: SaleProductUncheckedUpdateManyWithoutSaleNestedInput
    staff?: SaleStaffUncheckedUpdateManyWithoutSaleNestedInput
    payments?: SalePaymentUncheckedUpdateManyWithoutSaleNestedInput
  }

  export type SaleCreateManyInput = {
    id?: string
    customerId: string
    saleDate?: Date | string
    totalAmount: Decimal | DecimalJsLike | number | string
    discountAmount?: Decimal | DecimalJsLike | number | string
    finalAmount: Decimal | DecimalJsLike | number | string
    loyaltyPointsEarned?: number
    notes?: string | null
    isCompleted?: boolean
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
    birthMonthDiscount?: boolean
    ownShampooDiscount?: boolean
    paymentMethod?: $Enums.PaymentMethod
  }

  export type SaleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    saleDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    finalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    loyaltyPointsEarned?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    birthMonthDiscount?: BoolFieldUpdateOperationsInput | boolean
    ownShampooDiscount?: BoolFieldUpdateOperationsInput | boolean
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
  }

  export type SaleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    saleDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    finalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    loyaltyPointsEarned?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    birthMonthDiscount?: BoolFieldUpdateOperationsInput | boolean
    ownShampooDiscount?: BoolFieldUpdateOperationsInput | boolean
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
  }

  export type SaleServiceCreateInput = {
    id?: string
    quantity?: number
    unitPrice: Decimal | DecimalJsLike | number | string
    totalPrice: Decimal | DecimalJsLike | number | string
    isChild?: boolean
    isCombined?: boolean
    addShampoo?: boolean
    createdAt?: Date | string
    sale: SaleCreateNestedOneWithoutServicesInput
    service: ServiceCreateNestedOneWithoutSaleServicesInput
  }

  export type SaleServiceUncheckedCreateInput = {
    id?: string
    saleId: string
    serviceId: string
    quantity?: number
    unitPrice: Decimal | DecimalJsLike | number | string
    totalPrice: Decimal | DecimalJsLike | number | string
    isChild?: boolean
    isCombined?: boolean
    addShampoo?: boolean
    createdAt?: Date | string
  }

  export type SaleServiceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isChild?: BoolFieldUpdateOperationsInput | boolean
    isCombined?: BoolFieldUpdateOperationsInput | boolean
    addShampoo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sale?: SaleUpdateOneRequiredWithoutServicesNestedInput
    service?: ServiceUpdateOneRequiredWithoutSaleServicesNestedInput
  }

  export type SaleServiceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    saleId?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isChild?: BoolFieldUpdateOperationsInput | boolean
    isCombined?: BoolFieldUpdateOperationsInput | boolean
    addShampoo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SaleServiceCreateManyInput = {
    id?: string
    saleId: string
    serviceId: string
    quantity?: number
    unitPrice: Decimal | DecimalJsLike | number | string
    totalPrice: Decimal | DecimalJsLike | number | string
    isChild?: boolean
    isCombined?: boolean
    addShampoo?: boolean
    createdAt?: Date | string
  }

  export type SaleServiceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isChild?: BoolFieldUpdateOperationsInput | boolean
    isCombined?: BoolFieldUpdateOperationsInput | boolean
    addShampoo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SaleServiceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    saleId?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isChild?: BoolFieldUpdateOperationsInput | boolean
    isCombined?: BoolFieldUpdateOperationsInput | boolean
    addShampoo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SaleStaffCreateInput = {
    id?: string
    customName?: string | null
    serviceId?: string | null
    createdAt?: Date | string
    sale: SaleCreateNestedOneWithoutStaffInput
    staff?: UserCreateNestedOneWithoutStaffSalesInput
  }

  export type SaleStaffUncheckedCreateInput = {
    id?: string
    saleId: string
    staffId?: string | null
    customName?: string | null
    serviceId?: string | null
    createdAt?: Date | string
  }

  export type SaleStaffUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    customName?: NullableStringFieldUpdateOperationsInput | string | null
    serviceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sale?: SaleUpdateOneRequiredWithoutStaffNestedInput
    staff?: UserUpdateOneWithoutStaffSalesNestedInput
  }

  export type SaleStaffUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    saleId?: StringFieldUpdateOperationsInput | string
    staffId?: NullableStringFieldUpdateOperationsInput | string | null
    customName?: NullableStringFieldUpdateOperationsInput | string | null
    serviceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SaleStaffCreateManyInput = {
    id?: string
    saleId: string
    staffId?: string | null
    customName?: string | null
    serviceId?: string | null
    createdAt?: Date | string
  }

  export type SaleStaffUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    customName?: NullableStringFieldUpdateOperationsInput | string | null
    serviceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SaleStaffUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    saleId?: StringFieldUpdateOperationsInput | string
    staffId?: NullableStringFieldUpdateOperationsInput | string | null
    customName?: NullableStringFieldUpdateOperationsInput | string | null
    serviceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DiscountRuleCreateInput = {
    id?: string
    name: string
    type: $Enums.DiscountType
    value: Decimal | DecimalJsLike | number | string
    isPercentage?: boolean
    isActive?: boolean
    description?: string | null
    minAmount?: Decimal | DecimalJsLike | number | string | null
    maxDiscount?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    customerDiscounts?: CustomerDiscountCreateNestedManyWithoutDiscountRuleInput
    saleDiscounts?: SaleDiscountCreateNestedManyWithoutDiscountRuleInput
  }

  export type DiscountRuleUncheckedCreateInput = {
    id?: string
    name: string
    type: $Enums.DiscountType
    value: Decimal | DecimalJsLike | number | string
    isPercentage?: boolean
    isActive?: boolean
    description?: string | null
    minAmount?: Decimal | DecimalJsLike | number | string | null
    maxDiscount?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    customerDiscounts?: CustomerDiscountUncheckedCreateNestedManyWithoutDiscountRuleInput
    saleDiscounts?: SaleDiscountUncheckedCreateNestedManyWithoutDiscountRuleInput
  }

  export type DiscountRuleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumDiscountTypeFieldUpdateOperationsInput | $Enums.DiscountType
    value?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isPercentage?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    minAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    maxDiscount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customerDiscounts?: CustomerDiscountUpdateManyWithoutDiscountRuleNestedInput
    saleDiscounts?: SaleDiscountUpdateManyWithoutDiscountRuleNestedInput
  }

  export type DiscountRuleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumDiscountTypeFieldUpdateOperationsInput | $Enums.DiscountType
    value?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isPercentage?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    minAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    maxDiscount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customerDiscounts?: CustomerDiscountUncheckedUpdateManyWithoutDiscountRuleNestedInput
    saleDiscounts?: SaleDiscountUncheckedUpdateManyWithoutDiscountRuleNestedInput
  }

  export type DiscountRuleCreateManyInput = {
    id?: string
    name: string
    type: $Enums.DiscountType
    value: Decimal | DecimalJsLike | number | string
    isPercentage?: boolean
    isActive?: boolean
    description?: string | null
    minAmount?: Decimal | DecimalJsLike | number | string | null
    maxDiscount?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DiscountRuleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumDiscountTypeFieldUpdateOperationsInput | $Enums.DiscountType
    value?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isPercentage?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    minAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    maxDiscount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DiscountRuleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumDiscountTypeFieldUpdateOperationsInput | $Enums.DiscountType
    value?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isPercentage?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    minAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    maxDiscount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SaleDiscountCreateInput = {
    id?: string
    discountAmount: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    discountRule: DiscountRuleCreateNestedOneWithoutSaleDiscountsInput
    sale: SaleCreateNestedOneWithoutDiscountsInput
  }

  export type SaleDiscountUncheckedCreateInput = {
    id?: string
    saleId: string
    discountRuleId: string
    discountAmount: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
  }

  export type SaleDiscountUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    discountRule?: DiscountRuleUpdateOneRequiredWithoutSaleDiscountsNestedInput
    sale?: SaleUpdateOneRequiredWithoutDiscountsNestedInput
  }

  export type SaleDiscountUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    saleId?: StringFieldUpdateOperationsInput | string
    discountRuleId?: StringFieldUpdateOperationsInput | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SaleDiscountCreateManyInput = {
    id?: string
    saleId: string
    discountRuleId: string
    discountAmount: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
  }

  export type SaleDiscountUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SaleDiscountUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    saleId?: StringFieldUpdateOperationsInput | string
    discountRuleId?: StringFieldUpdateOperationsInput | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerDiscountCreateInput = {
    id?: string
    usedAt?: Date | string
    discountAmount: Decimal | DecimalJsLike | number | string
    customer: CustomerCreateNestedOneWithoutDiscountsInput
    discountRule: DiscountRuleCreateNestedOneWithoutCustomerDiscountsInput
  }

  export type CustomerDiscountUncheckedCreateInput = {
    id?: string
    customerId: string
    discountRuleId: string
    usedAt?: Date | string
    discountAmount: Decimal | DecimalJsLike | number | string
  }

  export type CustomerDiscountUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    usedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    customer?: CustomerUpdateOneRequiredWithoutDiscountsNestedInput
    discountRule?: DiscountRuleUpdateOneRequiredWithoutCustomerDiscountsNestedInput
  }

  export type CustomerDiscountUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    discountRuleId?: StringFieldUpdateOperationsInput | string
    usedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type CustomerDiscountCreateManyInput = {
    id?: string
    customerId: string
    discountRuleId: string
    usedAt?: Date | string
    discountAmount: Decimal | DecimalJsLike | number | string
  }

  export type CustomerDiscountUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    usedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type CustomerDiscountUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    discountRuleId?: StringFieldUpdateOperationsInput | string
    usedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type SalePaymentCreateInput = {
    id?: string
    paymentMethod: $Enums.PaymentMethod
    amount: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    sale: SaleCreateNestedOneWithoutPaymentsInput
  }

  export type SalePaymentUncheckedCreateInput = {
    id?: string
    saleId: string
    paymentMethod: $Enums.PaymentMethod
    amount: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
  }

  export type SalePaymentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sale?: SaleUpdateOneRequiredWithoutPaymentsNestedInput
  }

  export type SalePaymentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    saleId?: StringFieldUpdateOperationsInput | string
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SalePaymentCreateManyInput = {
    id?: string
    saleId: string
    paymentMethod: $Enums.PaymentMethod
    amount: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
  }

  export type SalePaymentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SalePaymentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    saleId?: StringFieldUpdateOperationsInput | string
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductCreateInput = {
    id?: string
    name: string
    description?: string | null
    price: Decimal | DecimalJsLike | number | string
    quantity?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    saleProducts?: SaleProductCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    price: Decimal | DecimalJsLike | number | string
    quantity?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    saleProducts?: SaleProductUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    quantity?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    saleProducts?: SaleProductUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    quantity?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    saleProducts?: SaleProductUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    price: Decimal | DecimalJsLike | number | string
    quantity?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    quantity?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    quantity?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SaleProductCreateInput = {
    id?: string
    quantity?: number
    unitPrice: Decimal | DecimalJsLike | number | string
    totalPrice: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    sale: SaleCreateNestedOneWithoutProductsInput
    product: ProductCreateNestedOneWithoutSaleProductsInput
  }

  export type SaleProductUncheckedCreateInput = {
    id?: string
    saleId: string
    productId: string
    quantity?: number
    unitPrice: Decimal | DecimalJsLike | number | string
    totalPrice: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
  }

  export type SaleProductUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sale?: SaleUpdateOneRequiredWithoutProductsNestedInput
    product?: ProductUpdateOneRequiredWithoutSaleProductsNestedInput
  }

  export type SaleProductUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    saleId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SaleProductCreateManyInput = {
    id?: string
    saleId: string
    productId: string
    quantity?: number
    unitPrice: Decimal | DecimalJsLike | number | string
    totalPrice: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
  }

  export type SaleProductUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SaleProductUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    saleId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type EnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type SaleStaffListRelationFilter = {
    every?: SaleStaffWhereInput
    some?: SaleStaffWhereInput
    none?: SaleStaffWhereInput
  }

  export type SaleListRelationFilter = {
    every?: SaleWhereInput
    some?: SaleWhereInput
    none?: SaleWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type SaleStaffOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SaleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
    phone?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    profilePicture?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
    phone?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    profilePicture?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
    phone?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    profilePicture?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type EnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleFilter<$PrismaModel>
    _max?: NestedEnumRoleFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type EnumGenderFilter<$PrismaModel = never> = {
    equals?: $Enums.Gender | EnumGenderFieldRefInput<$PrismaModel>
    in?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel>
    notIn?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel>
    not?: NestedEnumGenderFilter<$PrismaModel> | $Enums.Gender
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type CustomerDiscountListRelationFilter = {
    every?: CustomerDiscountWhereInput
    some?: CustomerDiscountWhereInput
    none?: CustomerDiscountWhereInput
  }

  export type CustomerNullableScalarRelationFilter = {
    is?: CustomerWhereInput | null
    isNot?: CustomerWhereInput | null
  }

  export type CustomerListRelationFilter = {
    every?: CustomerWhereInput
    some?: CustomerWhereInput
    none?: CustomerWhereInput
  }

  export type CustomerDiscountOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CustomerOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CustomerCountOrderByAggregateInput = {
    id?: SortOrder
    fullName?: SortOrder
    gender?: SortOrder
    location?: SortOrder
    district?: SortOrder
    province?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    birthDay?: SortOrder
    birthMonth?: SortOrder
    birthYear?: SortOrder
    loyaltyPoints?: SortOrder
    totalSpent?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isActive?: SortOrder
    additionalLocation?: SortOrder
    isDependent?: SortOrder
    lastSale?: SortOrder
    parentId?: SortOrder
    saleCount?: SortOrder
    sector?: SortOrder
  }

  export type CustomerAvgOrderByAggregateInput = {
    birthDay?: SortOrder
    birthMonth?: SortOrder
    birthYear?: SortOrder
    loyaltyPoints?: SortOrder
    totalSpent?: SortOrder
    saleCount?: SortOrder
  }

  export type CustomerMaxOrderByAggregateInput = {
    id?: SortOrder
    fullName?: SortOrder
    gender?: SortOrder
    location?: SortOrder
    district?: SortOrder
    province?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    birthDay?: SortOrder
    birthMonth?: SortOrder
    birthYear?: SortOrder
    loyaltyPoints?: SortOrder
    totalSpent?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isActive?: SortOrder
    additionalLocation?: SortOrder
    isDependent?: SortOrder
    lastSale?: SortOrder
    parentId?: SortOrder
    saleCount?: SortOrder
    sector?: SortOrder
  }

  export type CustomerMinOrderByAggregateInput = {
    id?: SortOrder
    fullName?: SortOrder
    gender?: SortOrder
    location?: SortOrder
    district?: SortOrder
    province?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    birthDay?: SortOrder
    birthMonth?: SortOrder
    birthYear?: SortOrder
    loyaltyPoints?: SortOrder
    totalSpent?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isActive?: SortOrder
    additionalLocation?: SortOrder
    isDependent?: SortOrder
    lastSale?: SortOrder
    parentId?: SortOrder
    saleCount?: SortOrder
    sector?: SortOrder
  }

  export type CustomerSumOrderByAggregateInput = {
    birthDay?: SortOrder
    birthMonth?: SortOrder
    birthYear?: SortOrder
    loyaltyPoints?: SortOrder
    totalSpent?: SortOrder
    saleCount?: SortOrder
  }

  export type EnumGenderWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Gender | EnumGenderFieldRefInput<$PrismaModel>
    in?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel>
    notIn?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel>
    not?: NestedEnumGenderWithAggregatesFilter<$PrismaModel> | $Enums.Gender
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumGenderFilter<$PrismaModel>
    _max?: NestedEnumGenderFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type EnumServiceCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.ServiceCategory | EnumServiceCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.ServiceCategory[] | ListEnumServiceCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.ServiceCategory[] | ListEnumServiceCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumServiceCategoryFilter<$PrismaModel> | $Enums.ServiceCategory
  }

  export type DecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type SaleServiceListRelationFilter = {
    every?: SaleServiceWhereInput
    some?: SaleServiceWhereInput
    none?: SaleServiceWhereInput
  }

  export type SaleServiceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ServiceCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    category?: SortOrder
    description?: SortOrder
    singlePrice?: SortOrder
    combinedPrice?: SortOrder
    childPrice?: SortOrder
    childCombinedPrice?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ServiceAvgOrderByAggregateInput = {
    singlePrice?: SortOrder
    combinedPrice?: SortOrder
    childPrice?: SortOrder
    childCombinedPrice?: SortOrder
  }

  export type ServiceMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    category?: SortOrder
    description?: SortOrder
    singlePrice?: SortOrder
    combinedPrice?: SortOrder
    childPrice?: SortOrder
    childCombinedPrice?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ServiceMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    category?: SortOrder
    description?: SortOrder
    singlePrice?: SortOrder
    combinedPrice?: SortOrder
    childPrice?: SortOrder
    childCombinedPrice?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ServiceSumOrderByAggregateInput = {
    singlePrice?: SortOrder
    combinedPrice?: SortOrder
    childPrice?: SortOrder
    childCombinedPrice?: SortOrder
  }

  export type EnumServiceCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ServiceCategory | EnumServiceCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.ServiceCategory[] | ListEnumServiceCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.ServiceCategory[] | ListEnumServiceCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumServiceCategoryWithAggregatesFilter<$PrismaModel> | $Enums.ServiceCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumServiceCategoryFilter<$PrismaModel>
    _max?: NestedEnumServiceCategoryFilter<$PrismaModel>
  }

  export type DecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type EnumPaymentMethodFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentMethodFilter<$PrismaModel> | $Enums.PaymentMethod
  }

  export type SaleDiscountListRelationFilter = {
    every?: SaleDiscountWhereInput
    some?: SaleDiscountWhereInput
    none?: SaleDiscountWhereInput
  }

  export type SaleProductListRelationFilter = {
    every?: SaleProductWhereInput
    some?: SaleProductWhereInput
    none?: SaleProductWhereInput
  }

  export type SalePaymentListRelationFilter = {
    every?: SalePaymentWhereInput
    some?: SalePaymentWhereInput
    none?: SalePaymentWhereInput
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type CustomerScalarRelationFilter = {
    is?: CustomerWhereInput
    isNot?: CustomerWhereInput
  }

  export type SaleDiscountOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SaleProductOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SalePaymentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SaleCountOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    saleDate?: SortOrder
    totalAmount?: SortOrder
    discountAmount?: SortOrder
    finalAmount?: SortOrder
    loyaltyPointsEarned?: SortOrder
    notes?: SortOrder
    isCompleted?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    birthMonthDiscount?: SortOrder
    ownShampooDiscount?: SortOrder
    paymentMethod?: SortOrder
  }

  export type SaleAvgOrderByAggregateInput = {
    totalAmount?: SortOrder
    discountAmount?: SortOrder
    finalAmount?: SortOrder
    loyaltyPointsEarned?: SortOrder
  }

  export type SaleMaxOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    saleDate?: SortOrder
    totalAmount?: SortOrder
    discountAmount?: SortOrder
    finalAmount?: SortOrder
    loyaltyPointsEarned?: SortOrder
    notes?: SortOrder
    isCompleted?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    birthMonthDiscount?: SortOrder
    ownShampooDiscount?: SortOrder
    paymentMethod?: SortOrder
  }

  export type SaleMinOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    saleDate?: SortOrder
    totalAmount?: SortOrder
    discountAmount?: SortOrder
    finalAmount?: SortOrder
    loyaltyPointsEarned?: SortOrder
    notes?: SortOrder
    isCompleted?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    birthMonthDiscount?: SortOrder
    ownShampooDiscount?: SortOrder
    paymentMethod?: SortOrder
  }

  export type SaleSumOrderByAggregateInput = {
    totalAmount?: SortOrder
    discountAmount?: SortOrder
    finalAmount?: SortOrder
    loyaltyPointsEarned?: SortOrder
  }

  export type EnumPaymentMethodWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentMethodWithAggregatesFilter<$PrismaModel> | $Enums.PaymentMethod
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentMethodFilter<$PrismaModel>
    _max?: NestedEnumPaymentMethodFilter<$PrismaModel>
  }

  export type SaleScalarRelationFilter = {
    is?: SaleWhereInput
    isNot?: SaleWhereInput
  }

  export type ServiceScalarRelationFilter = {
    is?: ServiceWhereInput
    isNot?: ServiceWhereInput
  }

  export type SaleServiceCountOrderByAggregateInput = {
    id?: SortOrder
    saleId?: SortOrder
    serviceId?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    totalPrice?: SortOrder
    isChild?: SortOrder
    isCombined?: SortOrder
    addShampoo?: SortOrder
    createdAt?: SortOrder
  }

  export type SaleServiceAvgOrderByAggregateInput = {
    quantity?: SortOrder
    unitPrice?: SortOrder
    totalPrice?: SortOrder
  }

  export type SaleServiceMaxOrderByAggregateInput = {
    id?: SortOrder
    saleId?: SortOrder
    serviceId?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    totalPrice?: SortOrder
    isChild?: SortOrder
    isCombined?: SortOrder
    addShampoo?: SortOrder
    createdAt?: SortOrder
  }

  export type SaleServiceMinOrderByAggregateInput = {
    id?: SortOrder
    saleId?: SortOrder
    serviceId?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    totalPrice?: SortOrder
    isChild?: SortOrder
    isCombined?: SortOrder
    addShampoo?: SortOrder
    createdAt?: SortOrder
  }

  export type SaleServiceSumOrderByAggregateInput = {
    quantity?: SortOrder
    unitPrice?: SortOrder
    totalPrice?: SortOrder
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type SaleStaffCountOrderByAggregateInput = {
    id?: SortOrder
    saleId?: SortOrder
    staffId?: SortOrder
    customName?: SortOrder
    serviceId?: SortOrder
    createdAt?: SortOrder
  }

  export type SaleStaffMaxOrderByAggregateInput = {
    id?: SortOrder
    saleId?: SortOrder
    staffId?: SortOrder
    customName?: SortOrder
    serviceId?: SortOrder
    createdAt?: SortOrder
  }

  export type SaleStaffMinOrderByAggregateInput = {
    id?: SortOrder
    saleId?: SortOrder
    staffId?: SortOrder
    customName?: SortOrder
    serviceId?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumDiscountTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.DiscountType | EnumDiscountTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DiscountType[] | ListEnumDiscountTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DiscountType[] | ListEnumDiscountTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDiscountTypeFilter<$PrismaModel> | $Enums.DiscountType
  }

  export type DiscountRuleCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    value?: SortOrder
    isPercentage?: SortOrder
    isActive?: SortOrder
    description?: SortOrder
    minAmount?: SortOrder
    maxDiscount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DiscountRuleAvgOrderByAggregateInput = {
    value?: SortOrder
    minAmount?: SortOrder
    maxDiscount?: SortOrder
  }

  export type DiscountRuleMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    value?: SortOrder
    isPercentage?: SortOrder
    isActive?: SortOrder
    description?: SortOrder
    minAmount?: SortOrder
    maxDiscount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DiscountRuleMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    value?: SortOrder
    isPercentage?: SortOrder
    isActive?: SortOrder
    description?: SortOrder
    minAmount?: SortOrder
    maxDiscount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DiscountRuleSumOrderByAggregateInput = {
    value?: SortOrder
    minAmount?: SortOrder
    maxDiscount?: SortOrder
  }

  export type EnumDiscountTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DiscountType | EnumDiscountTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DiscountType[] | ListEnumDiscountTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DiscountType[] | ListEnumDiscountTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDiscountTypeWithAggregatesFilter<$PrismaModel> | $Enums.DiscountType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDiscountTypeFilter<$PrismaModel>
    _max?: NestedEnumDiscountTypeFilter<$PrismaModel>
  }

  export type DiscountRuleScalarRelationFilter = {
    is?: DiscountRuleWhereInput
    isNot?: DiscountRuleWhereInput
  }

  export type SaleDiscountCountOrderByAggregateInput = {
    id?: SortOrder
    saleId?: SortOrder
    discountRuleId?: SortOrder
    discountAmount?: SortOrder
    createdAt?: SortOrder
  }

  export type SaleDiscountAvgOrderByAggregateInput = {
    discountAmount?: SortOrder
  }

  export type SaleDiscountMaxOrderByAggregateInput = {
    id?: SortOrder
    saleId?: SortOrder
    discountRuleId?: SortOrder
    discountAmount?: SortOrder
    createdAt?: SortOrder
  }

  export type SaleDiscountMinOrderByAggregateInput = {
    id?: SortOrder
    saleId?: SortOrder
    discountRuleId?: SortOrder
    discountAmount?: SortOrder
    createdAt?: SortOrder
  }

  export type SaleDiscountSumOrderByAggregateInput = {
    discountAmount?: SortOrder
  }

  export type CustomerDiscountCountOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    discountRuleId?: SortOrder
    usedAt?: SortOrder
    discountAmount?: SortOrder
  }

  export type CustomerDiscountAvgOrderByAggregateInput = {
    discountAmount?: SortOrder
  }

  export type CustomerDiscountMaxOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    discountRuleId?: SortOrder
    usedAt?: SortOrder
    discountAmount?: SortOrder
  }

  export type CustomerDiscountMinOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    discountRuleId?: SortOrder
    usedAt?: SortOrder
    discountAmount?: SortOrder
  }

  export type CustomerDiscountSumOrderByAggregateInput = {
    discountAmount?: SortOrder
  }

  export type SalePaymentCountOrderByAggregateInput = {
    id?: SortOrder
    saleId?: SortOrder
    paymentMethod?: SortOrder
    amount?: SortOrder
    createdAt?: SortOrder
  }

  export type SalePaymentAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type SalePaymentMaxOrderByAggregateInput = {
    id?: SortOrder
    saleId?: SortOrder
    paymentMethod?: SortOrder
    amount?: SortOrder
    createdAt?: SortOrder
  }

  export type SalePaymentMinOrderByAggregateInput = {
    id?: SortOrder
    saleId?: SortOrder
    paymentMethod?: SortOrder
    amount?: SortOrder
    createdAt?: SortOrder
  }

  export type SalePaymentSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type ProductCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    price?: SortOrder
    quantity?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductAvgOrderByAggregateInput = {
    price?: SortOrder
    quantity?: SortOrder
  }

  export type ProductMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    price?: SortOrder
    quantity?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    price?: SortOrder
    quantity?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductSumOrderByAggregateInput = {
    price?: SortOrder
    quantity?: SortOrder
  }

  export type ProductScalarRelationFilter = {
    is?: ProductWhereInput
    isNot?: ProductWhereInput
  }

  export type SaleProductCountOrderByAggregateInput = {
    id?: SortOrder
    saleId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    totalPrice?: SortOrder
    createdAt?: SortOrder
  }

  export type SaleProductAvgOrderByAggregateInput = {
    quantity?: SortOrder
    unitPrice?: SortOrder
    totalPrice?: SortOrder
  }

  export type SaleProductMaxOrderByAggregateInput = {
    id?: SortOrder
    saleId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    totalPrice?: SortOrder
    createdAt?: SortOrder
  }

  export type SaleProductMinOrderByAggregateInput = {
    id?: SortOrder
    saleId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    totalPrice?: SortOrder
    createdAt?: SortOrder
  }

  export type SaleProductSumOrderByAggregateInput = {
    quantity?: SortOrder
    unitPrice?: SortOrder
    totalPrice?: SortOrder
  }

  export type SaleStaffCreateNestedManyWithoutStaffInput = {
    create?: XOR<SaleStaffCreateWithoutStaffInput, SaleStaffUncheckedCreateWithoutStaffInput> | SaleStaffCreateWithoutStaffInput[] | SaleStaffUncheckedCreateWithoutStaffInput[]
    connectOrCreate?: SaleStaffCreateOrConnectWithoutStaffInput | SaleStaffCreateOrConnectWithoutStaffInput[]
    createMany?: SaleStaffCreateManyStaffInputEnvelope
    connect?: SaleStaffWhereUniqueInput | SaleStaffWhereUniqueInput[]
  }

  export type SaleCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<SaleCreateWithoutCreatedByInput, SaleUncheckedCreateWithoutCreatedByInput> | SaleCreateWithoutCreatedByInput[] | SaleUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: SaleCreateOrConnectWithoutCreatedByInput | SaleCreateOrConnectWithoutCreatedByInput[]
    createMany?: SaleCreateManyCreatedByInputEnvelope
    connect?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
  }

  export type SaleStaffUncheckedCreateNestedManyWithoutStaffInput = {
    create?: XOR<SaleStaffCreateWithoutStaffInput, SaleStaffUncheckedCreateWithoutStaffInput> | SaleStaffCreateWithoutStaffInput[] | SaleStaffUncheckedCreateWithoutStaffInput[]
    connectOrCreate?: SaleStaffCreateOrConnectWithoutStaffInput | SaleStaffCreateOrConnectWithoutStaffInput[]
    createMany?: SaleStaffCreateManyStaffInputEnvelope
    connect?: SaleStaffWhereUniqueInput | SaleStaffWhereUniqueInput[]
  }

  export type SaleUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<SaleCreateWithoutCreatedByInput, SaleUncheckedCreateWithoutCreatedByInput> | SaleCreateWithoutCreatedByInput[] | SaleUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: SaleCreateOrConnectWithoutCreatedByInput | SaleCreateOrConnectWithoutCreatedByInput[]
    createMany?: SaleCreateManyCreatedByInputEnvelope
    connect?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type EnumRoleFieldUpdateOperationsInput = {
    set?: $Enums.Role
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type SaleStaffUpdateManyWithoutStaffNestedInput = {
    create?: XOR<SaleStaffCreateWithoutStaffInput, SaleStaffUncheckedCreateWithoutStaffInput> | SaleStaffCreateWithoutStaffInput[] | SaleStaffUncheckedCreateWithoutStaffInput[]
    connectOrCreate?: SaleStaffCreateOrConnectWithoutStaffInput | SaleStaffCreateOrConnectWithoutStaffInput[]
    upsert?: SaleStaffUpsertWithWhereUniqueWithoutStaffInput | SaleStaffUpsertWithWhereUniqueWithoutStaffInput[]
    createMany?: SaleStaffCreateManyStaffInputEnvelope
    set?: SaleStaffWhereUniqueInput | SaleStaffWhereUniqueInput[]
    disconnect?: SaleStaffWhereUniqueInput | SaleStaffWhereUniqueInput[]
    delete?: SaleStaffWhereUniqueInput | SaleStaffWhereUniqueInput[]
    connect?: SaleStaffWhereUniqueInput | SaleStaffWhereUniqueInput[]
    update?: SaleStaffUpdateWithWhereUniqueWithoutStaffInput | SaleStaffUpdateWithWhereUniqueWithoutStaffInput[]
    updateMany?: SaleStaffUpdateManyWithWhereWithoutStaffInput | SaleStaffUpdateManyWithWhereWithoutStaffInput[]
    deleteMany?: SaleStaffScalarWhereInput | SaleStaffScalarWhereInput[]
  }

  export type SaleUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<SaleCreateWithoutCreatedByInput, SaleUncheckedCreateWithoutCreatedByInput> | SaleCreateWithoutCreatedByInput[] | SaleUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: SaleCreateOrConnectWithoutCreatedByInput | SaleCreateOrConnectWithoutCreatedByInput[]
    upsert?: SaleUpsertWithWhereUniqueWithoutCreatedByInput | SaleUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: SaleCreateManyCreatedByInputEnvelope
    set?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
    disconnect?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
    delete?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
    connect?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
    update?: SaleUpdateWithWhereUniqueWithoutCreatedByInput | SaleUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: SaleUpdateManyWithWhereWithoutCreatedByInput | SaleUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: SaleScalarWhereInput | SaleScalarWhereInput[]
  }

  export type SaleStaffUncheckedUpdateManyWithoutStaffNestedInput = {
    create?: XOR<SaleStaffCreateWithoutStaffInput, SaleStaffUncheckedCreateWithoutStaffInput> | SaleStaffCreateWithoutStaffInput[] | SaleStaffUncheckedCreateWithoutStaffInput[]
    connectOrCreate?: SaleStaffCreateOrConnectWithoutStaffInput | SaleStaffCreateOrConnectWithoutStaffInput[]
    upsert?: SaleStaffUpsertWithWhereUniqueWithoutStaffInput | SaleStaffUpsertWithWhereUniqueWithoutStaffInput[]
    createMany?: SaleStaffCreateManyStaffInputEnvelope
    set?: SaleStaffWhereUniqueInput | SaleStaffWhereUniqueInput[]
    disconnect?: SaleStaffWhereUniqueInput | SaleStaffWhereUniqueInput[]
    delete?: SaleStaffWhereUniqueInput | SaleStaffWhereUniqueInput[]
    connect?: SaleStaffWhereUniqueInput | SaleStaffWhereUniqueInput[]
    update?: SaleStaffUpdateWithWhereUniqueWithoutStaffInput | SaleStaffUpdateWithWhereUniqueWithoutStaffInput[]
    updateMany?: SaleStaffUpdateManyWithWhereWithoutStaffInput | SaleStaffUpdateManyWithWhereWithoutStaffInput[]
    deleteMany?: SaleStaffScalarWhereInput | SaleStaffScalarWhereInput[]
  }

  export type SaleUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<SaleCreateWithoutCreatedByInput, SaleUncheckedCreateWithoutCreatedByInput> | SaleCreateWithoutCreatedByInput[] | SaleUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: SaleCreateOrConnectWithoutCreatedByInput | SaleCreateOrConnectWithoutCreatedByInput[]
    upsert?: SaleUpsertWithWhereUniqueWithoutCreatedByInput | SaleUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: SaleCreateManyCreatedByInputEnvelope
    set?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
    disconnect?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
    delete?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
    connect?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
    update?: SaleUpdateWithWhereUniqueWithoutCreatedByInput | SaleUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: SaleUpdateManyWithWhereWithoutCreatedByInput | SaleUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: SaleScalarWhereInput | SaleScalarWhereInput[]
  }

  export type CustomerDiscountCreateNestedManyWithoutCustomerInput = {
    create?: XOR<CustomerDiscountCreateWithoutCustomerInput, CustomerDiscountUncheckedCreateWithoutCustomerInput> | CustomerDiscountCreateWithoutCustomerInput[] | CustomerDiscountUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: CustomerDiscountCreateOrConnectWithoutCustomerInput | CustomerDiscountCreateOrConnectWithoutCustomerInput[]
    createMany?: CustomerDiscountCreateManyCustomerInputEnvelope
    connect?: CustomerDiscountWhereUniqueInput | CustomerDiscountWhereUniqueInput[]
  }

  export type CustomerCreateNestedOneWithoutDependentsInput = {
    create?: XOR<CustomerCreateWithoutDependentsInput, CustomerUncheckedCreateWithoutDependentsInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutDependentsInput
    connect?: CustomerWhereUniqueInput
  }

  export type CustomerCreateNestedManyWithoutParentInput = {
    create?: XOR<CustomerCreateWithoutParentInput, CustomerUncheckedCreateWithoutParentInput> | CustomerCreateWithoutParentInput[] | CustomerUncheckedCreateWithoutParentInput[]
    connectOrCreate?: CustomerCreateOrConnectWithoutParentInput | CustomerCreateOrConnectWithoutParentInput[]
    createMany?: CustomerCreateManyParentInputEnvelope
    connect?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
  }

  export type SaleCreateNestedManyWithoutCustomerInput = {
    create?: XOR<SaleCreateWithoutCustomerInput, SaleUncheckedCreateWithoutCustomerInput> | SaleCreateWithoutCustomerInput[] | SaleUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: SaleCreateOrConnectWithoutCustomerInput | SaleCreateOrConnectWithoutCustomerInput[]
    createMany?: SaleCreateManyCustomerInputEnvelope
    connect?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
  }

  export type CustomerDiscountUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<CustomerDiscountCreateWithoutCustomerInput, CustomerDiscountUncheckedCreateWithoutCustomerInput> | CustomerDiscountCreateWithoutCustomerInput[] | CustomerDiscountUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: CustomerDiscountCreateOrConnectWithoutCustomerInput | CustomerDiscountCreateOrConnectWithoutCustomerInput[]
    createMany?: CustomerDiscountCreateManyCustomerInputEnvelope
    connect?: CustomerDiscountWhereUniqueInput | CustomerDiscountWhereUniqueInput[]
  }

  export type CustomerUncheckedCreateNestedManyWithoutParentInput = {
    create?: XOR<CustomerCreateWithoutParentInput, CustomerUncheckedCreateWithoutParentInput> | CustomerCreateWithoutParentInput[] | CustomerUncheckedCreateWithoutParentInput[]
    connectOrCreate?: CustomerCreateOrConnectWithoutParentInput | CustomerCreateOrConnectWithoutParentInput[]
    createMany?: CustomerCreateManyParentInputEnvelope
    connect?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
  }

  export type SaleUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<SaleCreateWithoutCustomerInput, SaleUncheckedCreateWithoutCustomerInput> | SaleCreateWithoutCustomerInput[] | SaleUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: SaleCreateOrConnectWithoutCustomerInput | SaleCreateOrConnectWithoutCustomerInput[]
    createMany?: SaleCreateManyCustomerInputEnvelope
    connect?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
  }

  export type EnumGenderFieldUpdateOperationsInput = {
    set?: $Enums.Gender
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type CustomerDiscountUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<CustomerDiscountCreateWithoutCustomerInput, CustomerDiscountUncheckedCreateWithoutCustomerInput> | CustomerDiscountCreateWithoutCustomerInput[] | CustomerDiscountUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: CustomerDiscountCreateOrConnectWithoutCustomerInput | CustomerDiscountCreateOrConnectWithoutCustomerInput[]
    upsert?: CustomerDiscountUpsertWithWhereUniqueWithoutCustomerInput | CustomerDiscountUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: CustomerDiscountCreateManyCustomerInputEnvelope
    set?: CustomerDiscountWhereUniqueInput | CustomerDiscountWhereUniqueInput[]
    disconnect?: CustomerDiscountWhereUniqueInput | CustomerDiscountWhereUniqueInput[]
    delete?: CustomerDiscountWhereUniqueInput | CustomerDiscountWhereUniqueInput[]
    connect?: CustomerDiscountWhereUniqueInput | CustomerDiscountWhereUniqueInput[]
    update?: CustomerDiscountUpdateWithWhereUniqueWithoutCustomerInput | CustomerDiscountUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: CustomerDiscountUpdateManyWithWhereWithoutCustomerInput | CustomerDiscountUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: CustomerDiscountScalarWhereInput | CustomerDiscountScalarWhereInput[]
  }

  export type CustomerUpdateOneWithoutDependentsNestedInput = {
    create?: XOR<CustomerCreateWithoutDependentsInput, CustomerUncheckedCreateWithoutDependentsInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutDependentsInput
    upsert?: CustomerUpsertWithoutDependentsInput
    disconnect?: CustomerWhereInput | boolean
    delete?: CustomerWhereInput | boolean
    connect?: CustomerWhereUniqueInput
    update?: XOR<XOR<CustomerUpdateToOneWithWhereWithoutDependentsInput, CustomerUpdateWithoutDependentsInput>, CustomerUncheckedUpdateWithoutDependentsInput>
  }

  export type CustomerUpdateManyWithoutParentNestedInput = {
    create?: XOR<CustomerCreateWithoutParentInput, CustomerUncheckedCreateWithoutParentInput> | CustomerCreateWithoutParentInput[] | CustomerUncheckedCreateWithoutParentInput[]
    connectOrCreate?: CustomerCreateOrConnectWithoutParentInput | CustomerCreateOrConnectWithoutParentInput[]
    upsert?: CustomerUpsertWithWhereUniqueWithoutParentInput | CustomerUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: CustomerCreateManyParentInputEnvelope
    set?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    disconnect?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    delete?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    connect?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    update?: CustomerUpdateWithWhereUniqueWithoutParentInput | CustomerUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: CustomerUpdateManyWithWhereWithoutParentInput | CustomerUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: CustomerScalarWhereInput | CustomerScalarWhereInput[]
  }

  export type SaleUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<SaleCreateWithoutCustomerInput, SaleUncheckedCreateWithoutCustomerInput> | SaleCreateWithoutCustomerInput[] | SaleUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: SaleCreateOrConnectWithoutCustomerInput | SaleCreateOrConnectWithoutCustomerInput[]
    upsert?: SaleUpsertWithWhereUniqueWithoutCustomerInput | SaleUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: SaleCreateManyCustomerInputEnvelope
    set?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
    disconnect?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
    delete?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
    connect?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
    update?: SaleUpdateWithWhereUniqueWithoutCustomerInput | SaleUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: SaleUpdateManyWithWhereWithoutCustomerInput | SaleUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: SaleScalarWhereInput | SaleScalarWhereInput[]
  }

  export type CustomerDiscountUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<CustomerDiscountCreateWithoutCustomerInput, CustomerDiscountUncheckedCreateWithoutCustomerInput> | CustomerDiscountCreateWithoutCustomerInput[] | CustomerDiscountUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: CustomerDiscountCreateOrConnectWithoutCustomerInput | CustomerDiscountCreateOrConnectWithoutCustomerInput[]
    upsert?: CustomerDiscountUpsertWithWhereUniqueWithoutCustomerInput | CustomerDiscountUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: CustomerDiscountCreateManyCustomerInputEnvelope
    set?: CustomerDiscountWhereUniqueInput | CustomerDiscountWhereUniqueInput[]
    disconnect?: CustomerDiscountWhereUniqueInput | CustomerDiscountWhereUniqueInput[]
    delete?: CustomerDiscountWhereUniqueInput | CustomerDiscountWhereUniqueInput[]
    connect?: CustomerDiscountWhereUniqueInput | CustomerDiscountWhereUniqueInput[]
    update?: CustomerDiscountUpdateWithWhereUniqueWithoutCustomerInput | CustomerDiscountUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: CustomerDiscountUpdateManyWithWhereWithoutCustomerInput | CustomerDiscountUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: CustomerDiscountScalarWhereInput | CustomerDiscountScalarWhereInput[]
  }

  export type CustomerUncheckedUpdateManyWithoutParentNestedInput = {
    create?: XOR<CustomerCreateWithoutParentInput, CustomerUncheckedCreateWithoutParentInput> | CustomerCreateWithoutParentInput[] | CustomerUncheckedCreateWithoutParentInput[]
    connectOrCreate?: CustomerCreateOrConnectWithoutParentInput | CustomerCreateOrConnectWithoutParentInput[]
    upsert?: CustomerUpsertWithWhereUniqueWithoutParentInput | CustomerUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: CustomerCreateManyParentInputEnvelope
    set?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    disconnect?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    delete?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    connect?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    update?: CustomerUpdateWithWhereUniqueWithoutParentInput | CustomerUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: CustomerUpdateManyWithWhereWithoutParentInput | CustomerUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: CustomerScalarWhereInput | CustomerScalarWhereInput[]
  }

  export type SaleUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<SaleCreateWithoutCustomerInput, SaleUncheckedCreateWithoutCustomerInput> | SaleCreateWithoutCustomerInput[] | SaleUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: SaleCreateOrConnectWithoutCustomerInput | SaleCreateOrConnectWithoutCustomerInput[]
    upsert?: SaleUpsertWithWhereUniqueWithoutCustomerInput | SaleUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: SaleCreateManyCustomerInputEnvelope
    set?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
    disconnect?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
    delete?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
    connect?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
    update?: SaleUpdateWithWhereUniqueWithoutCustomerInput | SaleUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: SaleUpdateManyWithWhereWithoutCustomerInput | SaleUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: SaleScalarWhereInput | SaleScalarWhereInput[]
  }

  export type SaleServiceCreateNestedManyWithoutServiceInput = {
    create?: XOR<SaleServiceCreateWithoutServiceInput, SaleServiceUncheckedCreateWithoutServiceInput> | SaleServiceCreateWithoutServiceInput[] | SaleServiceUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: SaleServiceCreateOrConnectWithoutServiceInput | SaleServiceCreateOrConnectWithoutServiceInput[]
    createMany?: SaleServiceCreateManyServiceInputEnvelope
    connect?: SaleServiceWhereUniqueInput | SaleServiceWhereUniqueInput[]
  }

  export type SaleServiceUncheckedCreateNestedManyWithoutServiceInput = {
    create?: XOR<SaleServiceCreateWithoutServiceInput, SaleServiceUncheckedCreateWithoutServiceInput> | SaleServiceCreateWithoutServiceInput[] | SaleServiceUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: SaleServiceCreateOrConnectWithoutServiceInput | SaleServiceCreateOrConnectWithoutServiceInput[]
    createMany?: SaleServiceCreateManyServiceInputEnvelope
    connect?: SaleServiceWhereUniqueInput | SaleServiceWhereUniqueInput[]
  }

  export type EnumServiceCategoryFieldUpdateOperationsInput = {
    set?: $Enums.ServiceCategory
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type SaleServiceUpdateManyWithoutServiceNestedInput = {
    create?: XOR<SaleServiceCreateWithoutServiceInput, SaleServiceUncheckedCreateWithoutServiceInput> | SaleServiceCreateWithoutServiceInput[] | SaleServiceUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: SaleServiceCreateOrConnectWithoutServiceInput | SaleServiceCreateOrConnectWithoutServiceInput[]
    upsert?: SaleServiceUpsertWithWhereUniqueWithoutServiceInput | SaleServiceUpsertWithWhereUniqueWithoutServiceInput[]
    createMany?: SaleServiceCreateManyServiceInputEnvelope
    set?: SaleServiceWhereUniqueInput | SaleServiceWhereUniqueInput[]
    disconnect?: SaleServiceWhereUniqueInput | SaleServiceWhereUniqueInput[]
    delete?: SaleServiceWhereUniqueInput | SaleServiceWhereUniqueInput[]
    connect?: SaleServiceWhereUniqueInput | SaleServiceWhereUniqueInput[]
    update?: SaleServiceUpdateWithWhereUniqueWithoutServiceInput | SaleServiceUpdateWithWhereUniqueWithoutServiceInput[]
    updateMany?: SaleServiceUpdateManyWithWhereWithoutServiceInput | SaleServiceUpdateManyWithWhereWithoutServiceInput[]
    deleteMany?: SaleServiceScalarWhereInput | SaleServiceScalarWhereInput[]
  }

  export type SaleServiceUncheckedUpdateManyWithoutServiceNestedInput = {
    create?: XOR<SaleServiceCreateWithoutServiceInput, SaleServiceUncheckedCreateWithoutServiceInput> | SaleServiceCreateWithoutServiceInput[] | SaleServiceUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: SaleServiceCreateOrConnectWithoutServiceInput | SaleServiceCreateOrConnectWithoutServiceInput[]
    upsert?: SaleServiceUpsertWithWhereUniqueWithoutServiceInput | SaleServiceUpsertWithWhereUniqueWithoutServiceInput[]
    createMany?: SaleServiceCreateManyServiceInputEnvelope
    set?: SaleServiceWhereUniqueInput | SaleServiceWhereUniqueInput[]
    disconnect?: SaleServiceWhereUniqueInput | SaleServiceWhereUniqueInput[]
    delete?: SaleServiceWhereUniqueInput | SaleServiceWhereUniqueInput[]
    connect?: SaleServiceWhereUniqueInput | SaleServiceWhereUniqueInput[]
    update?: SaleServiceUpdateWithWhereUniqueWithoutServiceInput | SaleServiceUpdateWithWhereUniqueWithoutServiceInput[]
    updateMany?: SaleServiceUpdateManyWithWhereWithoutServiceInput | SaleServiceUpdateManyWithWhereWithoutServiceInput[]
    deleteMany?: SaleServiceScalarWhereInput | SaleServiceScalarWhereInput[]
  }

  export type SaleDiscountCreateNestedManyWithoutSaleInput = {
    create?: XOR<SaleDiscountCreateWithoutSaleInput, SaleDiscountUncheckedCreateWithoutSaleInput> | SaleDiscountCreateWithoutSaleInput[] | SaleDiscountUncheckedCreateWithoutSaleInput[]
    connectOrCreate?: SaleDiscountCreateOrConnectWithoutSaleInput | SaleDiscountCreateOrConnectWithoutSaleInput[]
    createMany?: SaleDiscountCreateManySaleInputEnvelope
    connect?: SaleDiscountWhereUniqueInput | SaleDiscountWhereUniqueInput[]
  }

  export type SaleServiceCreateNestedManyWithoutSaleInput = {
    create?: XOR<SaleServiceCreateWithoutSaleInput, SaleServiceUncheckedCreateWithoutSaleInput> | SaleServiceCreateWithoutSaleInput[] | SaleServiceUncheckedCreateWithoutSaleInput[]
    connectOrCreate?: SaleServiceCreateOrConnectWithoutSaleInput | SaleServiceCreateOrConnectWithoutSaleInput[]
    createMany?: SaleServiceCreateManySaleInputEnvelope
    connect?: SaleServiceWhereUniqueInput | SaleServiceWhereUniqueInput[]
  }

  export type SaleProductCreateNestedManyWithoutSaleInput = {
    create?: XOR<SaleProductCreateWithoutSaleInput, SaleProductUncheckedCreateWithoutSaleInput> | SaleProductCreateWithoutSaleInput[] | SaleProductUncheckedCreateWithoutSaleInput[]
    connectOrCreate?: SaleProductCreateOrConnectWithoutSaleInput | SaleProductCreateOrConnectWithoutSaleInput[]
    createMany?: SaleProductCreateManySaleInputEnvelope
    connect?: SaleProductWhereUniqueInput | SaleProductWhereUniqueInput[]
  }

  export type SaleStaffCreateNestedManyWithoutSaleInput = {
    create?: XOR<SaleStaffCreateWithoutSaleInput, SaleStaffUncheckedCreateWithoutSaleInput> | SaleStaffCreateWithoutSaleInput[] | SaleStaffUncheckedCreateWithoutSaleInput[]
    connectOrCreate?: SaleStaffCreateOrConnectWithoutSaleInput | SaleStaffCreateOrConnectWithoutSaleInput[]
    createMany?: SaleStaffCreateManySaleInputEnvelope
    connect?: SaleStaffWhereUniqueInput | SaleStaffWhereUniqueInput[]
  }

  export type SalePaymentCreateNestedManyWithoutSaleInput = {
    create?: XOR<SalePaymentCreateWithoutSaleInput, SalePaymentUncheckedCreateWithoutSaleInput> | SalePaymentCreateWithoutSaleInput[] | SalePaymentUncheckedCreateWithoutSaleInput[]
    connectOrCreate?: SalePaymentCreateOrConnectWithoutSaleInput | SalePaymentCreateOrConnectWithoutSaleInput[]
    createMany?: SalePaymentCreateManySaleInputEnvelope
    connect?: SalePaymentWhereUniqueInput | SalePaymentWhereUniqueInput[]
  }

  export type UserCreateNestedOneWithoutSalesInput = {
    create?: XOR<UserCreateWithoutSalesInput, UserUncheckedCreateWithoutSalesInput>
    connectOrCreate?: UserCreateOrConnectWithoutSalesInput
    connect?: UserWhereUniqueInput
  }

  export type CustomerCreateNestedOneWithoutSalesInput = {
    create?: XOR<CustomerCreateWithoutSalesInput, CustomerUncheckedCreateWithoutSalesInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutSalesInput
    connect?: CustomerWhereUniqueInput
  }

  export type SaleDiscountUncheckedCreateNestedManyWithoutSaleInput = {
    create?: XOR<SaleDiscountCreateWithoutSaleInput, SaleDiscountUncheckedCreateWithoutSaleInput> | SaleDiscountCreateWithoutSaleInput[] | SaleDiscountUncheckedCreateWithoutSaleInput[]
    connectOrCreate?: SaleDiscountCreateOrConnectWithoutSaleInput | SaleDiscountCreateOrConnectWithoutSaleInput[]
    createMany?: SaleDiscountCreateManySaleInputEnvelope
    connect?: SaleDiscountWhereUniqueInput | SaleDiscountWhereUniqueInput[]
  }

  export type SaleServiceUncheckedCreateNestedManyWithoutSaleInput = {
    create?: XOR<SaleServiceCreateWithoutSaleInput, SaleServiceUncheckedCreateWithoutSaleInput> | SaleServiceCreateWithoutSaleInput[] | SaleServiceUncheckedCreateWithoutSaleInput[]
    connectOrCreate?: SaleServiceCreateOrConnectWithoutSaleInput | SaleServiceCreateOrConnectWithoutSaleInput[]
    createMany?: SaleServiceCreateManySaleInputEnvelope
    connect?: SaleServiceWhereUniqueInput | SaleServiceWhereUniqueInput[]
  }

  export type SaleProductUncheckedCreateNestedManyWithoutSaleInput = {
    create?: XOR<SaleProductCreateWithoutSaleInput, SaleProductUncheckedCreateWithoutSaleInput> | SaleProductCreateWithoutSaleInput[] | SaleProductUncheckedCreateWithoutSaleInput[]
    connectOrCreate?: SaleProductCreateOrConnectWithoutSaleInput | SaleProductCreateOrConnectWithoutSaleInput[]
    createMany?: SaleProductCreateManySaleInputEnvelope
    connect?: SaleProductWhereUniqueInput | SaleProductWhereUniqueInput[]
  }

  export type SaleStaffUncheckedCreateNestedManyWithoutSaleInput = {
    create?: XOR<SaleStaffCreateWithoutSaleInput, SaleStaffUncheckedCreateWithoutSaleInput> | SaleStaffCreateWithoutSaleInput[] | SaleStaffUncheckedCreateWithoutSaleInput[]
    connectOrCreate?: SaleStaffCreateOrConnectWithoutSaleInput | SaleStaffCreateOrConnectWithoutSaleInput[]
    createMany?: SaleStaffCreateManySaleInputEnvelope
    connect?: SaleStaffWhereUniqueInput | SaleStaffWhereUniqueInput[]
  }

  export type SalePaymentUncheckedCreateNestedManyWithoutSaleInput = {
    create?: XOR<SalePaymentCreateWithoutSaleInput, SalePaymentUncheckedCreateWithoutSaleInput> | SalePaymentCreateWithoutSaleInput[] | SalePaymentUncheckedCreateWithoutSaleInput[]
    connectOrCreate?: SalePaymentCreateOrConnectWithoutSaleInput | SalePaymentCreateOrConnectWithoutSaleInput[]
    createMany?: SalePaymentCreateManySaleInputEnvelope
    connect?: SalePaymentWhereUniqueInput | SalePaymentWhereUniqueInput[]
  }

  export type EnumPaymentMethodFieldUpdateOperationsInput = {
    set?: $Enums.PaymentMethod
  }

  export type SaleDiscountUpdateManyWithoutSaleNestedInput = {
    create?: XOR<SaleDiscountCreateWithoutSaleInput, SaleDiscountUncheckedCreateWithoutSaleInput> | SaleDiscountCreateWithoutSaleInput[] | SaleDiscountUncheckedCreateWithoutSaleInput[]
    connectOrCreate?: SaleDiscountCreateOrConnectWithoutSaleInput | SaleDiscountCreateOrConnectWithoutSaleInput[]
    upsert?: SaleDiscountUpsertWithWhereUniqueWithoutSaleInput | SaleDiscountUpsertWithWhereUniqueWithoutSaleInput[]
    createMany?: SaleDiscountCreateManySaleInputEnvelope
    set?: SaleDiscountWhereUniqueInput | SaleDiscountWhereUniqueInput[]
    disconnect?: SaleDiscountWhereUniqueInput | SaleDiscountWhereUniqueInput[]
    delete?: SaleDiscountWhereUniqueInput | SaleDiscountWhereUniqueInput[]
    connect?: SaleDiscountWhereUniqueInput | SaleDiscountWhereUniqueInput[]
    update?: SaleDiscountUpdateWithWhereUniqueWithoutSaleInput | SaleDiscountUpdateWithWhereUniqueWithoutSaleInput[]
    updateMany?: SaleDiscountUpdateManyWithWhereWithoutSaleInput | SaleDiscountUpdateManyWithWhereWithoutSaleInput[]
    deleteMany?: SaleDiscountScalarWhereInput | SaleDiscountScalarWhereInput[]
  }

  export type SaleServiceUpdateManyWithoutSaleNestedInput = {
    create?: XOR<SaleServiceCreateWithoutSaleInput, SaleServiceUncheckedCreateWithoutSaleInput> | SaleServiceCreateWithoutSaleInput[] | SaleServiceUncheckedCreateWithoutSaleInput[]
    connectOrCreate?: SaleServiceCreateOrConnectWithoutSaleInput | SaleServiceCreateOrConnectWithoutSaleInput[]
    upsert?: SaleServiceUpsertWithWhereUniqueWithoutSaleInput | SaleServiceUpsertWithWhereUniqueWithoutSaleInput[]
    createMany?: SaleServiceCreateManySaleInputEnvelope
    set?: SaleServiceWhereUniqueInput | SaleServiceWhereUniqueInput[]
    disconnect?: SaleServiceWhereUniqueInput | SaleServiceWhereUniqueInput[]
    delete?: SaleServiceWhereUniqueInput | SaleServiceWhereUniqueInput[]
    connect?: SaleServiceWhereUniqueInput | SaleServiceWhereUniqueInput[]
    update?: SaleServiceUpdateWithWhereUniqueWithoutSaleInput | SaleServiceUpdateWithWhereUniqueWithoutSaleInput[]
    updateMany?: SaleServiceUpdateManyWithWhereWithoutSaleInput | SaleServiceUpdateManyWithWhereWithoutSaleInput[]
    deleteMany?: SaleServiceScalarWhereInput | SaleServiceScalarWhereInput[]
  }

  export type SaleProductUpdateManyWithoutSaleNestedInput = {
    create?: XOR<SaleProductCreateWithoutSaleInput, SaleProductUncheckedCreateWithoutSaleInput> | SaleProductCreateWithoutSaleInput[] | SaleProductUncheckedCreateWithoutSaleInput[]
    connectOrCreate?: SaleProductCreateOrConnectWithoutSaleInput | SaleProductCreateOrConnectWithoutSaleInput[]
    upsert?: SaleProductUpsertWithWhereUniqueWithoutSaleInput | SaleProductUpsertWithWhereUniqueWithoutSaleInput[]
    createMany?: SaleProductCreateManySaleInputEnvelope
    set?: SaleProductWhereUniqueInput | SaleProductWhereUniqueInput[]
    disconnect?: SaleProductWhereUniqueInput | SaleProductWhereUniqueInput[]
    delete?: SaleProductWhereUniqueInput | SaleProductWhereUniqueInput[]
    connect?: SaleProductWhereUniqueInput | SaleProductWhereUniqueInput[]
    update?: SaleProductUpdateWithWhereUniqueWithoutSaleInput | SaleProductUpdateWithWhereUniqueWithoutSaleInput[]
    updateMany?: SaleProductUpdateManyWithWhereWithoutSaleInput | SaleProductUpdateManyWithWhereWithoutSaleInput[]
    deleteMany?: SaleProductScalarWhereInput | SaleProductScalarWhereInput[]
  }

  export type SaleStaffUpdateManyWithoutSaleNestedInput = {
    create?: XOR<SaleStaffCreateWithoutSaleInput, SaleStaffUncheckedCreateWithoutSaleInput> | SaleStaffCreateWithoutSaleInput[] | SaleStaffUncheckedCreateWithoutSaleInput[]
    connectOrCreate?: SaleStaffCreateOrConnectWithoutSaleInput | SaleStaffCreateOrConnectWithoutSaleInput[]
    upsert?: SaleStaffUpsertWithWhereUniqueWithoutSaleInput | SaleStaffUpsertWithWhereUniqueWithoutSaleInput[]
    createMany?: SaleStaffCreateManySaleInputEnvelope
    set?: SaleStaffWhereUniqueInput | SaleStaffWhereUniqueInput[]
    disconnect?: SaleStaffWhereUniqueInput | SaleStaffWhereUniqueInput[]
    delete?: SaleStaffWhereUniqueInput | SaleStaffWhereUniqueInput[]
    connect?: SaleStaffWhereUniqueInput | SaleStaffWhereUniqueInput[]
    update?: SaleStaffUpdateWithWhereUniqueWithoutSaleInput | SaleStaffUpdateWithWhereUniqueWithoutSaleInput[]
    updateMany?: SaleStaffUpdateManyWithWhereWithoutSaleInput | SaleStaffUpdateManyWithWhereWithoutSaleInput[]
    deleteMany?: SaleStaffScalarWhereInput | SaleStaffScalarWhereInput[]
  }

  export type SalePaymentUpdateManyWithoutSaleNestedInput = {
    create?: XOR<SalePaymentCreateWithoutSaleInput, SalePaymentUncheckedCreateWithoutSaleInput> | SalePaymentCreateWithoutSaleInput[] | SalePaymentUncheckedCreateWithoutSaleInput[]
    connectOrCreate?: SalePaymentCreateOrConnectWithoutSaleInput | SalePaymentCreateOrConnectWithoutSaleInput[]
    upsert?: SalePaymentUpsertWithWhereUniqueWithoutSaleInput | SalePaymentUpsertWithWhereUniqueWithoutSaleInput[]
    createMany?: SalePaymentCreateManySaleInputEnvelope
    set?: SalePaymentWhereUniqueInput | SalePaymentWhereUniqueInput[]
    disconnect?: SalePaymentWhereUniqueInput | SalePaymentWhereUniqueInput[]
    delete?: SalePaymentWhereUniqueInput | SalePaymentWhereUniqueInput[]
    connect?: SalePaymentWhereUniqueInput | SalePaymentWhereUniqueInput[]
    update?: SalePaymentUpdateWithWhereUniqueWithoutSaleInput | SalePaymentUpdateWithWhereUniqueWithoutSaleInput[]
    updateMany?: SalePaymentUpdateManyWithWhereWithoutSaleInput | SalePaymentUpdateManyWithWhereWithoutSaleInput[]
    deleteMany?: SalePaymentScalarWhereInput | SalePaymentScalarWhereInput[]
  }

  export type UserUpdateOneRequiredWithoutSalesNestedInput = {
    create?: XOR<UserCreateWithoutSalesInput, UserUncheckedCreateWithoutSalesInput>
    connectOrCreate?: UserCreateOrConnectWithoutSalesInput
    upsert?: UserUpsertWithoutSalesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSalesInput, UserUpdateWithoutSalesInput>, UserUncheckedUpdateWithoutSalesInput>
  }

  export type CustomerUpdateOneRequiredWithoutSalesNestedInput = {
    create?: XOR<CustomerCreateWithoutSalesInput, CustomerUncheckedCreateWithoutSalesInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutSalesInput
    upsert?: CustomerUpsertWithoutSalesInput
    connect?: CustomerWhereUniqueInput
    update?: XOR<XOR<CustomerUpdateToOneWithWhereWithoutSalesInput, CustomerUpdateWithoutSalesInput>, CustomerUncheckedUpdateWithoutSalesInput>
  }

  export type SaleDiscountUncheckedUpdateManyWithoutSaleNestedInput = {
    create?: XOR<SaleDiscountCreateWithoutSaleInput, SaleDiscountUncheckedCreateWithoutSaleInput> | SaleDiscountCreateWithoutSaleInput[] | SaleDiscountUncheckedCreateWithoutSaleInput[]
    connectOrCreate?: SaleDiscountCreateOrConnectWithoutSaleInput | SaleDiscountCreateOrConnectWithoutSaleInput[]
    upsert?: SaleDiscountUpsertWithWhereUniqueWithoutSaleInput | SaleDiscountUpsertWithWhereUniqueWithoutSaleInput[]
    createMany?: SaleDiscountCreateManySaleInputEnvelope
    set?: SaleDiscountWhereUniqueInput | SaleDiscountWhereUniqueInput[]
    disconnect?: SaleDiscountWhereUniqueInput | SaleDiscountWhereUniqueInput[]
    delete?: SaleDiscountWhereUniqueInput | SaleDiscountWhereUniqueInput[]
    connect?: SaleDiscountWhereUniqueInput | SaleDiscountWhereUniqueInput[]
    update?: SaleDiscountUpdateWithWhereUniqueWithoutSaleInput | SaleDiscountUpdateWithWhereUniqueWithoutSaleInput[]
    updateMany?: SaleDiscountUpdateManyWithWhereWithoutSaleInput | SaleDiscountUpdateManyWithWhereWithoutSaleInput[]
    deleteMany?: SaleDiscountScalarWhereInput | SaleDiscountScalarWhereInput[]
  }

  export type SaleServiceUncheckedUpdateManyWithoutSaleNestedInput = {
    create?: XOR<SaleServiceCreateWithoutSaleInput, SaleServiceUncheckedCreateWithoutSaleInput> | SaleServiceCreateWithoutSaleInput[] | SaleServiceUncheckedCreateWithoutSaleInput[]
    connectOrCreate?: SaleServiceCreateOrConnectWithoutSaleInput | SaleServiceCreateOrConnectWithoutSaleInput[]
    upsert?: SaleServiceUpsertWithWhereUniqueWithoutSaleInput | SaleServiceUpsertWithWhereUniqueWithoutSaleInput[]
    createMany?: SaleServiceCreateManySaleInputEnvelope
    set?: SaleServiceWhereUniqueInput | SaleServiceWhereUniqueInput[]
    disconnect?: SaleServiceWhereUniqueInput | SaleServiceWhereUniqueInput[]
    delete?: SaleServiceWhereUniqueInput | SaleServiceWhereUniqueInput[]
    connect?: SaleServiceWhereUniqueInput | SaleServiceWhereUniqueInput[]
    update?: SaleServiceUpdateWithWhereUniqueWithoutSaleInput | SaleServiceUpdateWithWhereUniqueWithoutSaleInput[]
    updateMany?: SaleServiceUpdateManyWithWhereWithoutSaleInput | SaleServiceUpdateManyWithWhereWithoutSaleInput[]
    deleteMany?: SaleServiceScalarWhereInput | SaleServiceScalarWhereInput[]
  }

  export type SaleProductUncheckedUpdateManyWithoutSaleNestedInput = {
    create?: XOR<SaleProductCreateWithoutSaleInput, SaleProductUncheckedCreateWithoutSaleInput> | SaleProductCreateWithoutSaleInput[] | SaleProductUncheckedCreateWithoutSaleInput[]
    connectOrCreate?: SaleProductCreateOrConnectWithoutSaleInput | SaleProductCreateOrConnectWithoutSaleInput[]
    upsert?: SaleProductUpsertWithWhereUniqueWithoutSaleInput | SaleProductUpsertWithWhereUniqueWithoutSaleInput[]
    createMany?: SaleProductCreateManySaleInputEnvelope
    set?: SaleProductWhereUniqueInput | SaleProductWhereUniqueInput[]
    disconnect?: SaleProductWhereUniqueInput | SaleProductWhereUniqueInput[]
    delete?: SaleProductWhereUniqueInput | SaleProductWhereUniqueInput[]
    connect?: SaleProductWhereUniqueInput | SaleProductWhereUniqueInput[]
    update?: SaleProductUpdateWithWhereUniqueWithoutSaleInput | SaleProductUpdateWithWhereUniqueWithoutSaleInput[]
    updateMany?: SaleProductUpdateManyWithWhereWithoutSaleInput | SaleProductUpdateManyWithWhereWithoutSaleInput[]
    deleteMany?: SaleProductScalarWhereInput | SaleProductScalarWhereInput[]
  }

  export type SaleStaffUncheckedUpdateManyWithoutSaleNestedInput = {
    create?: XOR<SaleStaffCreateWithoutSaleInput, SaleStaffUncheckedCreateWithoutSaleInput> | SaleStaffCreateWithoutSaleInput[] | SaleStaffUncheckedCreateWithoutSaleInput[]
    connectOrCreate?: SaleStaffCreateOrConnectWithoutSaleInput | SaleStaffCreateOrConnectWithoutSaleInput[]
    upsert?: SaleStaffUpsertWithWhereUniqueWithoutSaleInput | SaleStaffUpsertWithWhereUniqueWithoutSaleInput[]
    createMany?: SaleStaffCreateManySaleInputEnvelope
    set?: SaleStaffWhereUniqueInput | SaleStaffWhereUniqueInput[]
    disconnect?: SaleStaffWhereUniqueInput | SaleStaffWhereUniqueInput[]
    delete?: SaleStaffWhereUniqueInput | SaleStaffWhereUniqueInput[]
    connect?: SaleStaffWhereUniqueInput | SaleStaffWhereUniqueInput[]
    update?: SaleStaffUpdateWithWhereUniqueWithoutSaleInput | SaleStaffUpdateWithWhereUniqueWithoutSaleInput[]
    updateMany?: SaleStaffUpdateManyWithWhereWithoutSaleInput | SaleStaffUpdateManyWithWhereWithoutSaleInput[]
    deleteMany?: SaleStaffScalarWhereInput | SaleStaffScalarWhereInput[]
  }

  export type SalePaymentUncheckedUpdateManyWithoutSaleNestedInput = {
    create?: XOR<SalePaymentCreateWithoutSaleInput, SalePaymentUncheckedCreateWithoutSaleInput> | SalePaymentCreateWithoutSaleInput[] | SalePaymentUncheckedCreateWithoutSaleInput[]
    connectOrCreate?: SalePaymentCreateOrConnectWithoutSaleInput | SalePaymentCreateOrConnectWithoutSaleInput[]
    upsert?: SalePaymentUpsertWithWhereUniqueWithoutSaleInput | SalePaymentUpsertWithWhereUniqueWithoutSaleInput[]
    createMany?: SalePaymentCreateManySaleInputEnvelope
    set?: SalePaymentWhereUniqueInput | SalePaymentWhereUniqueInput[]
    disconnect?: SalePaymentWhereUniqueInput | SalePaymentWhereUniqueInput[]
    delete?: SalePaymentWhereUniqueInput | SalePaymentWhereUniqueInput[]
    connect?: SalePaymentWhereUniqueInput | SalePaymentWhereUniqueInput[]
    update?: SalePaymentUpdateWithWhereUniqueWithoutSaleInput | SalePaymentUpdateWithWhereUniqueWithoutSaleInput[]
    updateMany?: SalePaymentUpdateManyWithWhereWithoutSaleInput | SalePaymentUpdateManyWithWhereWithoutSaleInput[]
    deleteMany?: SalePaymentScalarWhereInput | SalePaymentScalarWhereInput[]
  }

  export type SaleCreateNestedOneWithoutServicesInput = {
    create?: XOR<SaleCreateWithoutServicesInput, SaleUncheckedCreateWithoutServicesInput>
    connectOrCreate?: SaleCreateOrConnectWithoutServicesInput
    connect?: SaleWhereUniqueInput
  }

  export type ServiceCreateNestedOneWithoutSaleServicesInput = {
    create?: XOR<ServiceCreateWithoutSaleServicesInput, ServiceUncheckedCreateWithoutSaleServicesInput>
    connectOrCreate?: ServiceCreateOrConnectWithoutSaleServicesInput
    connect?: ServiceWhereUniqueInput
  }

  export type SaleUpdateOneRequiredWithoutServicesNestedInput = {
    create?: XOR<SaleCreateWithoutServicesInput, SaleUncheckedCreateWithoutServicesInput>
    connectOrCreate?: SaleCreateOrConnectWithoutServicesInput
    upsert?: SaleUpsertWithoutServicesInput
    connect?: SaleWhereUniqueInput
    update?: XOR<XOR<SaleUpdateToOneWithWhereWithoutServicesInput, SaleUpdateWithoutServicesInput>, SaleUncheckedUpdateWithoutServicesInput>
  }

  export type ServiceUpdateOneRequiredWithoutSaleServicesNestedInput = {
    create?: XOR<ServiceCreateWithoutSaleServicesInput, ServiceUncheckedCreateWithoutSaleServicesInput>
    connectOrCreate?: ServiceCreateOrConnectWithoutSaleServicesInput
    upsert?: ServiceUpsertWithoutSaleServicesInput
    connect?: ServiceWhereUniqueInput
    update?: XOR<XOR<ServiceUpdateToOneWithWhereWithoutSaleServicesInput, ServiceUpdateWithoutSaleServicesInput>, ServiceUncheckedUpdateWithoutSaleServicesInput>
  }

  export type SaleCreateNestedOneWithoutStaffInput = {
    create?: XOR<SaleCreateWithoutStaffInput, SaleUncheckedCreateWithoutStaffInput>
    connectOrCreate?: SaleCreateOrConnectWithoutStaffInput
    connect?: SaleWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutStaffSalesInput = {
    create?: XOR<UserCreateWithoutStaffSalesInput, UserUncheckedCreateWithoutStaffSalesInput>
    connectOrCreate?: UserCreateOrConnectWithoutStaffSalesInput
    connect?: UserWhereUniqueInput
  }

  export type SaleUpdateOneRequiredWithoutStaffNestedInput = {
    create?: XOR<SaleCreateWithoutStaffInput, SaleUncheckedCreateWithoutStaffInput>
    connectOrCreate?: SaleCreateOrConnectWithoutStaffInput
    upsert?: SaleUpsertWithoutStaffInput
    connect?: SaleWhereUniqueInput
    update?: XOR<XOR<SaleUpdateToOneWithWhereWithoutStaffInput, SaleUpdateWithoutStaffInput>, SaleUncheckedUpdateWithoutStaffInput>
  }

  export type UserUpdateOneWithoutStaffSalesNestedInput = {
    create?: XOR<UserCreateWithoutStaffSalesInput, UserUncheckedCreateWithoutStaffSalesInput>
    connectOrCreate?: UserCreateOrConnectWithoutStaffSalesInput
    upsert?: UserUpsertWithoutStaffSalesInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutStaffSalesInput, UserUpdateWithoutStaffSalesInput>, UserUncheckedUpdateWithoutStaffSalesInput>
  }

  export type CustomerDiscountCreateNestedManyWithoutDiscountRuleInput = {
    create?: XOR<CustomerDiscountCreateWithoutDiscountRuleInput, CustomerDiscountUncheckedCreateWithoutDiscountRuleInput> | CustomerDiscountCreateWithoutDiscountRuleInput[] | CustomerDiscountUncheckedCreateWithoutDiscountRuleInput[]
    connectOrCreate?: CustomerDiscountCreateOrConnectWithoutDiscountRuleInput | CustomerDiscountCreateOrConnectWithoutDiscountRuleInput[]
    createMany?: CustomerDiscountCreateManyDiscountRuleInputEnvelope
    connect?: CustomerDiscountWhereUniqueInput | CustomerDiscountWhereUniqueInput[]
  }

  export type SaleDiscountCreateNestedManyWithoutDiscountRuleInput = {
    create?: XOR<SaleDiscountCreateWithoutDiscountRuleInput, SaleDiscountUncheckedCreateWithoutDiscountRuleInput> | SaleDiscountCreateWithoutDiscountRuleInput[] | SaleDiscountUncheckedCreateWithoutDiscountRuleInput[]
    connectOrCreate?: SaleDiscountCreateOrConnectWithoutDiscountRuleInput | SaleDiscountCreateOrConnectWithoutDiscountRuleInput[]
    createMany?: SaleDiscountCreateManyDiscountRuleInputEnvelope
    connect?: SaleDiscountWhereUniqueInput | SaleDiscountWhereUniqueInput[]
  }

  export type CustomerDiscountUncheckedCreateNestedManyWithoutDiscountRuleInput = {
    create?: XOR<CustomerDiscountCreateWithoutDiscountRuleInput, CustomerDiscountUncheckedCreateWithoutDiscountRuleInput> | CustomerDiscountCreateWithoutDiscountRuleInput[] | CustomerDiscountUncheckedCreateWithoutDiscountRuleInput[]
    connectOrCreate?: CustomerDiscountCreateOrConnectWithoutDiscountRuleInput | CustomerDiscountCreateOrConnectWithoutDiscountRuleInput[]
    createMany?: CustomerDiscountCreateManyDiscountRuleInputEnvelope
    connect?: CustomerDiscountWhereUniqueInput | CustomerDiscountWhereUniqueInput[]
  }

  export type SaleDiscountUncheckedCreateNestedManyWithoutDiscountRuleInput = {
    create?: XOR<SaleDiscountCreateWithoutDiscountRuleInput, SaleDiscountUncheckedCreateWithoutDiscountRuleInput> | SaleDiscountCreateWithoutDiscountRuleInput[] | SaleDiscountUncheckedCreateWithoutDiscountRuleInput[]
    connectOrCreate?: SaleDiscountCreateOrConnectWithoutDiscountRuleInput | SaleDiscountCreateOrConnectWithoutDiscountRuleInput[]
    createMany?: SaleDiscountCreateManyDiscountRuleInputEnvelope
    connect?: SaleDiscountWhereUniqueInput | SaleDiscountWhereUniqueInput[]
  }

  export type EnumDiscountTypeFieldUpdateOperationsInput = {
    set?: $Enums.DiscountType
  }

  export type CustomerDiscountUpdateManyWithoutDiscountRuleNestedInput = {
    create?: XOR<CustomerDiscountCreateWithoutDiscountRuleInput, CustomerDiscountUncheckedCreateWithoutDiscountRuleInput> | CustomerDiscountCreateWithoutDiscountRuleInput[] | CustomerDiscountUncheckedCreateWithoutDiscountRuleInput[]
    connectOrCreate?: CustomerDiscountCreateOrConnectWithoutDiscountRuleInput | CustomerDiscountCreateOrConnectWithoutDiscountRuleInput[]
    upsert?: CustomerDiscountUpsertWithWhereUniqueWithoutDiscountRuleInput | CustomerDiscountUpsertWithWhereUniqueWithoutDiscountRuleInput[]
    createMany?: CustomerDiscountCreateManyDiscountRuleInputEnvelope
    set?: CustomerDiscountWhereUniqueInput | CustomerDiscountWhereUniqueInput[]
    disconnect?: CustomerDiscountWhereUniqueInput | CustomerDiscountWhereUniqueInput[]
    delete?: CustomerDiscountWhereUniqueInput | CustomerDiscountWhereUniqueInput[]
    connect?: CustomerDiscountWhereUniqueInput | CustomerDiscountWhereUniqueInput[]
    update?: CustomerDiscountUpdateWithWhereUniqueWithoutDiscountRuleInput | CustomerDiscountUpdateWithWhereUniqueWithoutDiscountRuleInput[]
    updateMany?: CustomerDiscountUpdateManyWithWhereWithoutDiscountRuleInput | CustomerDiscountUpdateManyWithWhereWithoutDiscountRuleInput[]
    deleteMany?: CustomerDiscountScalarWhereInput | CustomerDiscountScalarWhereInput[]
  }

  export type SaleDiscountUpdateManyWithoutDiscountRuleNestedInput = {
    create?: XOR<SaleDiscountCreateWithoutDiscountRuleInput, SaleDiscountUncheckedCreateWithoutDiscountRuleInput> | SaleDiscountCreateWithoutDiscountRuleInput[] | SaleDiscountUncheckedCreateWithoutDiscountRuleInput[]
    connectOrCreate?: SaleDiscountCreateOrConnectWithoutDiscountRuleInput | SaleDiscountCreateOrConnectWithoutDiscountRuleInput[]
    upsert?: SaleDiscountUpsertWithWhereUniqueWithoutDiscountRuleInput | SaleDiscountUpsertWithWhereUniqueWithoutDiscountRuleInput[]
    createMany?: SaleDiscountCreateManyDiscountRuleInputEnvelope
    set?: SaleDiscountWhereUniqueInput | SaleDiscountWhereUniqueInput[]
    disconnect?: SaleDiscountWhereUniqueInput | SaleDiscountWhereUniqueInput[]
    delete?: SaleDiscountWhereUniqueInput | SaleDiscountWhereUniqueInput[]
    connect?: SaleDiscountWhereUniqueInput | SaleDiscountWhereUniqueInput[]
    update?: SaleDiscountUpdateWithWhereUniqueWithoutDiscountRuleInput | SaleDiscountUpdateWithWhereUniqueWithoutDiscountRuleInput[]
    updateMany?: SaleDiscountUpdateManyWithWhereWithoutDiscountRuleInput | SaleDiscountUpdateManyWithWhereWithoutDiscountRuleInput[]
    deleteMany?: SaleDiscountScalarWhereInput | SaleDiscountScalarWhereInput[]
  }

  export type CustomerDiscountUncheckedUpdateManyWithoutDiscountRuleNestedInput = {
    create?: XOR<CustomerDiscountCreateWithoutDiscountRuleInput, CustomerDiscountUncheckedCreateWithoutDiscountRuleInput> | CustomerDiscountCreateWithoutDiscountRuleInput[] | CustomerDiscountUncheckedCreateWithoutDiscountRuleInput[]
    connectOrCreate?: CustomerDiscountCreateOrConnectWithoutDiscountRuleInput | CustomerDiscountCreateOrConnectWithoutDiscountRuleInput[]
    upsert?: CustomerDiscountUpsertWithWhereUniqueWithoutDiscountRuleInput | CustomerDiscountUpsertWithWhereUniqueWithoutDiscountRuleInput[]
    createMany?: CustomerDiscountCreateManyDiscountRuleInputEnvelope
    set?: CustomerDiscountWhereUniqueInput | CustomerDiscountWhereUniqueInput[]
    disconnect?: CustomerDiscountWhereUniqueInput | CustomerDiscountWhereUniqueInput[]
    delete?: CustomerDiscountWhereUniqueInput | CustomerDiscountWhereUniqueInput[]
    connect?: CustomerDiscountWhereUniqueInput | CustomerDiscountWhereUniqueInput[]
    update?: CustomerDiscountUpdateWithWhereUniqueWithoutDiscountRuleInput | CustomerDiscountUpdateWithWhereUniqueWithoutDiscountRuleInput[]
    updateMany?: CustomerDiscountUpdateManyWithWhereWithoutDiscountRuleInput | CustomerDiscountUpdateManyWithWhereWithoutDiscountRuleInput[]
    deleteMany?: CustomerDiscountScalarWhereInput | CustomerDiscountScalarWhereInput[]
  }

  export type SaleDiscountUncheckedUpdateManyWithoutDiscountRuleNestedInput = {
    create?: XOR<SaleDiscountCreateWithoutDiscountRuleInput, SaleDiscountUncheckedCreateWithoutDiscountRuleInput> | SaleDiscountCreateWithoutDiscountRuleInput[] | SaleDiscountUncheckedCreateWithoutDiscountRuleInput[]
    connectOrCreate?: SaleDiscountCreateOrConnectWithoutDiscountRuleInput | SaleDiscountCreateOrConnectWithoutDiscountRuleInput[]
    upsert?: SaleDiscountUpsertWithWhereUniqueWithoutDiscountRuleInput | SaleDiscountUpsertWithWhereUniqueWithoutDiscountRuleInput[]
    createMany?: SaleDiscountCreateManyDiscountRuleInputEnvelope
    set?: SaleDiscountWhereUniqueInput | SaleDiscountWhereUniqueInput[]
    disconnect?: SaleDiscountWhereUniqueInput | SaleDiscountWhereUniqueInput[]
    delete?: SaleDiscountWhereUniqueInput | SaleDiscountWhereUniqueInput[]
    connect?: SaleDiscountWhereUniqueInput | SaleDiscountWhereUniqueInput[]
    update?: SaleDiscountUpdateWithWhereUniqueWithoutDiscountRuleInput | SaleDiscountUpdateWithWhereUniqueWithoutDiscountRuleInput[]
    updateMany?: SaleDiscountUpdateManyWithWhereWithoutDiscountRuleInput | SaleDiscountUpdateManyWithWhereWithoutDiscountRuleInput[]
    deleteMany?: SaleDiscountScalarWhereInput | SaleDiscountScalarWhereInput[]
  }

  export type DiscountRuleCreateNestedOneWithoutSaleDiscountsInput = {
    create?: XOR<DiscountRuleCreateWithoutSaleDiscountsInput, DiscountRuleUncheckedCreateWithoutSaleDiscountsInput>
    connectOrCreate?: DiscountRuleCreateOrConnectWithoutSaleDiscountsInput
    connect?: DiscountRuleWhereUniqueInput
  }

  export type SaleCreateNestedOneWithoutDiscountsInput = {
    create?: XOR<SaleCreateWithoutDiscountsInput, SaleUncheckedCreateWithoutDiscountsInput>
    connectOrCreate?: SaleCreateOrConnectWithoutDiscountsInput
    connect?: SaleWhereUniqueInput
  }

  export type DiscountRuleUpdateOneRequiredWithoutSaleDiscountsNestedInput = {
    create?: XOR<DiscountRuleCreateWithoutSaleDiscountsInput, DiscountRuleUncheckedCreateWithoutSaleDiscountsInput>
    connectOrCreate?: DiscountRuleCreateOrConnectWithoutSaleDiscountsInput
    upsert?: DiscountRuleUpsertWithoutSaleDiscountsInput
    connect?: DiscountRuleWhereUniqueInput
    update?: XOR<XOR<DiscountRuleUpdateToOneWithWhereWithoutSaleDiscountsInput, DiscountRuleUpdateWithoutSaleDiscountsInput>, DiscountRuleUncheckedUpdateWithoutSaleDiscountsInput>
  }

  export type SaleUpdateOneRequiredWithoutDiscountsNestedInput = {
    create?: XOR<SaleCreateWithoutDiscountsInput, SaleUncheckedCreateWithoutDiscountsInput>
    connectOrCreate?: SaleCreateOrConnectWithoutDiscountsInput
    upsert?: SaleUpsertWithoutDiscountsInput
    connect?: SaleWhereUniqueInput
    update?: XOR<XOR<SaleUpdateToOneWithWhereWithoutDiscountsInput, SaleUpdateWithoutDiscountsInput>, SaleUncheckedUpdateWithoutDiscountsInput>
  }

  export type CustomerCreateNestedOneWithoutDiscountsInput = {
    create?: XOR<CustomerCreateWithoutDiscountsInput, CustomerUncheckedCreateWithoutDiscountsInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutDiscountsInput
    connect?: CustomerWhereUniqueInput
  }

  export type DiscountRuleCreateNestedOneWithoutCustomerDiscountsInput = {
    create?: XOR<DiscountRuleCreateWithoutCustomerDiscountsInput, DiscountRuleUncheckedCreateWithoutCustomerDiscountsInput>
    connectOrCreate?: DiscountRuleCreateOrConnectWithoutCustomerDiscountsInput
    connect?: DiscountRuleWhereUniqueInput
  }

  export type CustomerUpdateOneRequiredWithoutDiscountsNestedInput = {
    create?: XOR<CustomerCreateWithoutDiscountsInput, CustomerUncheckedCreateWithoutDiscountsInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutDiscountsInput
    upsert?: CustomerUpsertWithoutDiscountsInput
    connect?: CustomerWhereUniqueInput
    update?: XOR<XOR<CustomerUpdateToOneWithWhereWithoutDiscountsInput, CustomerUpdateWithoutDiscountsInput>, CustomerUncheckedUpdateWithoutDiscountsInput>
  }

  export type DiscountRuleUpdateOneRequiredWithoutCustomerDiscountsNestedInput = {
    create?: XOR<DiscountRuleCreateWithoutCustomerDiscountsInput, DiscountRuleUncheckedCreateWithoutCustomerDiscountsInput>
    connectOrCreate?: DiscountRuleCreateOrConnectWithoutCustomerDiscountsInput
    upsert?: DiscountRuleUpsertWithoutCustomerDiscountsInput
    connect?: DiscountRuleWhereUniqueInput
    update?: XOR<XOR<DiscountRuleUpdateToOneWithWhereWithoutCustomerDiscountsInput, DiscountRuleUpdateWithoutCustomerDiscountsInput>, DiscountRuleUncheckedUpdateWithoutCustomerDiscountsInput>
  }

  export type SaleCreateNestedOneWithoutPaymentsInput = {
    create?: XOR<SaleCreateWithoutPaymentsInput, SaleUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: SaleCreateOrConnectWithoutPaymentsInput
    connect?: SaleWhereUniqueInput
  }

  export type SaleUpdateOneRequiredWithoutPaymentsNestedInput = {
    create?: XOR<SaleCreateWithoutPaymentsInput, SaleUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: SaleCreateOrConnectWithoutPaymentsInput
    upsert?: SaleUpsertWithoutPaymentsInput
    connect?: SaleWhereUniqueInput
    update?: XOR<XOR<SaleUpdateToOneWithWhereWithoutPaymentsInput, SaleUpdateWithoutPaymentsInput>, SaleUncheckedUpdateWithoutPaymentsInput>
  }

  export type SaleProductCreateNestedManyWithoutProductInput = {
    create?: XOR<SaleProductCreateWithoutProductInput, SaleProductUncheckedCreateWithoutProductInput> | SaleProductCreateWithoutProductInput[] | SaleProductUncheckedCreateWithoutProductInput[]
    connectOrCreate?: SaleProductCreateOrConnectWithoutProductInput | SaleProductCreateOrConnectWithoutProductInput[]
    createMany?: SaleProductCreateManyProductInputEnvelope
    connect?: SaleProductWhereUniqueInput | SaleProductWhereUniqueInput[]
  }

  export type SaleProductUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<SaleProductCreateWithoutProductInput, SaleProductUncheckedCreateWithoutProductInput> | SaleProductCreateWithoutProductInput[] | SaleProductUncheckedCreateWithoutProductInput[]
    connectOrCreate?: SaleProductCreateOrConnectWithoutProductInput | SaleProductCreateOrConnectWithoutProductInput[]
    createMany?: SaleProductCreateManyProductInputEnvelope
    connect?: SaleProductWhereUniqueInput | SaleProductWhereUniqueInput[]
  }

  export type SaleProductUpdateManyWithoutProductNestedInput = {
    create?: XOR<SaleProductCreateWithoutProductInput, SaleProductUncheckedCreateWithoutProductInput> | SaleProductCreateWithoutProductInput[] | SaleProductUncheckedCreateWithoutProductInput[]
    connectOrCreate?: SaleProductCreateOrConnectWithoutProductInput | SaleProductCreateOrConnectWithoutProductInput[]
    upsert?: SaleProductUpsertWithWhereUniqueWithoutProductInput | SaleProductUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: SaleProductCreateManyProductInputEnvelope
    set?: SaleProductWhereUniqueInput | SaleProductWhereUniqueInput[]
    disconnect?: SaleProductWhereUniqueInput | SaleProductWhereUniqueInput[]
    delete?: SaleProductWhereUniqueInput | SaleProductWhereUniqueInput[]
    connect?: SaleProductWhereUniqueInput | SaleProductWhereUniqueInput[]
    update?: SaleProductUpdateWithWhereUniqueWithoutProductInput | SaleProductUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: SaleProductUpdateManyWithWhereWithoutProductInput | SaleProductUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: SaleProductScalarWhereInput | SaleProductScalarWhereInput[]
  }

  export type SaleProductUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<SaleProductCreateWithoutProductInput, SaleProductUncheckedCreateWithoutProductInput> | SaleProductCreateWithoutProductInput[] | SaleProductUncheckedCreateWithoutProductInput[]
    connectOrCreate?: SaleProductCreateOrConnectWithoutProductInput | SaleProductCreateOrConnectWithoutProductInput[]
    upsert?: SaleProductUpsertWithWhereUniqueWithoutProductInput | SaleProductUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: SaleProductCreateManyProductInputEnvelope
    set?: SaleProductWhereUniqueInput | SaleProductWhereUniqueInput[]
    disconnect?: SaleProductWhereUniqueInput | SaleProductWhereUniqueInput[]
    delete?: SaleProductWhereUniqueInput | SaleProductWhereUniqueInput[]
    connect?: SaleProductWhereUniqueInput | SaleProductWhereUniqueInput[]
    update?: SaleProductUpdateWithWhereUniqueWithoutProductInput | SaleProductUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: SaleProductUpdateManyWithWhereWithoutProductInput | SaleProductUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: SaleProductScalarWhereInput | SaleProductScalarWhereInput[]
  }

  export type SaleCreateNestedOneWithoutProductsInput = {
    create?: XOR<SaleCreateWithoutProductsInput, SaleUncheckedCreateWithoutProductsInput>
    connectOrCreate?: SaleCreateOrConnectWithoutProductsInput
    connect?: SaleWhereUniqueInput
  }

  export type ProductCreateNestedOneWithoutSaleProductsInput = {
    create?: XOR<ProductCreateWithoutSaleProductsInput, ProductUncheckedCreateWithoutSaleProductsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutSaleProductsInput
    connect?: ProductWhereUniqueInput
  }

  export type SaleUpdateOneRequiredWithoutProductsNestedInput = {
    create?: XOR<SaleCreateWithoutProductsInput, SaleUncheckedCreateWithoutProductsInput>
    connectOrCreate?: SaleCreateOrConnectWithoutProductsInput
    upsert?: SaleUpsertWithoutProductsInput
    connect?: SaleWhereUniqueInput
    update?: XOR<XOR<SaleUpdateToOneWithWhereWithoutProductsInput, SaleUpdateWithoutProductsInput>, SaleUncheckedUpdateWithoutProductsInput>
  }

  export type ProductUpdateOneRequiredWithoutSaleProductsNestedInput = {
    create?: XOR<ProductCreateWithoutSaleProductsInput, ProductUncheckedCreateWithoutSaleProductsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutSaleProductsInput
    upsert?: ProductUpsertWithoutSaleProductsInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutSaleProductsInput, ProductUpdateWithoutSaleProductsInput>, ProductUncheckedUpdateWithoutSaleProductsInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedEnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleFilter<$PrismaModel>
    _max?: NestedEnumRoleFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedEnumGenderFilter<$PrismaModel = never> = {
    equals?: $Enums.Gender | EnumGenderFieldRefInput<$PrismaModel>
    in?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel>
    notIn?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel>
    not?: NestedEnumGenderFilter<$PrismaModel> | $Enums.Gender
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedEnumGenderWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Gender | EnumGenderFieldRefInput<$PrismaModel>
    in?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel>
    notIn?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel>
    not?: NestedEnumGenderWithAggregatesFilter<$PrismaModel> | $Enums.Gender
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumGenderFilter<$PrismaModel>
    _max?: NestedEnumGenderFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedEnumServiceCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.ServiceCategory | EnumServiceCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.ServiceCategory[] | ListEnumServiceCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.ServiceCategory[] | ListEnumServiceCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumServiceCategoryFilter<$PrismaModel> | $Enums.ServiceCategory
  }

  export type NestedDecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type NestedEnumServiceCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ServiceCategory | EnumServiceCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.ServiceCategory[] | ListEnumServiceCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.ServiceCategory[] | ListEnumServiceCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumServiceCategoryWithAggregatesFilter<$PrismaModel> | $Enums.ServiceCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumServiceCategoryFilter<$PrismaModel>
    _max?: NestedEnumServiceCategoryFilter<$PrismaModel>
  }

  export type NestedDecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type NestedEnumPaymentMethodFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentMethodFilter<$PrismaModel> | $Enums.PaymentMethod
  }

  export type NestedEnumPaymentMethodWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentMethodWithAggregatesFilter<$PrismaModel> | $Enums.PaymentMethod
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentMethodFilter<$PrismaModel>
    _max?: NestedEnumPaymentMethodFilter<$PrismaModel>
  }

  export type NestedEnumDiscountTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.DiscountType | EnumDiscountTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DiscountType[] | ListEnumDiscountTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DiscountType[] | ListEnumDiscountTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDiscountTypeFilter<$PrismaModel> | $Enums.DiscountType
  }

  export type NestedEnumDiscountTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DiscountType | EnumDiscountTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DiscountType[] | ListEnumDiscountTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DiscountType[] | ListEnumDiscountTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDiscountTypeWithAggregatesFilter<$PrismaModel> | $Enums.DiscountType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDiscountTypeFilter<$PrismaModel>
    _max?: NestedEnumDiscountTypeFilter<$PrismaModel>
  }

  export type SaleStaffCreateWithoutStaffInput = {
    id?: string
    customName?: string | null
    serviceId?: string | null
    createdAt?: Date | string
    sale: SaleCreateNestedOneWithoutStaffInput
  }

  export type SaleStaffUncheckedCreateWithoutStaffInput = {
    id?: string
    saleId: string
    customName?: string | null
    serviceId?: string | null
    createdAt?: Date | string
  }

  export type SaleStaffCreateOrConnectWithoutStaffInput = {
    where: SaleStaffWhereUniqueInput
    create: XOR<SaleStaffCreateWithoutStaffInput, SaleStaffUncheckedCreateWithoutStaffInput>
  }

  export type SaleStaffCreateManyStaffInputEnvelope = {
    data: SaleStaffCreateManyStaffInput | SaleStaffCreateManyStaffInput[]
    skipDuplicates?: boolean
  }

  export type SaleCreateWithoutCreatedByInput = {
    id?: string
    saleDate?: Date | string
    totalAmount: Decimal | DecimalJsLike | number | string
    discountAmount?: Decimal | DecimalJsLike | number | string
    finalAmount: Decimal | DecimalJsLike | number | string
    loyaltyPointsEarned?: number
    notes?: string | null
    isCompleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    birthMonthDiscount?: boolean
    ownShampooDiscount?: boolean
    paymentMethod?: $Enums.PaymentMethod
    discounts?: SaleDiscountCreateNestedManyWithoutSaleInput
    services?: SaleServiceCreateNestedManyWithoutSaleInput
    products?: SaleProductCreateNestedManyWithoutSaleInput
    staff?: SaleStaffCreateNestedManyWithoutSaleInput
    payments?: SalePaymentCreateNestedManyWithoutSaleInput
    customer: CustomerCreateNestedOneWithoutSalesInput
  }

  export type SaleUncheckedCreateWithoutCreatedByInput = {
    id?: string
    customerId: string
    saleDate?: Date | string
    totalAmount: Decimal | DecimalJsLike | number | string
    discountAmount?: Decimal | DecimalJsLike | number | string
    finalAmount: Decimal | DecimalJsLike | number | string
    loyaltyPointsEarned?: number
    notes?: string | null
    isCompleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    birthMonthDiscount?: boolean
    ownShampooDiscount?: boolean
    paymentMethod?: $Enums.PaymentMethod
    discounts?: SaleDiscountUncheckedCreateNestedManyWithoutSaleInput
    services?: SaleServiceUncheckedCreateNestedManyWithoutSaleInput
    products?: SaleProductUncheckedCreateNestedManyWithoutSaleInput
    staff?: SaleStaffUncheckedCreateNestedManyWithoutSaleInput
    payments?: SalePaymentUncheckedCreateNestedManyWithoutSaleInput
  }

  export type SaleCreateOrConnectWithoutCreatedByInput = {
    where: SaleWhereUniqueInput
    create: XOR<SaleCreateWithoutCreatedByInput, SaleUncheckedCreateWithoutCreatedByInput>
  }

  export type SaleCreateManyCreatedByInputEnvelope = {
    data: SaleCreateManyCreatedByInput | SaleCreateManyCreatedByInput[]
    skipDuplicates?: boolean
  }

  export type SaleStaffUpsertWithWhereUniqueWithoutStaffInput = {
    where: SaleStaffWhereUniqueInput
    update: XOR<SaleStaffUpdateWithoutStaffInput, SaleStaffUncheckedUpdateWithoutStaffInput>
    create: XOR<SaleStaffCreateWithoutStaffInput, SaleStaffUncheckedCreateWithoutStaffInput>
  }

  export type SaleStaffUpdateWithWhereUniqueWithoutStaffInput = {
    where: SaleStaffWhereUniqueInput
    data: XOR<SaleStaffUpdateWithoutStaffInput, SaleStaffUncheckedUpdateWithoutStaffInput>
  }

  export type SaleStaffUpdateManyWithWhereWithoutStaffInput = {
    where: SaleStaffScalarWhereInput
    data: XOR<SaleStaffUpdateManyMutationInput, SaleStaffUncheckedUpdateManyWithoutStaffInput>
  }

  export type SaleStaffScalarWhereInput = {
    AND?: SaleStaffScalarWhereInput | SaleStaffScalarWhereInput[]
    OR?: SaleStaffScalarWhereInput[]
    NOT?: SaleStaffScalarWhereInput | SaleStaffScalarWhereInput[]
    id?: StringFilter<"SaleStaff"> | string
    saleId?: StringFilter<"SaleStaff"> | string
    staffId?: StringNullableFilter<"SaleStaff"> | string | null
    customName?: StringNullableFilter<"SaleStaff"> | string | null
    serviceId?: StringNullableFilter<"SaleStaff"> | string | null
    createdAt?: DateTimeFilter<"SaleStaff"> | Date | string
  }

  export type SaleUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: SaleWhereUniqueInput
    update: XOR<SaleUpdateWithoutCreatedByInput, SaleUncheckedUpdateWithoutCreatedByInput>
    create: XOR<SaleCreateWithoutCreatedByInput, SaleUncheckedCreateWithoutCreatedByInput>
  }

  export type SaleUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: SaleWhereUniqueInput
    data: XOR<SaleUpdateWithoutCreatedByInput, SaleUncheckedUpdateWithoutCreatedByInput>
  }

  export type SaleUpdateManyWithWhereWithoutCreatedByInput = {
    where: SaleScalarWhereInput
    data: XOR<SaleUpdateManyMutationInput, SaleUncheckedUpdateManyWithoutCreatedByInput>
  }

  export type SaleScalarWhereInput = {
    AND?: SaleScalarWhereInput | SaleScalarWhereInput[]
    OR?: SaleScalarWhereInput[]
    NOT?: SaleScalarWhereInput | SaleScalarWhereInput[]
    id?: StringFilter<"Sale"> | string
    customerId?: StringFilter<"Sale"> | string
    saleDate?: DateTimeFilter<"Sale"> | Date | string
    totalAmount?: DecimalFilter<"Sale"> | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFilter<"Sale"> | Decimal | DecimalJsLike | number | string
    finalAmount?: DecimalFilter<"Sale"> | Decimal | DecimalJsLike | number | string
    loyaltyPointsEarned?: IntFilter<"Sale"> | number
    notes?: StringNullableFilter<"Sale"> | string | null
    isCompleted?: BoolFilter<"Sale"> | boolean
    createdById?: StringFilter<"Sale"> | string
    createdAt?: DateTimeFilter<"Sale"> | Date | string
    updatedAt?: DateTimeFilter<"Sale"> | Date | string
    birthMonthDiscount?: BoolFilter<"Sale"> | boolean
    ownShampooDiscount?: BoolFilter<"Sale"> | boolean
    paymentMethod?: EnumPaymentMethodFilter<"Sale"> | $Enums.PaymentMethod
  }

  export type CustomerDiscountCreateWithoutCustomerInput = {
    id?: string
    usedAt?: Date | string
    discountAmount: Decimal | DecimalJsLike | number | string
    discountRule: DiscountRuleCreateNestedOneWithoutCustomerDiscountsInput
  }

  export type CustomerDiscountUncheckedCreateWithoutCustomerInput = {
    id?: string
    discountRuleId: string
    usedAt?: Date | string
    discountAmount: Decimal | DecimalJsLike | number | string
  }

  export type CustomerDiscountCreateOrConnectWithoutCustomerInput = {
    where: CustomerDiscountWhereUniqueInput
    create: XOR<CustomerDiscountCreateWithoutCustomerInput, CustomerDiscountUncheckedCreateWithoutCustomerInput>
  }

  export type CustomerDiscountCreateManyCustomerInputEnvelope = {
    data: CustomerDiscountCreateManyCustomerInput | CustomerDiscountCreateManyCustomerInput[]
    skipDuplicates?: boolean
  }

  export type CustomerCreateWithoutDependentsInput = {
    id?: string
    fullName: string
    gender: $Enums.Gender
    location: string
    district: string
    province: string
    phone?: string | null
    email?: string | null
    birthDay: number
    birthMonth: number
    birthYear?: number | null
    loyaltyPoints?: number
    totalSpent?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    isActive?: boolean
    additionalLocation?: string | null
    isDependent?: boolean
    lastSale?: Date | string | null
    saleCount?: number
    sector?: string | null
    discounts?: CustomerDiscountCreateNestedManyWithoutCustomerInput
    parent?: CustomerCreateNestedOneWithoutDependentsInput
    sales?: SaleCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateWithoutDependentsInput = {
    id?: string
    fullName: string
    gender: $Enums.Gender
    location: string
    district: string
    province: string
    phone?: string | null
    email?: string | null
    birthDay: number
    birthMonth: number
    birthYear?: number | null
    loyaltyPoints?: number
    totalSpent?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    isActive?: boolean
    additionalLocation?: string | null
    isDependent?: boolean
    lastSale?: Date | string | null
    parentId?: string | null
    saleCount?: number
    sector?: string | null
    discounts?: CustomerDiscountUncheckedCreateNestedManyWithoutCustomerInput
    sales?: SaleUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerCreateOrConnectWithoutDependentsInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutDependentsInput, CustomerUncheckedCreateWithoutDependentsInput>
  }

  export type CustomerCreateWithoutParentInput = {
    id?: string
    fullName: string
    gender: $Enums.Gender
    location: string
    district: string
    province: string
    phone?: string | null
    email?: string | null
    birthDay: number
    birthMonth: number
    birthYear?: number | null
    loyaltyPoints?: number
    totalSpent?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    isActive?: boolean
    additionalLocation?: string | null
    isDependent?: boolean
    lastSale?: Date | string | null
    saleCount?: number
    sector?: string | null
    discounts?: CustomerDiscountCreateNestedManyWithoutCustomerInput
    dependents?: CustomerCreateNestedManyWithoutParentInput
    sales?: SaleCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateWithoutParentInput = {
    id?: string
    fullName: string
    gender: $Enums.Gender
    location: string
    district: string
    province: string
    phone?: string | null
    email?: string | null
    birthDay: number
    birthMonth: number
    birthYear?: number | null
    loyaltyPoints?: number
    totalSpent?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    isActive?: boolean
    additionalLocation?: string | null
    isDependent?: boolean
    lastSale?: Date | string | null
    saleCount?: number
    sector?: string | null
    discounts?: CustomerDiscountUncheckedCreateNestedManyWithoutCustomerInput
    dependents?: CustomerUncheckedCreateNestedManyWithoutParentInput
    sales?: SaleUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerCreateOrConnectWithoutParentInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutParentInput, CustomerUncheckedCreateWithoutParentInput>
  }

  export type CustomerCreateManyParentInputEnvelope = {
    data: CustomerCreateManyParentInput | CustomerCreateManyParentInput[]
    skipDuplicates?: boolean
  }

  export type SaleCreateWithoutCustomerInput = {
    id?: string
    saleDate?: Date | string
    totalAmount: Decimal | DecimalJsLike | number | string
    discountAmount?: Decimal | DecimalJsLike | number | string
    finalAmount: Decimal | DecimalJsLike | number | string
    loyaltyPointsEarned?: number
    notes?: string | null
    isCompleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    birthMonthDiscount?: boolean
    ownShampooDiscount?: boolean
    paymentMethod?: $Enums.PaymentMethod
    discounts?: SaleDiscountCreateNestedManyWithoutSaleInput
    services?: SaleServiceCreateNestedManyWithoutSaleInput
    products?: SaleProductCreateNestedManyWithoutSaleInput
    staff?: SaleStaffCreateNestedManyWithoutSaleInput
    payments?: SalePaymentCreateNestedManyWithoutSaleInput
    createdBy: UserCreateNestedOneWithoutSalesInput
  }

  export type SaleUncheckedCreateWithoutCustomerInput = {
    id?: string
    saleDate?: Date | string
    totalAmount: Decimal | DecimalJsLike | number | string
    discountAmount?: Decimal | DecimalJsLike | number | string
    finalAmount: Decimal | DecimalJsLike | number | string
    loyaltyPointsEarned?: number
    notes?: string | null
    isCompleted?: boolean
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
    birthMonthDiscount?: boolean
    ownShampooDiscount?: boolean
    paymentMethod?: $Enums.PaymentMethod
    discounts?: SaleDiscountUncheckedCreateNestedManyWithoutSaleInput
    services?: SaleServiceUncheckedCreateNestedManyWithoutSaleInput
    products?: SaleProductUncheckedCreateNestedManyWithoutSaleInput
    staff?: SaleStaffUncheckedCreateNestedManyWithoutSaleInput
    payments?: SalePaymentUncheckedCreateNestedManyWithoutSaleInput
  }

  export type SaleCreateOrConnectWithoutCustomerInput = {
    where: SaleWhereUniqueInput
    create: XOR<SaleCreateWithoutCustomerInput, SaleUncheckedCreateWithoutCustomerInput>
  }

  export type SaleCreateManyCustomerInputEnvelope = {
    data: SaleCreateManyCustomerInput | SaleCreateManyCustomerInput[]
    skipDuplicates?: boolean
  }

  export type CustomerDiscountUpsertWithWhereUniqueWithoutCustomerInput = {
    where: CustomerDiscountWhereUniqueInput
    update: XOR<CustomerDiscountUpdateWithoutCustomerInput, CustomerDiscountUncheckedUpdateWithoutCustomerInput>
    create: XOR<CustomerDiscountCreateWithoutCustomerInput, CustomerDiscountUncheckedCreateWithoutCustomerInput>
  }

  export type CustomerDiscountUpdateWithWhereUniqueWithoutCustomerInput = {
    where: CustomerDiscountWhereUniqueInput
    data: XOR<CustomerDiscountUpdateWithoutCustomerInput, CustomerDiscountUncheckedUpdateWithoutCustomerInput>
  }

  export type CustomerDiscountUpdateManyWithWhereWithoutCustomerInput = {
    where: CustomerDiscountScalarWhereInput
    data: XOR<CustomerDiscountUpdateManyMutationInput, CustomerDiscountUncheckedUpdateManyWithoutCustomerInput>
  }

  export type CustomerDiscountScalarWhereInput = {
    AND?: CustomerDiscountScalarWhereInput | CustomerDiscountScalarWhereInput[]
    OR?: CustomerDiscountScalarWhereInput[]
    NOT?: CustomerDiscountScalarWhereInput | CustomerDiscountScalarWhereInput[]
    id?: StringFilter<"CustomerDiscount"> | string
    customerId?: StringFilter<"CustomerDiscount"> | string
    discountRuleId?: StringFilter<"CustomerDiscount"> | string
    usedAt?: DateTimeFilter<"CustomerDiscount"> | Date | string
    discountAmount?: DecimalFilter<"CustomerDiscount"> | Decimal | DecimalJsLike | number | string
  }

  export type CustomerUpsertWithoutDependentsInput = {
    update: XOR<CustomerUpdateWithoutDependentsInput, CustomerUncheckedUpdateWithoutDependentsInput>
    create: XOR<CustomerCreateWithoutDependentsInput, CustomerUncheckedCreateWithoutDependentsInput>
    where?: CustomerWhereInput
  }

  export type CustomerUpdateToOneWithWhereWithoutDependentsInput = {
    where?: CustomerWhereInput
    data: XOR<CustomerUpdateWithoutDependentsInput, CustomerUncheckedUpdateWithoutDependentsInput>
  }

  export type CustomerUpdateWithoutDependentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    location?: StringFieldUpdateOperationsInput | string
    district?: StringFieldUpdateOperationsInput | string
    province?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    birthDay?: IntFieldUpdateOperationsInput | number
    birthMonth?: IntFieldUpdateOperationsInput | number
    birthYear?: NullableIntFieldUpdateOperationsInput | number | null
    loyaltyPoints?: IntFieldUpdateOperationsInput | number
    totalSpent?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    additionalLocation?: NullableStringFieldUpdateOperationsInput | string | null
    isDependent?: BoolFieldUpdateOperationsInput | boolean
    lastSale?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    saleCount?: IntFieldUpdateOperationsInput | number
    sector?: NullableStringFieldUpdateOperationsInput | string | null
    discounts?: CustomerDiscountUpdateManyWithoutCustomerNestedInput
    parent?: CustomerUpdateOneWithoutDependentsNestedInput
    sales?: SaleUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateWithoutDependentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    location?: StringFieldUpdateOperationsInput | string
    district?: StringFieldUpdateOperationsInput | string
    province?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    birthDay?: IntFieldUpdateOperationsInput | number
    birthMonth?: IntFieldUpdateOperationsInput | number
    birthYear?: NullableIntFieldUpdateOperationsInput | number | null
    loyaltyPoints?: IntFieldUpdateOperationsInput | number
    totalSpent?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    additionalLocation?: NullableStringFieldUpdateOperationsInput | string | null
    isDependent?: BoolFieldUpdateOperationsInput | boolean
    lastSale?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    saleCount?: IntFieldUpdateOperationsInput | number
    sector?: NullableStringFieldUpdateOperationsInput | string | null
    discounts?: CustomerDiscountUncheckedUpdateManyWithoutCustomerNestedInput
    sales?: SaleUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUpsertWithWhereUniqueWithoutParentInput = {
    where: CustomerWhereUniqueInput
    update: XOR<CustomerUpdateWithoutParentInput, CustomerUncheckedUpdateWithoutParentInput>
    create: XOR<CustomerCreateWithoutParentInput, CustomerUncheckedCreateWithoutParentInput>
  }

  export type CustomerUpdateWithWhereUniqueWithoutParentInput = {
    where: CustomerWhereUniqueInput
    data: XOR<CustomerUpdateWithoutParentInput, CustomerUncheckedUpdateWithoutParentInput>
  }

  export type CustomerUpdateManyWithWhereWithoutParentInput = {
    where: CustomerScalarWhereInput
    data: XOR<CustomerUpdateManyMutationInput, CustomerUncheckedUpdateManyWithoutParentInput>
  }

  export type CustomerScalarWhereInput = {
    AND?: CustomerScalarWhereInput | CustomerScalarWhereInput[]
    OR?: CustomerScalarWhereInput[]
    NOT?: CustomerScalarWhereInput | CustomerScalarWhereInput[]
    id?: StringFilter<"Customer"> | string
    fullName?: StringFilter<"Customer"> | string
    gender?: EnumGenderFilter<"Customer"> | $Enums.Gender
    location?: StringFilter<"Customer"> | string
    district?: StringFilter<"Customer"> | string
    province?: StringFilter<"Customer"> | string
    phone?: StringNullableFilter<"Customer"> | string | null
    email?: StringNullableFilter<"Customer"> | string | null
    birthDay?: IntFilter<"Customer"> | number
    birthMonth?: IntFilter<"Customer"> | number
    birthYear?: IntNullableFilter<"Customer"> | number | null
    loyaltyPoints?: IntFilter<"Customer"> | number
    totalSpent?: DecimalFilter<"Customer"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"Customer"> | Date | string
    updatedAt?: DateTimeFilter<"Customer"> | Date | string
    isActive?: BoolFilter<"Customer"> | boolean
    additionalLocation?: StringNullableFilter<"Customer"> | string | null
    isDependent?: BoolFilter<"Customer"> | boolean
    lastSale?: DateTimeNullableFilter<"Customer"> | Date | string | null
    parentId?: StringNullableFilter<"Customer"> | string | null
    saleCount?: IntFilter<"Customer"> | number
    sector?: StringNullableFilter<"Customer"> | string | null
  }

  export type SaleUpsertWithWhereUniqueWithoutCustomerInput = {
    where: SaleWhereUniqueInput
    update: XOR<SaleUpdateWithoutCustomerInput, SaleUncheckedUpdateWithoutCustomerInput>
    create: XOR<SaleCreateWithoutCustomerInput, SaleUncheckedCreateWithoutCustomerInput>
  }

  export type SaleUpdateWithWhereUniqueWithoutCustomerInput = {
    where: SaleWhereUniqueInput
    data: XOR<SaleUpdateWithoutCustomerInput, SaleUncheckedUpdateWithoutCustomerInput>
  }

  export type SaleUpdateManyWithWhereWithoutCustomerInput = {
    where: SaleScalarWhereInput
    data: XOR<SaleUpdateManyMutationInput, SaleUncheckedUpdateManyWithoutCustomerInput>
  }

  export type SaleServiceCreateWithoutServiceInput = {
    id?: string
    quantity?: number
    unitPrice: Decimal | DecimalJsLike | number | string
    totalPrice: Decimal | DecimalJsLike | number | string
    isChild?: boolean
    isCombined?: boolean
    addShampoo?: boolean
    createdAt?: Date | string
    sale: SaleCreateNestedOneWithoutServicesInput
  }

  export type SaleServiceUncheckedCreateWithoutServiceInput = {
    id?: string
    saleId: string
    quantity?: number
    unitPrice: Decimal | DecimalJsLike | number | string
    totalPrice: Decimal | DecimalJsLike | number | string
    isChild?: boolean
    isCombined?: boolean
    addShampoo?: boolean
    createdAt?: Date | string
  }

  export type SaleServiceCreateOrConnectWithoutServiceInput = {
    where: SaleServiceWhereUniqueInput
    create: XOR<SaleServiceCreateWithoutServiceInput, SaleServiceUncheckedCreateWithoutServiceInput>
  }

  export type SaleServiceCreateManyServiceInputEnvelope = {
    data: SaleServiceCreateManyServiceInput | SaleServiceCreateManyServiceInput[]
    skipDuplicates?: boolean
  }

  export type SaleServiceUpsertWithWhereUniqueWithoutServiceInput = {
    where: SaleServiceWhereUniqueInput
    update: XOR<SaleServiceUpdateWithoutServiceInput, SaleServiceUncheckedUpdateWithoutServiceInput>
    create: XOR<SaleServiceCreateWithoutServiceInput, SaleServiceUncheckedCreateWithoutServiceInput>
  }

  export type SaleServiceUpdateWithWhereUniqueWithoutServiceInput = {
    where: SaleServiceWhereUniqueInput
    data: XOR<SaleServiceUpdateWithoutServiceInput, SaleServiceUncheckedUpdateWithoutServiceInput>
  }

  export type SaleServiceUpdateManyWithWhereWithoutServiceInput = {
    where: SaleServiceScalarWhereInput
    data: XOR<SaleServiceUpdateManyMutationInput, SaleServiceUncheckedUpdateManyWithoutServiceInput>
  }

  export type SaleServiceScalarWhereInput = {
    AND?: SaleServiceScalarWhereInput | SaleServiceScalarWhereInput[]
    OR?: SaleServiceScalarWhereInput[]
    NOT?: SaleServiceScalarWhereInput | SaleServiceScalarWhereInput[]
    id?: StringFilter<"SaleService"> | string
    saleId?: StringFilter<"SaleService"> | string
    serviceId?: StringFilter<"SaleService"> | string
    quantity?: IntFilter<"SaleService"> | number
    unitPrice?: DecimalFilter<"SaleService"> | Decimal | DecimalJsLike | number | string
    totalPrice?: DecimalFilter<"SaleService"> | Decimal | DecimalJsLike | number | string
    isChild?: BoolFilter<"SaleService"> | boolean
    isCombined?: BoolFilter<"SaleService"> | boolean
    addShampoo?: BoolFilter<"SaleService"> | boolean
    createdAt?: DateTimeFilter<"SaleService"> | Date | string
  }

  export type SaleDiscountCreateWithoutSaleInput = {
    id?: string
    discountAmount: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    discountRule: DiscountRuleCreateNestedOneWithoutSaleDiscountsInput
  }

  export type SaleDiscountUncheckedCreateWithoutSaleInput = {
    id?: string
    discountRuleId: string
    discountAmount: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
  }

  export type SaleDiscountCreateOrConnectWithoutSaleInput = {
    where: SaleDiscountWhereUniqueInput
    create: XOR<SaleDiscountCreateWithoutSaleInput, SaleDiscountUncheckedCreateWithoutSaleInput>
  }

  export type SaleDiscountCreateManySaleInputEnvelope = {
    data: SaleDiscountCreateManySaleInput | SaleDiscountCreateManySaleInput[]
    skipDuplicates?: boolean
  }

  export type SaleServiceCreateWithoutSaleInput = {
    id?: string
    quantity?: number
    unitPrice: Decimal | DecimalJsLike | number | string
    totalPrice: Decimal | DecimalJsLike | number | string
    isChild?: boolean
    isCombined?: boolean
    addShampoo?: boolean
    createdAt?: Date | string
    service: ServiceCreateNestedOneWithoutSaleServicesInput
  }

  export type SaleServiceUncheckedCreateWithoutSaleInput = {
    id?: string
    serviceId: string
    quantity?: number
    unitPrice: Decimal | DecimalJsLike | number | string
    totalPrice: Decimal | DecimalJsLike | number | string
    isChild?: boolean
    isCombined?: boolean
    addShampoo?: boolean
    createdAt?: Date | string
  }

  export type SaleServiceCreateOrConnectWithoutSaleInput = {
    where: SaleServiceWhereUniqueInput
    create: XOR<SaleServiceCreateWithoutSaleInput, SaleServiceUncheckedCreateWithoutSaleInput>
  }

  export type SaleServiceCreateManySaleInputEnvelope = {
    data: SaleServiceCreateManySaleInput | SaleServiceCreateManySaleInput[]
    skipDuplicates?: boolean
  }

  export type SaleProductCreateWithoutSaleInput = {
    id?: string
    quantity?: number
    unitPrice: Decimal | DecimalJsLike | number | string
    totalPrice: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    product: ProductCreateNestedOneWithoutSaleProductsInput
  }

  export type SaleProductUncheckedCreateWithoutSaleInput = {
    id?: string
    productId: string
    quantity?: number
    unitPrice: Decimal | DecimalJsLike | number | string
    totalPrice: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
  }

  export type SaleProductCreateOrConnectWithoutSaleInput = {
    where: SaleProductWhereUniqueInput
    create: XOR<SaleProductCreateWithoutSaleInput, SaleProductUncheckedCreateWithoutSaleInput>
  }

  export type SaleProductCreateManySaleInputEnvelope = {
    data: SaleProductCreateManySaleInput | SaleProductCreateManySaleInput[]
    skipDuplicates?: boolean
  }

  export type SaleStaffCreateWithoutSaleInput = {
    id?: string
    customName?: string | null
    serviceId?: string | null
    createdAt?: Date | string
    staff?: UserCreateNestedOneWithoutStaffSalesInput
  }

  export type SaleStaffUncheckedCreateWithoutSaleInput = {
    id?: string
    staffId?: string | null
    customName?: string | null
    serviceId?: string | null
    createdAt?: Date | string
  }

  export type SaleStaffCreateOrConnectWithoutSaleInput = {
    where: SaleStaffWhereUniqueInput
    create: XOR<SaleStaffCreateWithoutSaleInput, SaleStaffUncheckedCreateWithoutSaleInput>
  }

  export type SaleStaffCreateManySaleInputEnvelope = {
    data: SaleStaffCreateManySaleInput | SaleStaffCreateManySaleInput[]
    skipDuplicates?: boolean
  }

  export type SalePaymentCreateWithoutSaleInput = {
    id?: string
    paymentMethod: $Enums.PaymentMethod
    amount: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
  }

  export type SalePaymentUncheckedCreateWithoutSaleInput = {
    id?: string
    paymentMethod: $Enums.PaymentMethod
    amount: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
  }

  export type SalePaymentCreateOrConnectWithoutSaleInput = {
    where: SalePaymentWhereUniqueInput
    create: XOR<SalePaymentCreateWithoutSaleInput, SalePaymentUncheckedCreateWithoutSaleInput>
  }

  export type SalePaymentCreateManySaleInputEnvelope = {
    data: SalePaymentCreateManySaleInput | SalePaymentCreateManySaleInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutSalesInput = {
    id?: string
    name: string
    email?: string | null
    password: string
    role?: $Enums.Role
    phone: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    profilePicture?: string | null
    staffSales?: SaleStaffCreateNestedManyWithoutStaffInput
  }

  export type UserUncheckedCreateWithoutSalesInput = {
    id?: string
    name: string
    email?: string | null
    password: string
    role?: $Enums.Role
    phone: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    profilePicture?: string | null
    staffSales?: SaleStaffUncheckedCreateNestedManyWithoutStaffInput
  }

  export type UserCreateOrConnectWithoutSalesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSalesInput, UserUncheckedCreateWithoutSalesInput>
  }

  export type CustomerCreateWithoutSalesInput = {
    id?: string
    fullName: string
    gender: $Enums.Gender
    location: string
    district: string
    province: string
    phone?: string | null
    email?: string | null
    birthDay: number
    birthMonth: number
    birthYear?: number | null
    loyaltyPoints?: number
    totalSpent?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    isActive?: boolean
    additionalLocation?: string | null
    isDependent?: boolean
    lastSale?: Date | string | null
    saleCount?: number
    sector?: string | null
    discounts?: CustomerDiscountCreateNestedManyWithoutCustomerInput
    parent?: CustomerCreateNestedOneWithoutDependentsInput
    dependents?: CustomerCreateNestedManyWithoutParentInput
  }

  export type CustomerUncheckedCreateWithoutSalesInput = {
    id?: string
    fullName: string
    gender: $Enums.Gender
    location: string
    district: string
    province: string
    phone?: string | null
    email?: string | null
    birthDay: number
    birthMonth: number
    birthYear?: number | null
    loyaltyPoints?: number
    totalSpent?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    isActive?: boolean
    additionalLocation?: string | null
    isDependent?: boolean
    lastSale?: Date | string | null
    parentId?: string | null
    saleCount?: number
    sector?: string | null
    discounts?: CustomerDiscountUncheckedCreateNestedManyWithoutCustomerInput
    dependents?: CustomerUncheckedCreateNestedManyWithoutParentInput
  }

  export type CustomerCreateOrConnectWithoutSalesInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutSalesInput, CustomerUncheckedCreateWithoutSalesInput>
  }

  export type SaleDiscountUpsertWithWhereUniqueWithoutSaleInput = {
    where: SaleDiscountWhereUniqueInput
    update: XOR<SaleDiscountUpdateWithoutSaleInput, SaleDiscountUncheckedUpdateWithoutSaleInput>
    create: XOR<SaleDiscountCreateWithoutSaleInput, SaleDiscountUncheckedCreateWithoutSaleInput>
  }

  export type SaleDiscountUpdateWithWhereUniqueWithoutSaleInput = {
    where: SaleDiscountWhereUniqueInput
    data: XOR<SaleDiscountUpdateWithoutSaleInput, SaleDiscountUncheckedUpdateWithoutSaleInput>
  }

  export type SaleDiscountUpdateManyWithWhereWithoutSaleInput = {
    where: SaleDiscountScalarWhereInput
    data: XOR<SaleDiscountUpdateManyMutationInput, SaleDiscountUncheckedUpdateManyWithoutSaleInput>
  }

  export type SaleDiscountScalarWhereInput = {
    AND?: SaleDiscountScalarWhereInput | SaleDiscountScalarWhereInput[]
    OR?: SaleDiscountScalarWhereInput[]
    NOT?: SaleDiscountScalarWhereInput | SaleDiscountScalarWhereInput[]
    id?: StringFilter<"SaleDiscount"> | string
    saleId?: StringFilter<"SaleDiscount"> | string
    discountRuleId?: StringFilter<"SaleDiscount"> | string
    discountAmount?: DecimalFilter<"SaleDiscount"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"SaleDiscount"> | Date | string
  }

  export type SaleServiceUpsertWithWhereUniqueWithoutSaleInput = {
    where: SaleServiceWhereUniqueInput
    update: XOR<SaleServiceUpdateWithoutSaleInput, SaleServiceUncheckedUpdateWithoutSaleInput>
    create: XOR<SaleServiceCreateWithoutSaleInput, SaleServiceUncheckedCreateWithoutSaleInput>
  }

  export type SaleServiceUpdateWithWhereUniqueWithoutSaleInput = {
    where: SaleServiceWhereUniqueInput
    data: XOR<SaleServiceUpdateWithoutSaleInput, SaleServiceUncheckedUpdateWithoutSaleInput>
  }

  export type SaleServiceUpdateManyWithWhereWithoutSaleInput = {
    where: SaleServiceScalarWhereInput
    data: XOR<SaleServiceUpdateManyMutationInput, SaleServiceUncheckedUpdateManyWithoutSaleInput>
  }

  export type SaleProductUpsertWithWhereUniqueWithoutSaleInput = {
    where: SaleProductWhereUniqueInput
    update: XOR<SaleProductUpdateWithoutSaleInput, SaleProductUncheckedUpdateWithoutSaleInput>
    create: XOR<SaleProductCreateWithoutSaleInput, SaleProductUncheckedCreateWithoutSaleInput>
  }

  export type SaleProductUpdateWithWhereUniqueWithoutSaleInput = {
    where: SaleProductWhereUniqueInput
    data: XOR<SaleProductUpdateWithoutSaleInput, SaleProductUncheckedUpdateWithoutSaleInput>
  }

  export type SaleProductUpdateManyWithWhereWithoutSaleInput = {
    where: SaleProductScalarWhereInput
    data: XOR<SaleProductUpdateManyMutationInput, SaleProductUncheckedUpdateManyWithoutSaleInput>
  }

  export type SaleProductScalarWhereInput = {
    AND?: SaleProductScalarWhereInput | SaleProductScalarWhereInput[]
    OR?: SaleProductScalarWhereInput[]
    NOT?: SaleProductScalarWhereInput | SaleProductScalarWhereInput[]
    id?: StringFilter<"SaleProduct"> | string
    saleId?: StringFilter<"SaleProduct"> | string
    productId?: StringFilter<"SaleProduct"> | string
    quantity?: IntFilter<"SaleProduct"> | number
    unitPrice?: DecimalFilter<"SaleProduct"> | Decimal | DecimalJsLike | number | string
    totalPrice?: DecimalFilter<"SaleProduct"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"SaleProduct"> | Date | string
  }

  export type SaleStaffUpsertWithWhereUniqueWithoutSaleInput = {
    where: SaleStaffWhereUniqueInput
    update: XOR<SaleStaffUpdateWithoutSaleInput, SaleStaffUncheckedUpdateWithoutSaleInput>
    create: XOR<SaleStaffCreateWithoutSaleInput, SaleStaffUncheckedCreateWithoutSaleInput>
  }

  export type SaleStaffUpdateWithWhereUniqueWithoutSaleInput = {
    where: SaleStaffWhereUniqueInput
    data: XOR<SaleStaffUpdateWithoutSaleInput, SaleStaffUncheckedUpdateWithoutSaleInput>
  }

  export type SaleStaffUpdateManyWithWhereWithoutSaleInput = {
    where: SaleStaffScalarWhereInput
    data: XOR<SaleStaffUpdateManyMutationInput, SaleStaffUncheckedUpdateManyWithoutSaleInput>
  }

  export type SalePaymentUpsertWithWhereUniqueWithoutSaleInput = {
    where: SalePaymentWhereUniqueInput
    update: XOR<SalePaymentUpdateWithoutSaleInput, SalePaymentUncheckedUpdateWithoutSaleInput>
    create: XOR<SalePaymentCreateWithoutSaleInput, SalePaymentUncheckedCreateWithoutSaleInput>
  }

  export type SalePaymentUpdateWithWhereUniqueWithoutSaleInput = {
    where: SalePaymentWhereUniqueInput
    data: XOR<SalePaymentUpdateWithoutSaleInput, SalePaymentUncheckedUpdateWithoutSaleInput>
  }

  export type SalePaymentUpdateManyWithWhereWithoutSaleInput = {
    where: SalePaymentScalarWhereInput
    data: XOR<SalePaymentUpdateManyMutationInput, SalePaymentUncheckedUpdateManyWithoutSaleInput>
  }

  export type SalePaymentScalarWhereInput = {
    AND?: SalePaymentScalarWhereInput | SalePaymentScalarWhereInput[]
    OR?: SalePaymentScalarWhereInput[]
    NOT?: SalePaymentScalarWhereInput | SalePaymentScalarWhereInput[]
    id?: StringFilter<"SalePayment"> | string
    saleId?: StringFilter<"SalePayment"> | string
    paymentMethod?: EnumPaymentMethodFilter<"SalePayment"> | $Enums.PaymentMethod
    amount?: DecimalFilter<"SalePayment"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"SalePayment"> | Date | string
  }

  export type UserUpsertWithoutSalesInput = {
    update: XOR<UserUpdateWithoutSalesInput, UserUncheckedUpdateWithoutSalesInput>
    create: XOR<UserCreateWithoutSalesInput, UserUncheckedCreateWithoutSalesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSalesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSalesInput, UserUncheckedUpdateWithoutSalesInput>
  }

  export type UserUpdateWithoutSalesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    phone?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    staffSales?: SaleStaffUpdateManyWithoutStaffNestedInput
  }

  export type UserUncheckedUpdateWithoutSalesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    phone?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    staffSales?: SaleStaffUncheckedUpdateManyWithoutStaffNestedInput
  }

  export type CustomerUpsertWithoutSalesInput = {
    update: XOR<CustomerUpdateWithoutSalesInput, CustomerUncheckedUpdateWithoutSalesInput>
    create: XOR<CustomerCreateWithoutSalesInput, CustomerUncheckedCreateWithoutSalesInput>
    where?: CustomerWhereInput
  }

  export type CustomerUpdateToOneWithWhereWithoutSalesInput = {
    where?: CustomerWhereInput
    data: XOR<CustomerUpdateWithoutSalesInput, CustomerUncheckedUpdateWithoutSalesInput>
  }

  export type CustomerUpdateWithoutSalesInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    location?: StringFieldUpdateOperationsInput | string
    district?: StringFieldUpdateOperationsInput | string
    province?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    birthDay?: IntFieldUpdateOperationsInput | number
    birthMonth?: IntFieldUpdateOperationsInput | number
    birthYear?: NullableIntFieldUpdateOperationsInput | number | null
    loyaltyPoints?: IntFieldUpdateOperationsInput | number
    totalSpent?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    additionalLocation?: NullableStringFieldUpdateOperationsInput | string | null
    isDependent?: BoolFieldUpdateOperationsInput | boolean
    lastSale?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    saleCount?: IntFieldUpdateOperationsInput | number
    sector?: NullableStringFieldUpdateOperationsInput | string | null
    discounts?: CustomerDiscountUpdateManyWithoutCustomerNestedInput
    parent?: CustomerUpdateOneWithoutDependentsNestedInput
    dependents?: CustomerUpdateManyWithoutParentNestedInput
  }

  export type CustomerUncheckedUpdateWithoutSalesInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    location?: StringFieldUpdateOperationsInput | string
    district?: StringFieldUpdateOperationsInput | string
    province?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    birthDay?: IntFieldUpdateOperationsInput | number
    birthMonth?: IntFieldUpdateOperationsInput | number
    birthYear?: NullableIntFieldUpdateOperationsInput | number | null
    loyaltyPoints?: IntFieldUpdateOperationsInput | number
    totalSpent?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    additionalLocation?: NullableStringFieldUpdateOperationsInput | string | null
    isDependent?: BoolFieldUpdateOperationsInput | boolean
    lastSale?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    saleCount?: IntFieldUpdateOperationsInput | number
    sector?: NullableStringFieldUpdateOperationsInput | string | null
    discounts?: CustomerDiscountUncheckedUpdateManyWithoutCustomerNestedInput
    dependents?: CustomerUncheckedUpdateManyWithoutParentNestedInput
  }

  export type SaleCreateWithoutServicesInput = {
    id?: string
    saleDate?: Date | string
    totalAmount: Decimal | DecimalJsLike | number | string
    discountAmount?: Decimal | DecimalJsLike | number | string
    finalAmount: Decimal | DecimalJsLike | number | string
    loyaltyPointsEarned?: number
    notes?: string | null
    isCompleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    birthMonthDiscount?: boolean
    ownShampooDiscount?: boolean
    paymentMethod?: $Enums.PaymentMethod
    discounts?: SaleDiscountCreateNestedManyWithoutSaleInput
    products?: SaleProductCreateNestedManyWithoutSaleInput
    staff?: SaleStaffCreateNestedManyWithoutSaleInput
    payments?: SalePaymentCreateNestedManyWithoutSaleInput
    createdBy: UserCreateNestedOneWithoutSalesInput
    customer: CustomerCreateNestedOneWithoutSalesInput
  }

  export type SaleUncheckedCreateWithoutServicesInput = {
    id?: string
    customerId: string
    saleDate?: Date | string
    totalAmount: Decimal | DecimalJsLike | number | string
    discountAmount?: Decimal | DecimalJsLike | number | string
    finalAmount: Decimal | DecimalJsLike | number | string
    loyaltyPointsEarned?: number
    notes?: string | null
    isCompleted?: boolean
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
    birthMonthDiscount?: boolean
    ownShampooDiscount?: boolean
    paymentMethod?: $Enums.PaymentMethod
    discounts?: SaleDiscountUncheckedCreateNestedManyWithoutSaleInput
    products?: SaleProductUncheckedCreateNestedManyWithoutSaleInput
    staff?: SaleStaffUncheckedCreateNestedManyWithoutSaleInput
    payments?: SalePaymentUncheckedCreateNestedManyWithoutSaleInput
  }

  export type SaleCreateOrConnectWithoutServicesInput = {
    where: SaleWhereUniqueInput
    create: XOR<SaleCreateWithoutServicesInput, SaleUncheckedCreateWithoutServicesInput>
  }

  export type ServiceCreateWithoutSaleServicesInput = {
    id?: string
    name: string
    category: $Enums.ServiceCategory
    description?: string | null
    singlePrice: Decimal | DecimalJsLike | number | string
    combinedPrice?: Decimal | DecimalJsLike | number | string | null
    childPrice?: Decimal | DecimalJsLike | number | string | null
    childCombinedPrice?: Decimal | DecimalJsLike | number | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ServiceUncheckedCreateWithoutSaleServicesInput = {
    id?: string
    name: string
    category: $Enums.ServiceCategory
    description?: string | null
    singlePrice: Decimal | DecimalJsLike | number | string
    combinedPrice?: Decimal | DecimalJsLike | number | string | null
    childPrice?: Decimal | DecimalJsLike | number | string | null
    childCombinedPrice?: Decimal | DecimalJsLike | number | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ServiceCreateOrConnectWithoutSaleServicesInput = {
    where: ServiceWhereUniqueInput
    create: XOR<ServiceCreateWithoutSaleServicesInput, ServiceUncheckedCreateWithoutSaleServicesInput>
  }

  export type SaleUpsertWithoutServicesInput = {
    update: XOR<SaleUpdateWithoutServicesInput, SaleUncheckedUpdateWithoutServicesInput>
    create: XOR<SaleCreateWithoutServicesInput, SaleUncheckedCreateWithoutServicesInput>
    where?: SaleWhereInput
  }

  export type SaleUpdateToOneWithWhereWithoutServicesInput = {
    where?: SaleWhereInput
    data: XOR<SaleUpdateWithoutServicesInput, SaleUncheckedUpdateWithoutServicesInput>
  }

  export type SaleUpdateWithoutServicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    saleDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    finalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    loyaltyPointsEarned?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    birthMonthDiscount?: BoolFieldUpdateOperationsInput | boolean
    ownShampooDiscount?: BoolFieldUpdateOperationsInput | boolean
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    discounts?: SaleDiscountUpdateManyWithoutSaleNestedInput
    products?: SaleProductUpdateManyWithoutSaleNestedInput
    staff?: SaleStaffUpdateManyWithoutSaleNestedInput
    payments?: SalePaymentUpdateManyWithoutSaleNestedInput
    createdBy?: UserUpdateOneRequiredWithoutSalesNestedInput
    customer?: CustomerUpdateOneRequiredWithoutSalesNestedInput
  }

  export type SaleUncheckedUpdateWithoutServicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    saleDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    finalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    loyaltyPointsEarned?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    birthMonthDiscount?: BoolFieldUpdateOperationsInput | boolean
    ownShampooDiscount?: BoolFieldUpdateOperationsInput | boolean
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    discounts?: SaleDiscountUncheckedUpdateManyWithoutSaleNestedInput
    products?: SaleProductUncheckedUpdateManyWithoutSaleNestedInput
    staff?: SaleStaffUncheckedUpdateManyWithoutSaleNestedInput
    payments?: SalePaymentUncheckedUpdateManyWithoutSaleNestedInput
  }

  export type ServiceUpsertWithoutSaleServicesInput = {
    update: XOR<ServiceUpdateWithoutSaleServicesInput, ServiceUncheckedUpdateWithoutSaleServicesInput>
    create: XOR<ServiceCreateWithoutSaleServicesInput, ServiceUncheckedCreateWithoutSaleServicesInput>
    where?: ServiceWhereInput
  }

  export type ServiceUpdateToOneWithWhereWithoutSaleServicesInput = {
    where?: ServiceWhereInput
    data: XOR<ServiceUpdateWithoutSaleServicesInput, ServiceUncheckedUpdateWithoutSaleServicesInput>
  }

  export type ServiceUpdateWithoutSaleServicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: EnumServiceCategoryFieldUpdateOperationsInput | $Enums.ServiceCategory
    description?: NullableStringFieldUpdateOperationsInput | string | null
    singlePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    combinedPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    childPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    childCombinedPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceUncheckedUpdateWithoutSaleServicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: EnumServiceCategoryFieldUpdateOperationsInput | $Enums.ServiceCategory
    description?: NullableStringFieldUpdateOperationsInput | string | null
    singlePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    combinedPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    childPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    childCombinedPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SaleCreateWithoutStaffInput = {
    id?: string
    saleDate?: Date | string
    totalAmount: Decimal | DecimalJsLike | number | string
    discountAmount?: Decimal | DecimalJsLike | number | string
    finalAmount: Decimal | DecimalJsLike | number | string
    loyaltyPointsEarned?: number
    notes?: string | null
    isCompleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    birthMonthDiscount?: boolean
    ownShampooDiscount?: boolean
    paymentMethod?: $Enums.PaymentMethod
    discounts?: SaleDiscountCreateNestedManyWithoutSaleInput
    services?: SaleServiceCreateNestedManyWithoutSaleInput
    products?: SaleProductCreateNestedManyWithoutSaleInput
    payments?: SalePaymentCreateNestedManyWithoutSaleInput
    createdBy: UserCreateNestedOneWithoutSalesInput
    customer: CustomerCreateNestedOneWithoutSalesInput
  }

  export type SaleUncheckedCreateWithoutStaffInput = {
    id?: string
    customerId: string
    saleDate?: Date | string
    totalAmount: Decimal | DecimalJsLike | number | string
    discountAmount?: Decimal | DecimalJsLike | number | string
    finalAmount: Decimal | DecimalJsLike | number | string
    loyaltyPointsEarned?: number
    notes?: string | null
    isCompleted?: boolean
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
    birthMonthDiscount?: boolean
    ownShampooDiscount?: boolean
    paymentMethod?: $Enums.PaymentMethod
    discounts?: SaleDiscountUncheckedCreateNestedManyWithoutSaleInput
    services?: SaleServiceUncheckedCreateNestedManyWithoutSaleInput
    products?: SaleProductUncheckedCreateNestedManyWithoutSaleInput
    payments?: SalePaymentUncheckedCreateNestedManyWithoutSaleInput
  }

  export type SaleCreateOrConnectWithoutStaffInput = {
    where: SaleWhereUniqueInput
    create: XOR<SaleCreateWithoutStaffInput, SaleUncheckedCreateWithoutStaffInput>
  }

  export type UserCreateWithoutStaffSalesInput = {
    id?: string
    name: string
    email?: string | null
    password: string
    role?: $Enums.Role
    phone: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    profilePicture?: string | null
    sales?: SaleCreateNestedManyWithoutCreatedByInput
  }

  export type UserUncheckedCreateWithoutStaffSalesInput = {
    id?: string
    name: string
    email?: string | null
    password: string
    role?: $Enums.Role
    phone: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    profilePicture?: string | null
    sales?: SaleUncheckedCreateNestedManyWithoutCreatedByInput
  }

  export type UserCreateOrConnectWithoutStaffSalesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutStaffSalesInput, UserUncheckedCreateWithoutStaffSalesInput>
  }

  export type SaleUpsertWithoutStaffInput = {
    update: XOR<SaleUpdateWithoutStaffInput, SaleUncheckedUpdateWithoutStaffInput>
    create: XOR<SaleCreateWithoutStaffInput, SaleUncheckedCreateWithoutStaffInput>
    where?: SaleWhereInput
  }

  export type SaleUpdateToOneWithWhereWithoutStaffInput = {
    where?: SaleWhereInput
    data: XOR<SaleUpdateWithoutStaffInput, SaleUncheckedUpdateWithoutStaffInput>
  }

  export type SaleUpdateWithoutStaffInput = {
    id?: StringFieldUpdateOperationsInput | string
    saleDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    finalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    loyaltyPointsEarned?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    birthMonthDiscount?: BoolFieldUpdateOperationsInput | boolean
    ownShampooDiscount?: BoolFieldUpdateOperationsInput | boolean
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    discounts?: SaleDiscountUpdateManyWithoutSaleNestedInput
    services?: SaleServiceUpdateManyWithoutSaleNestedInput
    products?: SaleProductUpdateManyWithoutSaleNestedInput
    payments?: SalePaymentUpdateManyWithoutSaleNestedInput
    createdBy?: UserUpdateOneRequiredWithoutSalesNestedInput
    customer?: CustomerUpdateOneRequiredWithoutSalesNestedInput
  }

  export type SaleUncheckedUpdateWithoutStaffInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    saleDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    finalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    loyaltyPointsEarned?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    birthMonthDiscount?: BoolFieldUpdateOperationsInput | boolean
    ownShampooDiscount?: BoolFieldUpdateOperationsInput | boolean
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    discounts?: SaleDiscountUncheckedUpdateManyWithoutSaleNestedInput
    services?: SaleServiceUncheckedUpdateManyWithoutSaleNestedInput
    products?: SaleProductUncheckedUpdateManyWithoutSaleNestedInput
    payments?: SalePaymentUncheckedUpdateManyWithoutSaleNestedInput
  }

  export type UserUpsertWithoutStaffSalesInput = {
    update: XOR<UserUpdateWithoutStaffSalesInput, UserUncheckedUpdateWithoutStaffSalesInput>
    create: XOR<UserCreateWithoutStaffSalesInput, UserUncheckedCreateWithoutStaffSalesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutStaffSalesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutStaffSalesInput, UserUncheckedUpdateWithoutStaffSalesInput>
  }

  export type UserUpdateWithoutStaffSalesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    phone?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    sales?: SaleUpdateManyWithoutCreatedByNestedInput
  }

  export type UserUncheckedUpdateWithoutStaffSalesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    phone?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    sales?: SaleUncheckedUpdateManyWithoutCreatedByNestedInput
  }

  export type CustomerDiscountCreateWithoutDiscountRuleInput = {
    id?: string
    usedAt?: Date | string
    discountAmount: Decimal | DecimalJsLike | number | string
    customer: CustomerCreateNestedOneWithoutDiscountsInput
  }

  export type CustomerDiscountUncheckedCreateWithoutDiscountRuleInput = {
    id?: string
    customerId: string
    usedAt?: Date | string
    discountAmount: Decimal | DecimalJsLike | number | string
  }

  export type CustomerDiscountCreateOrConnectWithoutDiscountRuleInput = {
    where: CustomerDiscountWhereUniqueInput
    create: XOR<CustomerDiscountCreateWithoutDiscountRuleInput, CustomerDiscountUncheckedCreateWithoutDiscountRuleInput>
  }

  export type CustomerDiscountCreateManyDiscountRuleInputEnvelope = {
    data: CustomerDiscountCreateManyDiscountRuleInput | CustomerDiscountCreateManyDiscountRuleInput[]
    skipDuplicates?: boolean
  }

  export type SaleDiscountCreateWithoutDiscountRuleInput = {
    id?: string
    discountAmount: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    sale: SaleCreateNestedOneWithoutDiscountsInput
  }

  export type SaleDiscountUncheckedCreateWithoutDiscountRuleInput = {
    id?: string
    saleId: string
    discountAmount: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
  }

  export type SaleDiscountCreateOrConnectWithoutDiscountRuleInput = {
    where: SaleDiscountWhereUniqueInput
    create: XOR<SaleDiscountCreateWithoutDiscountRuleInput, SaleDiscountUncheckedCreateWithoutDiscountRuleInput>
  }

  export type SaleDiscountCreateManyDiscountRuleInputEnvelope = {
    data: SaleDiscountCreateManyDiscountRuleInput | SaleDiscountCreateManyDiscountRuleInput[]
    skipDuplicates?: boolean
  }

  export type CustomerDiscountUpsertWithWhereUniqueWithoutDiscountRuleInput = {
    where: CustomerDiscountWhereUniqueInput
    update: XOR<CustomerDiscountUpdateWithoutDiscountRuleInput, CustomerDiscountUncheckedUpdateWithoutDiscountRuleInput>
    create: XOR<CustomerDiscountCreateWithoutDiscountRuleInput, CustomerDiscountUncheckedCreateWithoutDiscountRuleInput>
  }

  export type CustomerDiscountUpdateWithWhereUniqueWithoutDiscountRuleInput = {
    where: CustomerDiscountWhereUniqueInput
    data: XOR<CustomerDiscountUpdateWithoutDiscountRuleInput, CustomerDiscountUncheckedUpdateWithoutDiscountRuleInput>
  }

  export type CustomerDiscountUpdateManyWithWhereWithoutDiscountRuleInput = {
    where: CustomerDiscountScalarWhereInput
    data: XOR<CustomerDiscountUpdateManyMutationInput, CustomerDiscountUncheckedUpdateManyWithoutDiscountRuleInput>
  }

  export type SaleDiscountUpsertWithWhereUniqueWithoutDiscountRuleInput = {
    where: SaleDiscountWhereUniqueInput
    update: XOR<SaleDiscountUpdateWithoutDiscountRuleInput, SaleDiscountUncheckedUpdateWithoutDiscountRuleInput>
    create: XOR<SaleDiscountCreateWithoutDiscountRuleInput, SaleDiscountUncheckedCreateWithoutDiscountRuleInput>
  }

  export type SaleDiscountUpdateWithWhereUniqueWithoutDiscountRuleInput = {
    where: SaleDiscountWhereUniqueInput
    data: XOR<SaleDiscountUpdateWithoutDiscountRuleInput, SaleDiscountUncheckedUpdateWithoutDiscountRuleInput>
  }

  export type SaleDiscountUpdateManyWithWhereWithoutDiscountRuleInput = {
    where: SaleDiscountScalarWhereInput
    data: XOR<SaleDiscountUpdateManyMutationInput, SaleDiscountUncheckedUpdateManyWithoutDiscountRuleInput>
  }

  export type DiscountRuleCreateWithoutSaleDiscountsInput = {
    id?: string
    name: string
    type: $Enums.DiscountType
    value: Decimal | DecimalJsLike | number | string
    isPercentage?: boolean
    isActive?: boolean
    description?: string | null
    minAmount?: Decimal | DecimalJsLike | number | string | null
    maxDiscount?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    customerDiscounts?: CustomerDiscountCreateNestedManyWithoutDiscountRuleInput
  }

  export type DiscountRuleUncheckedCreateWithoutSaleDiscountsInput = {
    id?: string
    name: string
    type: $Enums.DiscountType
    value: Decimal | DecimalJsLike | number | string
    isPercentage?: boolean
    isActive?: boolean
    description?: string | null
    minAmount?: Decimal | DecimalJsLike | number | string | null
    maxDiscount?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    customerDiscounts?: CustomerDiscountUncheckedCreateNestedManyWithoutDiscountRuleInput
  }

  export type DiscountRuleCreateOrConnectWithoutSaleDiscountsInput = {
    where: DiscountRuleWhereUniqueInput
    create: XOR<DiscountRuleCreateWithoutSaleDiscountsInput, DiscountRuleUncheckedCreateWithoutSaleDiscountsInput>
  }

  export type SaleCreateWithoutDiscountsInput = {
    id?: string
    saleDate?: Date | string
    totalAmount: Decimal | DecimalJsLike | number | string
    discountAmount?: Decimal | DecimalJsLike | number | string
    finalAmount: Decimal | DecimalJsLike | number | string
    loyaltyPointsEarned?: number
    notes?: string | null
    isCompleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    birthMonthDiscount?: boolean
    ownShampooDiscount?: boolean
    paymentMethod?: $Enums.PaymentMethod
    services?: SaleServiceCreateNestedManyWithoutSaleInput
    products?: SaleProductCreateNestedManyWithoutSaleInput
    staff?: SaleStaffCreateNestedManyWithoutSaleInput
    payments?: SalePaymentCreateNestedManyWithoutSaleInput
    createdBy: UserCreateNestedOneWithoutSalesInput
    customer: CustomerCreateNestedOneWithoutSalesInput
  }

  export type SaleUncheckedCreateWithoutDiscountsInput = {
    id?: string
    customerId: string
    saleDate?: Date | string
    totalAmount: Decimal | DecimalJsLike | number | string
    discountAmount?: Decimal | DecimalJsLike | number | string
    finalAmount: Decimal | DecimalJsLike | number | string
    loyaltyPointsEarned?: number
    notes?: string | null
    isCompleted?: boolean
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
    birthMonthDiscount?: boolean
    ownShampooDiscount?: boolean
    paymentMethod?: $Enums.PaymentMethod
    services?: SaleServiceUncheckedCreateNestedManyWithoutSaleInput
    products?: SaleProductUncheckedCreateNestedManyWithoutSaleInput
    staff?: SaleStaffUncheckedCreateNestedManyWithoutSaleInput
    payments?: SalePaymentUncheckedCreateNestedManyWithoutSaleInput
  }

  export type SaleCreateOrConnectWithoutDiscountsInput = {
    where: SaleWhereUniqueInput
    create: XOR<SaleCreateWithoutDiscountsInput, SaleUncheckedCreateWithoutDiscountsInput>
  }

  export type DiscountRuleUpsertWithoutSaleDiscountsInput = {
    update: XOR<DiscountRuleUpdateWithoutSaleDiscountsInput, DiscountRuleUncheckedUpdateWithoutSaleDiscountsInput>
    create: XOR<DiscountRuleCreateWithoutSaleDiscountsInput, DiscountRuleUncheckedCreateWithoutSaleDiscountsInput>
    where?: DiscountRuleWhereInput
  }

  export type DiscountRuleUpdateToOneWithWhereWithoutSaleDiscountsInput = {
    where?: DiscountRuleWhereInput
    data: XOR<DiscountRuleUpdateWithoutSaleDiscountsInput, DiscountRuleUncheckedUpdateWithoutSaleDiscountsInput>
  }

  export type DiscountRuleUpdateWithoutSaleDiscountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumDiscountTypeFieldUpdateOperationsInput | $Enums.DiscountType
    value?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isPercentage?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    minAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    maxDiscount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customerDiscounts?: CustomerDiscountUpdateManyWithoutDiscountRuleNestedInput
  }

  export type DiscountRuleUncheckedUpdateWithoutSaleDiscountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumDiscountTypeFieldUpdateOperationsInput | $Enums.DiscountType
    value?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isPercentage?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    minAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    maxDiscount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customerDiscounts?: CustomerDiscountUncheckedUpdateManyWithoutDiscountRuleNestedInput
  }

  export type SaleUpsertWithoutDiscountsInput = {
    update: XOR<SaleUpdateWithoutDiscountsInput, SaleUncheckedUpdateWithoutDiscountsInput>
    create: XOR<SaleCreateWithoutDiscountsInput, SaleUncheckedCreateWithoutDiscountsInput>
    where?: SaleWhereInput
  }

  export type SaleUpdateToOneWithWhereWithoutDiscountsInput = {
    where?: SaleWhereInput
    data: XOR<SaleUpdateWithoutDiscountsInput, SaleUncheckedUpdateWithoutDiscountsInput>
  }

  export type SaleUpdateWithoutDiscountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    saleDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    finalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    loyaltyPointsEarned?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    birthMonthDiscount?: BoolFieldUpdateOperationsInput | boolean
    ownShampooDiscount?: BoolFieldUpdateOperationsInput | boolean
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    services?: SaleServiceUpdateManyWithoutSaleNestedInput
    products?: SaleProductUpdateManyWithoutSaleNestedInput
    staff?: SaleStaffUpdateManyWithoutSaleNestedInput
    payments?: SalePaymentUpdateManyWithoutSaleNestedInput
    createdBy?: UserUpdateOneRequiredWithoutSalesNestedInput
    customer?: CustomerUpdateOneRequiredWithoutSalesNestedInput
  }

  export type SaleUncheckedUpdateWithoutDiscountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    saleDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    finalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    loyaltyPointsEarned?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    birthMonthDiscount?: BoolFieldUpdateOperationsInput | boolean
    ownShampooDiscount?: BoolFieldUpdateOperationsInput | boolean
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    services?: SaleServiceUncheckedUpdateManyWithoutSaleNestedInput
    products?: SaleProductUncheckedUpdateManyWithoutSaleNestedInput
    staff?: SaleStaffUncheckedUpdateManyWithoutSaleNestedInput
    payments?: SalePaymentUncheckedUpdateManyWithoutSaleNestedInput
  }

  export type CustomerCreateWithoutDiscountsInput = {
    id?: string
    fullName: string
    gender: $Enums.Gender
    location: string
    district: string
    province: string
    phone?: string | null
    email?: string | null
    birthDay: number
    birthMonth: number
    birthYear?: number | null
    loyaltyPoints?: number
    totalSpent?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    isActive?: boolean
    additionalLocation?: string | null
    isDependent?: boolean
    lastSale?: Date | string | null
    saleCount?: number
    sector?: string | null
    parent?: CustomerCreateNestedOneWithoutDependentsInput
    dependents?: CustomerCreateNestedManyWithoutParentInput
    sales?: SaleCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateWithoutDiscountsInput = {
    id?: string
    fullName: string
    gender: $Enums.Gender
    location: string
    district: string
    province: string
    phone?: string | null
    email?: string | null
    birthDay: number
    birthMonth: number
    birthYear?: number | null
    loyaltyPoints?: number
    totalSpent?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    isActive?: boolean
    additionalLocation?: string | null
    isDependent?: boolean
    lastSale?: Date | string | null
    parentId?: string | null
    saleCount?: number
    sector?: string | null
    dependents?: CustomerUncheckedCreateNestedManyWithoutParentInput
    sales?: SaleUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerCreateOrConnectWithoutDiscountsInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutDiscountsInput, CustomerUncheckedCreateWithoutDiscountsInput>
  }

  export type DiscountRuleCreateWithoutCustomerDiscountsInput = {
    id?: string
    name: string
    type: $Enums.DiscountType
    value: Decimal | DecimalJsLike | number | string
    isPercentage?: boolean
    isActive?: boolean
    description?: string | null
    minAmount?: Decimal | DecimalJsLike | number | string | null
    maxDiscount?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    saleDiscounts?: SaleDiscountCreateNestedManyWithoutDiscountRuleInput
  }

  export type DiscountRuleUncheckedCreateWithoutCustomerDiscountsInput = {
    id?: string
    name: string
    type: $Enums.DiscountType
    value: Decimal | DecimalJsLike | number | string
    isPercentage?: boolean
    isActive?: boolean
    description?: string | null
    minAmount?: Decimal | DecimalJsLike | number | string | null
    maxDiscount?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    saleDiscounts?: SaleDiscountUncheckedCreateNestedManyWithoutDiscountRuleInput
  }

  export type DiscountRuleCreateOrConnectWithoutCustomerDiscountsInput = {
    where: DiscountRuleWhereUniqueInput
    create: XOR<DiscountRuleCreateWithoutCustomerDiscountsInput, DiscountRuleUncheckedCreateWithoutCustomerDiscountsInput>
  }

  export type CustomerUpsertWithoutDiscountsInput = {
    update: XOR<CustomerUpdateWithoutDiscountsInput, CustomerUncheckedUpdateWithoutDiscountsInput>
    create: XOR<CustomerCreateWithoutDiscountsInput, CustomerUncheckedCreateWithoutDiscountsInput>
    where?: CustomerWhereInput
  }

  export type CustomerUpdateToOneWithWhereWithoutDiscountsInput = {
    where?: CustomerWhereInput
    data: XOR<CustomerUpdateWithoutDiscountsInput, CustomerUncheckedUpdateWithoutDiscountsInput>
  }

  export type CustomerUpdateWithoutDiscountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    location?: StringFieldUpdateOperationsInput | string
    district?: StringFieldUpdateOperationsInput | string
    province?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    birthDay?: IntFieldUpdateOperationsInput | number
    birthMonth?: IntFieldUpdateOperationsInput | number
    birthYear?: NullableIntFieldUpdateOperationsInput | number | null
    loyaltyPoints?: IntFieldUpdateOperationsInput | number
    totalSpent?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    additionalLocation?: NullableStringFieldUpdateOperationsInput | string | null
    isDependent?: BoolFieldUpdateOperationsInput | boolean
    lastSale?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    saleCount?: IntFieldUpdateOperationsInput | number
    sector?: NullableStringFieldUpdateOperationsInput | string | null
    parent?: CustomerUpdateOneWithoutDependentsNestedInput
    dependents?: CustomerUpdateManyWithoutParentNestedInput
    sales?: SaleUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateWithoutDiscountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    location?: StringFieldUpdateOperationsInput | string
    district?: StringFieldUpdateOperationsInput | string
    province?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    birthDay?: IntFieldUpdateOperationsInput | number
    birthMonth?: IntFieldUpdateOperationsInput | number
    birthYear?: NullableIntFieldUpdateOperationsInput | number | null
    loyaltyPoints?: IntFieldUpdateOperationsInput | number
    totalSpent?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    additionalLocation?: NullableStringFieldUpdateOperationsInput | string | null
    isDependent?: BoolFieldUpdateOperationsInput | boolean
    lastSale?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    saleCount?: IntFieldUpdateOperationsInput | number
    sector?: NullableStringFieldUpdateOperationsInput | string | null
    dependents?: CustomerUncheckedUpdateManyWithoutParentNestedInput
    sales?: SaleUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type DiscountRuleUpsertWithoutCustomerDiscountsInput = {
    update: XOR<DiscountRuleUpdateWithoutCustomerDiscountsInput, DiscountRuleUncheckedUpdateWithoutCustomerDiscountsInput>
    create: XOR<DiscountRuleCreateWithoutCustomerDiscountsInput, DiscountRuleUncheckedCreateWithoutCustomerDiscountsInput>
    where?: DiscountRuleWhereInput
  }

  export type DiscountRuleUpdateToOneWithWhereWithoutCustomerDiscountsInput = {
    where?: DiscountRuleWhereInput
    data: XOR<DiscountRuleUpdateWithoutCustomerDiscountsInput, DiscountRuleUncheckedUpdateWithoutCustomerDiscountsInput>
  }

  export type DiscountRuleUpdateWithoutCustomerDiscountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumDiscountTypeFieldUpdateOperationsInput | $Enums.DiscountType
    value?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isPercentage?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    minAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    maxDiscount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    saleDiscounts?: SaleDiscountUpdateManyWithoutDiscountRuleNestedInput
  }

  export type DiscountRuleUncheckedUpdateWithoutCustomerDiscountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumDiscountTypeFieldUpdateOperationsInput | $Enums.DiscountType
    value?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isPercentage?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    minAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    maxDiscount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    saleDiscounts?: SaleDiscountUncheckedUpdateManyWithoutDiscountRuleNestedInput
  }

  export type SaleCreateWithoutPaymentsInput = {
    id?: string
    saleDate?: Date | string
    totalAmount: Decimal | DecimalJsLike | number | string
    discountAmount?: Decimal | DecimalJsLike | number | string
    finalAmount: Decimal | DecimalJsLike | number | string
    loyaltyPointsEarned?: number
    notes?: string | null
    isCompleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    birthMonthDiscount?: boolean
    ownShampooDiscount?: boolean
    paymentMethod?: $Enums.PaymentMethod
    discounts?: SaleDiscountCreateNestedManyWithoutSaleInput
    services?: SaleServiceCreateNestedManyWithoutSaleInput
    products?: SaleProductCreateNestedManyWithoutSaleInput
    staff?: SaleStaffCreateNestedManyWithoutSaleInput
    createdBy: UserCreateNestedOneWithoutSalesInput
    customer: CustomerCreateNestedOneWithoutSalesInput
  }

  export type SaleUncheckedCreateWithoutPaymentsInput = {
    id?: string
    customerId: string
    saleDate?: Date | string
    totalAmount: Decimal | DecimalJsLike | number | string
    discountAmount?: Decimal | DecimalJsLike | number | string
    finalAmount: Decimal | DecimalJsLike | number | string
    loyaltyPointsEarned?: number
    notes?: string | null
    isCompleted?: boolean
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
    birthMonthDiscount?: boolean
    ownShampooDiscount?: boolean
    paymentMethod?: $Enums.PaymentMethod
    discounts?: SaleDiscountUncheckedCreateNestedManyWithoutSaleInput
    services?: SaleServiceUncheckedCreateNestedManyWithoutSaleInput
    products?: SaleProductUncheckedCreateNestedManyWithoutSaleInput
    staff?: SaleStaffUncheckedCreateNestedManyWithoutSaleInput
  }

  export type SaleCreateOrConnectWithoutPaymentsInput = {
    where: SaleWhereUniqueInput
    create: XOR<SaleCreateWithoutPaymentsInput, SaleUncheckedCreateWithoutPaymentsInput>
  }

  export type SaleUpsertWithoutPaymentsInput = {
    update: XOR<SaleUpdateWithoutPaymentsInput, SaleUncheckedUpdateWithoutPaymentsInput>
    create: XOR<SaleCreateWithoutPaymentsInput, SaleUncheckedCreateWithoutPaymentsInput>
    where?: SaleWhereInput
  }

  export type SaleUpdateToOneWithWhereWithoutPaymentsInput = {
    where?: SaleWhereInput
    data: XOR<SaleUpdateWithoutPaymentsInput, SaleUncheckedUpdateWithoutPaymentsInput>
  }

  export type SaleUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    saleDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    finalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    loyaltyPointsEarned?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    birthMonthDiscount?: BoolFieldUpdateOperationsInput | boolean
    ownShampooDiscount?: BoolFieldUpdateOperationsInput | boolean
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    discounts?: SaleDiscountUpdateManyWithoutSaleNestedInput
    services?: SaleServiceUpdateManyWithoutSaleNestedInput
    products?: SaleProductUpdateManyWithoutSaleNestedInput
    staff?: SaleStaffUpdateManyWithoutSaleNestedInput
    createdBy?: UserUpdateOneRequiredWithoutSalesNestedInput
    customer?: CustomerUpdateOneRequiredWithoutSalesNestedInput
  }

  export type SaleUncheckedUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    saleDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    finalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    loyaltyPointsEarned?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    birthMonthDiscount?: BoolFieldUpdateOperationsInput | boolean
    ownShampooDiscount?: BoolFieldUpdateOperationsInput | boolean
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    discounts?: SaleDiscountUncheckedUpdateManyWithoutSaleNestedInput
    services?: SaleServiceUncheckedUpdateManyWithoutSaleNestedInput
    products?: SaleProductUncheckedUpdateManyWithoutSaleNestedInput
    staff?: SaleStaffUncheckedUpdateManyWithoutSaleNestedInput
  }

  export type SaleProductCreateWithoutProductInput = {
    id?: string
    quantity?: number
    unitPrice: Decimal | DecimalJsLike | number | string
    totalPrice: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    sale: SaleCreateNestedOneWithoutProductsInput
  }

  export type SaleProductUncheckedCreateWithoutProductInput = {
    id?: string
    saleId: string
    quantity?: number
    unitPrice: Decimal | DecimalJsLike | number | string
    totalPrice: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
  }

  export type SaleProductCreateOrConnectWithoutProductInput = {
    where: SaleProductWhereUniqueInput
    create: XOR<SaleProductCreateWithoutProductInput, SaleProductUncheckedCreateWithoutProductInput>
  }

  export type SaleProductCreateManyProductInputEnvelope = {
    data: SaleProductCreateManyProductInput | SaleProductCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type SaleProductUpsertWithWhereUniqueWithoutProductInput = {
    where: SaleProductWhereUniqueInput
    update: XOR<SaleProductUpdateWithoutProductInput, SaleProductUncheckedUpdateWithoutProductInput>
    create: XOR<SaleProductCreateWithoutProductInput, SaleProductUncheckedCreateWithoutProductInput>
  }

  export type SaleProductUpdateWithWhereUniqueWithoutProductInput = {
    where: SaleProductWhereUniqueInput
    data: XOR<SaleProductUpdateWithoutProductInput, SaleProductUncheckedUpdateWithoutProductInput>
  }

  export type SaleProductUpdateManyWithWhereWithoutProductInput = {
    where: SaleProductScalarWhereInput
    data: XOR<SaleProductUpdateManyMutationInput, SaleProductUncheckedUpdateManyWithoutProductInput>
  }

  export type SaleCreateWithoutProductsInput = {
    id?: string
    saleDate?: Date | string
    totalAmount: Decimal | DecimalJsLike | number | string
    discountAmount?: Decimal | DecimalJsLike | number | string
    finalAmount: Decimal | DecimalJsLike | number | string
    loyaltyPointsEarned?: number
    notes?: string | null
    isCompleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    birthMonthDiscount?: boolean
    ownShampooDiscount?: boolean
    paymentMethod?: $Enums.PaymentMethod
    discounts?: SaleDiscountCreateNestedManyWithoutSaleInput
    services?: SaleServiceCreateNestedManyWithoutSaleInput
    staff?: SaleStaffCreateNestedManyWithoutSaleInput
    payments?: SalePaymentCreateNestedManyWithoutSaleInput
    createdBy: UserCreateNestedOneWithoutSalesInput
    customer: CustomerCreateNestedOneWithoutSalesInput
  }

  export type SaleUncheckedCreateWithoutProductsInput = {
    id?: string
    customerId: string
    saleDate?: Date | string
    totalAmount: Decimal | DecimalJsLike | number | string
    discountAmount?: Decimal | DecimalJsLike | number | string
    finalAmount: Decimal | DecimalJsLike | number | string
    loyaltyPointsEarned?: number
    notes?: string | null
    isCompleted?: boolean
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
    birthMonthDiscount?: boolean
    ownShampooDiscount?: boolean
    paymentMethod?: $Enums.PaymentMethod
    discounts?: SaleDiscountUncheckedCreateNestedManyWithoutSaleInput
    services?: SaleServiceUncheckedCreateNestedManyWithoutSaleInput
    staff?: SaleStaffUncheckedCreateNestedManyWithoutSaleInput
    payments?: SalePaymentUncheckedCreateNestedManyWithoutSaleInput
  }

  export type SaleCreateOrConnectWithoutProductsInput = {
    where: SaleWhereUniqueInput
    create: XOR<SaleCreateWithoutProductsInput, SaleUncheckedCreateWithoutProductsInput>
  }

  export type ProductCreateWithoutSaleProductsInput = {
    id?: string
    name: string
    description?: string | null
    price: Decimal | DecimalJsLike | number | string
    quantity?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductUncheckedCreateWithoutSaleProductsInput = {
    id?: string
    name: string
    description?: string | null
    price: Decimal | DecimalJsLike | number | string
    quantity?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductCreateOrConnectWithoutSaleProductsInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutSaleProductsInput, ProductUncheckedCreateWithoutSaleProductsInput>
  }

  export type SaleUpsertWithoutProductsInput = {
    update: XOR<SaleUpdateWithoutProductsInput, SaleUncheckedUpdateWithoutProductsInput>
    create: XOR<SaleCreateWithoutProductsInput, SaleUncheckedCreateWithoutProductsInput>
    where?: SaleWhereInput
  }

  export type SaleUpdateToOneWithWhereWithoutProductsInput = {
    where?: SaleWhereInput
    data: XOR<SaleUpdateWithoutProductsInput, SaleUncheckedUpdateWithoutProductsInput>
  }

  export type SaleUpdateWithoutProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    saleDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    finalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    loyaltyPointsEarned?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    birthMonthDiscount?: BoolFieldUpdateOperationsInput | boolean
    ownShampooDiscount?: BoolFieldUpdateOperationsInput | boolean
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    discounts?: SaleDiscountUpdateManyWithoutSaleNestedInput
    services?: SaleServiceUpdateManyWithoutSaleNestedInput
    staff?: SaleStaffUpdateManyWithoutSaleNestedInput
    payments?: SalePaymentUpdateManyWithoutSaleNestedInput
    createdBy?: UserUpdateOneRequiredWithoutSalesNestedInput
    customer?: CustomerUpdateOneRequiredWithoutSalesNestedInput
  }

  export type SaleUncheckedUpdateWithoutProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    saleDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    finalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    loyaltyPointsEarned?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    birthMonthDiscount?: BoolFieldUpdateOperationsInput | boolean
    ownShampooDiscount?: BoolFieldUpdateOperationsInput | boolean
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    discounts?: SaleDiscountUncheckedUpdateManyWithoutSaleNestedInput
    services?: SaleServiceUncheckedUpdateManyWithoutSaleNestedInput
    staff?: SaleStaffUncheckedUpdateManyWithoutSaleNestedInput
    payments?: SalePaymentUncheckedUpdateManyWithoutSaleNestedInput
  }

  export type ProductUpsertWithoutSaleProductsInput = {
    update: XOR<ProductUpdateWithoutSaleProductsInput, ProductUncheckedUpdateWithoutSaleProductsInput>
    create: XOR<ProductCreateWithoutSaleProductsInput, ProductUncheckedCreateWithoutSaleProductsInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutSaleProductsInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutSaleProductsInput, ProductUncheckedUpdateWithoutSaleProductsInput>
  }

  export type ProductUpdateWithoutSaleProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    quantity?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductUncheckedUpdateWithoutSaleProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    quantity?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SaleStaffCreateManyStaffInput = {
    id?: string
    saleId: string
    customName?: string | null
    serviceId?: string | null
    createdAt?: Date | string
  }

  export type SaleCreateManyCreatedByInput = {
    id?: string
    customerId: string
    saleDate?: Date | string
    totalAmount: Decimal | DecimalJsLike | number | string
    discountAmount?: Decimal | DecimalJsLike | number | string
    finalAmount: Decimal | DecimalJsLike | number | string
    loyaltyPointsEarned?: number
    notes?: string | null
    isCompleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    birthMonthDiscount?: boolean
    ownShampooDiscount?: boolean
    paymentMethod?: $Enums.PaymentMethod
  }

  export type SaleStaffUpdateWithoutStaffInput = {
    id?: StringFieldUpdateOperationsInput | string
    customName?: NullableStringFieldUpdateOperationsInput | string | null
    serviceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sale?: SaleUpdateOneRequiredWithoutStaffNestedInput
  }

  export type SaleStaffUncheckedUpdateWithoutStaffInput = {
    id?: StringFieldUpdateOperationsInput | string
    saleId?: StringFieldUpdateOperationsInput | string
    customName?: NullableStringFieldUpdateOperationsInput | string | null
    serviceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SaleStaffUncheckedUpdateManyWithoutStaffInput = {
    id?: StringFieldUpdateOperationsInput | string
    saleId?: StringFieldUpdateOperationsInput | string
    customName?: NullableStringFieldUpdateOperationsInput | string | null
    serviceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SaleUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    saleDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    finalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    loyaltyPointsEarned?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    birthMonthDiscount?: BoolFieldUpdateOperationsInput | boolean
    ownShampooDiscount?: BoolFieldUpdateOperationsInput | boolean
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    discounts?: SaleDiscountUpdateManyWithoutSaleNestedInput
    services?: SaleServiceUpdateManyWithoutSaleNestedInput
    products?: SaleProductUpdateManyWithoutSaleNestedInput
    staff?: SaleStaffUpdateManyWithoutSaleNestedInput
    payments?: SalePaymentUpdateManyWithoutSaleNestedInput
    customer?: CustomerUpdateOneRequiredWithoutSalesNestedInput
  }

  export type SaleUncheckedUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    saleDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    finalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    loyaltyPointsEarned?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    birthMonthDiscount?: BoolFieldUpdateOperationsInput | boolean
    ownShampooDiscount?: BoolFieldUpdateOperationsInput | boolean
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    discounts?: SaleDiscountUncheckedUpdateManyWithoutSaleNestedInput
    services?: SaleServiceUncheckedUpdateManyWithoutSaleNestedInput
    products?: SaleProductUncheckedUpdateManyWithoutSaleNestedInput
    staff?: SaleStaffUncheckedUpdateManyWithoutSaleNestedInput
    payments?: SalePaymentUncheckedUpdateManyWithoutSaleNestedInput
  }

  export type SaleUncheckedUpdateManyWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    saleDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    finalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    loyaltyPointsEarned?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    birthMonthDiscount?: BoolFieldUpdateOperationsInput | boolean
    ownShampooDiscount?: BoolFieldUpdateOperationsInput | boolean
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
  }

  export type CustomerDiscountCreateManyCustomerInput = {
    id?: string
    discountRuleId: string
    usedAt?: Date | string
    discountAmount: Decimal | DecimalJsLike | number | string
  }

  export type CustomerCreateManyParentInput = {
    id?: string
    fullName: string
    gender: $Enums.Gender
    location: string
    district: string
    province: string
    phone?: string | null
    email?: string | null
    birthDay: number
    birthMonth: number
    birthYear?: number | null
    loyaltyPoints?: number
    totalSpent?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    isActive?: boolean
    additionalLocation?: string | null
    isDependent?: boolean
    lastSale?: Date | string | null
    saleCount?: number
    sector?: string | null
  }

  export type SaleCreateManyCustomerInput = {
    id?: string
    saleDate?: Date | string
    totalAmount: Decimal | DecimalJsLike | number | string
    discountAmount?: Decimal | DecimalJsLike | number | string
    finalAmount: Decimal | DecimalJsLike | number | string
    loyaltyPointsEarned?: number
    notes?: string | null
    isCompleted?: boolean
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
    birthMonthDiscount?: boolean
    ownShampooDiscount?: boolean
    paymentMethod?: $Enums.PaymentMethod
  }

  export type CustomerDiscountUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    usedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountRule?: DiscountRuleUpdateOneRequiredWithoutCustomerDiscountsNestedInput
  }

  export type CustomerDiscountUncheckedUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    discountRuleId?: StringFieldUpdateOperationsInput | string
    usedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type CustomerDiscountUncheckedUpdateManyWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    discountRuleId?: StringFieldUpdateOperationsInput | string
    usedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type CustomerUpdateWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    location?: StringFieldUpdateOperationsInput | string
    district?: StringFieldUpdateOperationsInput | string
    province?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    birthDay?: IntFieldUpdateOperationsInput | number
    birthMonth?: IntFieldUpdateOperationsInput | number
    birthYear?: NullableIntFieldUpdateOperationsInput | number | null
    loyaltyPoints?: IntFieldUpdateOperationsInput | number
    totalSpent?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    additionalLocation?: NullableStringFieldUpdateOperationsInput | string | null
    isDependent?: BoolFieldUpdateOperationsInput | boolean
    lastSale?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    saleCount?: IntFieldUpdateOperationsInput | number
    sector?: NullableStringFieldUpdateOperationsInput | string | null
    discounts?: CustomerDiscountUpdateManyWithoutCustomerNestedInput
    dependents?: CustomerUpdateManyWithoutParentNestedInput
    sales?: SaleUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    location?: StringFieldUpdateOperationsInput | string
    district?: StringFieldUpdateOperationsInput | string
    province?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    birthDay?: IntFieldUpdateOperationsInput | number
    birthMonth?: IntFieldUpdateOperationsInput | number
    birthYear?: NullableIntFieldUpdateOperationsInput | number | null
    loyaltyPoints?: IntFieldUpdateOperationsInput | number
    totalSpent?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    additionalLocation?: NullableStringFieldUpdateOperationsInput | string | null
    isDependent?: BoolFieldUpdateOperationsInput | boolean
    lastSale?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    saleCount?: IntFieldUpdateOperationsInput | number
    sector?: NullableStringFieldUpdateOperationsInput | string | null
    discounts?: CustomerDiscountUncheckedUpdateManyWithoutCustomerNestedInput
    dependents?: CustomerUncheckedUpdateManyWithoutParentNestedInput
    sales?: SaleUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateManyWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    location?: StringFieldUpdateOperationsInput | string
    district?: StringFieldUpdateOperationsInput | string
    province?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    birthDay?: IntFieldUpdateOperationsInput | number
    birthMonth?: IntFieldUpdateOperationsInput | number
    birthYear?: NullableIntFieldUpdateOperationsInput | number | null
    loyaltyPoints?: IntFieldUpdateOperationsInput | number
    totalSpent?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    additionalLocation?: NullableStringFieldUpdateOperationsInput | string | null
    isDependent?: BoolFieldUpdateOperationsInput | boolean
    lastSale?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    saleCount?: IntFieldUpdateOperationsInput | number
    sector?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SaleUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    saleDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    finalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    loyaltyPointsEarned?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    birthMonthDiscount?: BoolFieldUpdateOperationsInput | boolean
    ownShampooDiscount?: BoolFieldUpdateOperationsInput | boolean
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    discounts?: SaleDiscountUpdateManyWithoutSaleNestedInput
    services?: SaleServiceUpdateManyWithoutSaleNestedInput
    products?: SaleProductUpdateManyWithoutSaleNestedInput
    staff?: SaleStaffUpdateManyWithoutSaleNestedInput
    payments?: SalePaymentUpdateManyWithoutSaleNestedInput
    createdBy?: UserUpdateOneRequiredWithoutSalesNestedInput
  }

  export type SaleUncheckedUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    saleDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    finalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    loyaltyPointsEarned?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    birthMonthDiscount?: BoolFieldUpdateOperationsInput | boolean
    ownShampooDiscount?: BoolFieldUpdateOperationsInput | boolean
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    discounts?: SaleDiscountUncheckedUpdateManyWithoutSaleNestedInput
    services?: SaleServiceUncheckedUpdateManyWithoutSaleNestedInput
    products?: SaleProductUncheckedUpdateManyWithoutSaleNestedInput
    staff?: SaleStaffUncheckedUpdateManyWithoutSaleNestedInput
    payments?: SalePaymentUncheckedUpdateManyWithoutSaleNestedInput
  }

  export type SaleUncheckedUpdateManyWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    saleDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    finalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    loyaltyPointsEarned?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    birthMonthDiscount?: BoolFieldUpdateOperationsInput | boolean
    ownShampooDiscount?: BoolFieldUpdateOperationsInput | boolean
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
  }

  export type SaleServiceCreateManyServiceInput = {
    id?: string
    saleId: string
    quantity?: number
    unitPrice: Decimal | DecimalJsLike | number | string
    totalPrice: Decimal | DecimalJsLike | number | string
    isChild?: boolean
    isCombined?: boolean
    addShampoo?: boolean
    createdAt?: Date | string
  }

  export type SaleServiceUpdateWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isChild?: BoolFieldUpdateOperationsInput | boolean
    isCombined?: BoolFieldUpdateOperationsInput | boolean
    addShampoo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sale?: SaleUpdateOneRequiredWithoutServicesNestedInput
  }

  export type SaleServiceUncheckedUpdateWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    saleId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isChild?: BoolFieldUpdateOperationsInput | boolean
    isCombined?: BoolFieldUpdateOperationsInput | boolean
    addShampoo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SaleServiceUncheckedUpdateManyWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    saleId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isChild?: BoolFieldUpdateOperationsInput | boolean
    isCombined?: BoolFieldUpdateOperationsInput | boolean
    addShampoo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SaleDiscountCreateManySaleInput = {
    id?: string
    discountRuleId: string
    discountAmount: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
  }

  export type SaleServiceCreateManySaleInput = {
    id?: string
    serviceId: string
    quantity?: number
    unitPrice: Decimal | DecimalJsLike | number | string
    totalPrice: Decimal | DecimalJsLike | number | string
    isChild?: boolean
    isCombined?: boolean
    addShampoo?: boolean
    createdAt?: Date | string
  }

  export type SaleProductCreateManySaleInput = {
    id?: string
    productId: string
    quantity?: number
    unitPrice: Decimal | DecimalJsLike | number | string
    totalPrice: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
  }

  export type SaleStaffCreateManySaleInput = {
    id?: string
    staffId?: string | null
    customName?: string | null
    serviceId?: string | null
    createdAt?: Date | string
  }

  export type SalePaymentCreateManySaleInput = {
    id?: string
    paymentMethod: $Enums.PaymentMethod
    amount: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
  }

  export type SaleDiscountUpdateWithoutSaleInput = {
    id?: StringFieldUpdateOperationsInput | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    discountRule?: DiscountRuleUpdateOneRequiredWithoutSaleDiscountsNestedInput
  }

  export type SaleDiscountUncheckedUpdateWithoutSaleInput = {
    id?: StringFieldUpdateOperationsInput | string
    discountRuleId?: StringFieldUpdateOperationsInput | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SaleDiscountUncheckedUpdateManyWithoutSaleInput = {
    id?: StringFieldUpdateOperationsInput | string
    discountRuleId?: StringFieldUpdateOperationsInput | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SaleServiceUpdateWithoutSaleInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isChild?: BoolFieldUpdateOperationsInput | boolean
    isCombined?: BoolFieldUpdateOperationsInput | boolean
    addShampoo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    service?: ServiceUpdateOneRequiredWithoutSaleServicesNestedInput
  }

  export type SaleServiceUncheckedUpdateWithoutSaleInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isChild?: BoolFieldUpdateOperationsInput | boolean
    isCombined?: BoolFieldUpdateOperationsInput | boolean
    addShampoo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SaleServiceUncheckedUpdateManyWithoutSaleInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isChild?: BoolFieldUpdateOperationsInput | boolean
    isCombined?: BoolFieldUpdateOperationsInput | boolean
    addShampoo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SaleProductUpdateWithoutSaleInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutSaleProductsNestedInput
  }

  export type SaleProductUncheckedUpdateWithoutSaleInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SaleProductUncheckedUpdateManyWithoutSaleInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SaleStaffUpdateWithoutSaleInput = {
    id?: StringFieldUpdateOperationsInput | string
    customName?: NullableStringFieldUpdateOperationsInput | string | null
    serviceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    staff?: UserUpdateOneWithoutStaffSalesNestedInput
  }

  export type SaleStaffUncheckedUpdateWithoutSaleInput = {
    id?: StringFieldUpdateOperationsInput | string
    staffId?: NullableStringFieldUpdateOperationsInput | string | null
    customName?: NullableStringFieldUpdateOperationsInput | string | null
    serviceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SaleStaffUncheckedUpdateManyWithoutSaleInput = {
    id?: StringFieldUpdateOperationsInput | string
    staffId?: NullableStringFieldUpdateOperationsInput | string | null
    customName?: NullableStringFieldUpdateOperationsInput | string | null
    serviceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SalePaymentUpdateWithoutSaleInput = {
    id?: StringFieldUpdateOperationsInput | string
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SalePaymentUncheckedUpdateWithoutSaleInput = {
    id?: StringFieldUpdateOperationsInput | string
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SalePaymentUncheckedUpdateManyWithoutSaleInput = {
    id?: StringFieldUpdateOperationsInput | string
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerDiscountCreateManyDiscountRuleInput = {
    id?: string
    customerId: string
    usedAt?: Date | string
    discountAmount: Decimal | DecimalJsLike | number | string
  }

  export type SaleDiscountCreateManyDiscountRuleInput = {
    id?: string
    saleId: string
    discountAmount: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
  }

  export type CustomerDiscountUpdateWithoutDiscountRuleInput = {
    id?: StringFieldUpdateOperationsInput | string
    usedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    customer?: CustomerUpdateOneRequiredWithoutDiscountsNestedInput
  }

  export type CustomerDiscountUncheckedUpdateWithoutDiscountRuleInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    usedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type CustomerDiscountUncheckedUpdateManyWithoutDiscountRuleInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    usedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type SaleDiscountUpdateWithoutDiscountRuleInput = {
    id?: StringFieldUpdateOperationsInput | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sale?: SaleUpdateOneRequiredWithoutDiscountsNestedInput
  }

  export type SaleDiscountUncheckedUpdateWithoutDiscountRuleInput = {
    id?: StringFieldUpdateOperationsInput | string
    saleId?: StringFieldUpdateOperationsInput | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SaleDiscountUncheckedUpdateManyWithoutDiscountRuleInput = {
    id?: StringFieldUpdateOperationsInput | string
    saleId?: StringFieldUpdateOperationsInput | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SaleProductCreateManyProductInput = {
    id?: string
    saleId: string
    quantity?: number
    unitPrice: Decimal | DecimalJsLike | number | string
    totalPrice: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
  }

  export type SaleProductUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sale?: SaleUpdateOneRequiredWithoutProductsNestedInput
  }

  export type SaleProductUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    saleId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SaleProductUncheckedUpdateManyWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    saleId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}